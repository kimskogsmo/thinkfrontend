/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FirebaseError\": () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   \"SDK_VERSION\": () => (/* binding */ SDK_VERSION),\n/* harmony export */   \"_DEFAULT_ENTRY_NAME\": () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   \"_addComponent\": () => (/* binding */ _addComponent),\n/* harmony export */   \"_addOrOverwriteComponent\": () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   \"_apps\": () => (/* binding */ _apps),\n/* harmony export */   \"_clearComponents\": () => (/* binding */ _clearComponents),\n/* harmony export */   \"_components\": () => (/* binding */ _components),\n/* harmony export */   \"_getProvider\": () => (/* binding */ _getProvider),\n/* harmony export */   \"_registerComponent\": () => (/* binding */ _registerComponent),\n/* harmony export */   \"_removeServiceInstance\": () => (/* binding */ _removeServiceInstance),\n/* harmony export */   \"deleteApp\": () => (/* binding */ deleteApp),\n/* harmony export */   \"getApp\": () => (/* binding */ getApp),\n/* harmony export */   \"getApps\": () => (/* binding */ getApps),\n/* harmony export */   \"initializeApp\": () => (/* binding */ initializeApp),\n/* harmony export */   \"onLog\": () => (/* binding */ onLog),\n/* harmony export */   \"registerVersion\": () => (/* binding */ registerVersion),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"./node_modules/@firebase/util/dist/index.esm2017.js\");\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nclass PlatformLoggerServiceImpl {\n  constructor(container) {\n    this.container = container;\n  } // In initial implementation, this will be called by installations on\n  // auth token refresh, and installations will send this string.\n\n\n  getPlatformInfoString() {\n    const providers = this.container.getProviders(); // Loop through providers and get library/version pairs from any that are\n    // version components.\n\n    return providers.map(provider => {\n      if (isVersionServiceProvider(provider)) {\n        const service = provider.getImmediate();\n        return `${service.library}/${service.version}`;\n      } else {\n        return null;\n      }\n    }).filter(logString => logString).join(' ');\n  }\n\n}\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */\n\n\nfunction isVersionServiceProvider(provider) {\n  const component = provider.getComponent();\n  return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\"\n  /* VERSION */\n  ;\n}\n\nconst name$o = \"@firebase/app\";\nconst version$1 = \"0.7.11\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\nconst name$n = \"@firebase/app-compat\";\nconst name$m = \"@firebase/analytics-compat\";\nconst name$l = \"@firebase/analytics\";\nconst name$k = \"@firebase/app-check-compat\";\nconst name$j = \"@firebase/app-check\";\nconst name$i = \"@firebase/auth\";\nconst name$h = \"@firebase/auth-compat\";\nconst name$g = \"@firebase/database\";\nconst name$f = \"@firebase/database-compat\";\nconst name$e = \"@firebase/functions\";\nconst name$d = \"@firebase/functions-compat\";\nconst name$c = \"@firebase/installations\";\nconst name$b = \"@firebase/installations-compat\";\nconst name$a = \"@firebase/messaging\";\nconst name$9 = \"@firebase/messaging-compat\";\nconst name$8 = \"@firebase/performance\";\nconst name$7 = \"@firebase/performance-compat\";\nconst name$6 = \"@firebase/remote-config\";\nconst name$5 = \"@firebase/remote-config-compat\";\nconst name$4 = \"@firebase/storage\";\nconst name$3 = \"@firebase/storage-compat\";\nconst name$2 = \"@firebase/firestore\";\nconst name$1 = \"@firebase/firestore-compat\";\nconst name = \"firebase\";\nconst version = \"9.6.1\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * The default app name\r\n *\r\n * @internal\r\n */\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\nconst PLATFORM_LOG_STRING = {\n  [name$o]: 'fire-core',\n  [name$n]: 'fire-core-compat',\n  [name$l]: 'fire-analytics',\n  [name$m]: 'fire-analytics-compat',\n  [name$j]: 'fire-app-check',\n  [name$k]: 'fire-app-check-compat',\n  [name$i]: 'fire-auth',\n  [name$h]: 'fire-auth-compat',\n  [name$g]: 'fire-rtdb',\n  [name$f]: 'fire-rtdb-compat',\n  [name$e]: 'fire-fn',\n  [name$d]: 'fire-fn-compat',\n  [name$c]: 'fire-iid',\n  [name$b]: 'fire-iid-compat',\n  [name$a]: 'fire-fcm',\n  [name$9]: 'fire-fcm-compat',\n  [name$8]: 'fire-perf',\n  [name$7]: 'fire-perf-compat',\n  [name$6]: 'fire-rc',\n  [name$5]: 'fire-rc-compat',\n  [name$4]: 'fire-gcs',\n  [name$3]: 'fire-gcs-compat',\n  [name$2]: 'fire-fst',\n  [name$1]: 'fire-fst-compat',\n  'fire-js': 'fire-js',\n  [name]: 'fire-js-all'\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * @internal\r\n */\n\nconst _apps = new Map();\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nconst _components = new Map();\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */\n\n\nfunction _addComponent(app, component) {\n  try {\n    app.container.addComponent(component);\n  } catch (e) {\n    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n  }\n}\n/**\r\n *\r\n * @internal\r\n */\n\n\nfunction _addOrOverwriteComponent(app, component) {\n  app.container.addOrOverwriteComponent(component);\n}\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */\n\n\nfunction _registerComponent(component) {\n  const componentName = component.name;\n\n  if (_components.has(componentName)) {\n    logger.debug(`There were multiple attempts to register component ${componentName}.`);\n    return false;\n  }\n\n  _components.set(componentName, component); // add the component to existing app instances\n\n\n  for (const app of _apps.values()) {\n    _addComponent(app, component);\n  }\n\n  return true;\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */\n\n\nfunction _getProvider(app, name) {\n  return app.container.getProvider(name);\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */\n\n\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n  _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */\n\n\nfunction _clearComponents() {\n  _components.clear();\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst ERRORS = {\n  [\"no-app\"\n  /* NO_APP */\n  ]: \"No Firebase App '{$appName}' has been created - \" + 'call Firebase App.initializeApp()',\n  [\"bad-app-name\"\n  /* BAD_APP_NAME */\n  ]: \"Illegal App name: '{$appName}\",\n  [\"duplicate-app\"\n  /* DUPLICATE_APP */\n  ]: \"Firebase App named '{$appName}' already exists with different options or config\",\n  [\"app-deleted\"\n  /* APP_DELETED */\n  ]: \"Firebase App named '{$appName}' already deleted\",\n  [\"invalid-app-argument\"\n  /* INVALID_APP_ARGUMENT */\n  ]: 'firebase.{$appName}() takes either no argument or a ' + 'Firebase App instance.',\n  [\"invalid-log-argument\"\n  /* INVALID_LOG_ARGUMENT */\n  ]: 'First argument to `onLog` must be null or a function.'\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nclass FirebaseAppImpl {\n  constructor(options, config, container) {\n    this._isDeleted = false;\n    this._options = Object.assign({}, options);\n    this._config = Object.assign({}, config);\n    this._name = config.name;\n    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n    this._container = container;\n    this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\"\n    /* PUBLIC */\n    ));\n  }\n\n  get automaticDataCollectionEnabled() {\n    this.checkDestroyed();\n    return this._automaticDataCollectionEnabled;\n  }\n\n  set automaticDataCollectionEnabled(val) {\n    this.checkDestroyed();\n    this._automaticDataCollectionEnabled = val;\n  }\n\n  get name() {\n    this.checkDestroyed();\n    return this._name;\n  }\n\n  get options() {\n    this.checkDestroyed();\n    return this._options;\n  }\n\n  get config() {\n    this.checkDestroyed();\n    return this._config;\n  }\n\n  get container() {\n    return this._container;\n  }\n\n  get isDeleted() {\n    return this._isDeleted;\n  }\n\n  set isDeleted(val) {\n    this._isDeleted = val;\n  }\n  /**\r\n   * This function will throw an Error if the App has already been deleted -\r\n   * use before performing API actions on the App.\r\n   */\n\n\n  checkDestroyed() {\n    if (this.isDeleted) {\n      throw ERROR_FACTORY.create(\"app-deleted\"\n      /* APP_DELETED */\n      , {\n        appName: this._name\n      });\n    }\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */\n\n\nconst SDK_VERSION = version;\n\nfunction initializeApp(options, rawConfig = {}) {\n  if (typeof rawConfig !== 'object') {\n    const name = rawConfig;\n    rawConfig = {\n      name\n    };\n  }\n\n  const config = Object.assign({\n    name: DEFAULT_ENTRY_NAME,\n    automaticDataCollectionEnabled: false\n  }, rawConfig);\n  const name = config.name;\n\n  if (typeof name !== 'string' || !name) {\n    throw ERROR_FACTORY.create(\"bad-app-name\"\n    /* BAD_APP_NAME */\n    , {\n      appName: String(name)\n    });\n  }\n\n  const existingApp = _apps.get(name);\n\n  if (existingApp) {\n    // return the existing app if options and config deep equal the ones in the existing app.\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n      return existingApp;\n    } else {\n      throw ERROR_FACTORY.create(\"duplicate-app\"\n      /* DUPLICATE_APP */\n      , {\n        appName: name\n      });\n    }\n  }\n\n  const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n\n  for (const component of _components.values()) {\n    container.addComponent(component);\n  }\n\n  const newApp = new FirebaseAppImpl(options, config, container);\n\n  _apps.set(name, newApp);\n\n  return newApp;\n}\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */\n\n\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\n  const app = _apps.get(name);\n\n  if (!app) {\n    throw ERROR_FACTORY.create(\"no-app\"\n    /* NO_APP */\n    , {\n      appName: name\n    });\n  }\n\n  return app;\n}\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */\n\n\nfunction getApps() {\n  return Array.from(_apps.values());\n}\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */\n\n\nasync function deleteApp(app) {\n  const name = app.name;\n\n  if (_apps.has(name)) {\n    _apps.delete(name);\n\n    await Promise.all(app.container.getProviders().map(provider => provider.delete()));\n    app.isDeleted = true;\n  }\n}\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */\n\n\nfunction registerVersion(libraryKeyOrName, version, variant) {\n  var _a; // TODO: We can use this check to whitelist strings when/if we set up\n  // a good whitelist system.\n\n\n  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n\n  if (variant) {\n    library += `-${variant}`;\n  }\n\n  const libraryMismatch = library.match(/\\s|\\//);\n  const versionMismatch = version.match(/\\s|\\//);\n\n  if (libraryMismatch || versionMismatch) {\n    const warning = [`Unable to register library \"${library}\" with version \"${version}\":`];\n\n    if (libraryMismatch) {\n      warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n    }\n\n    if (libraryMismatch && versionMismatch) {\n      warning.push('and');\n    }\n\n    if (versionMismatch) {\n      warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n    }\n\n    logger.warn(warning.join(' '));\n    return;\n  }\n\n  _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({\n    library,\n    version\n  }), \"VERSION\"\n  /* VERSION */\n  ));\n}\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */\n\n\nfunction onLog(logCallback, options) {\n  if (logCallback !== null && typeof logCallback !== 'function') {\n    throw ERROR_FACTORY.create(\"invalid-log-argument\"\n    /* INVALID_LOG_ARGUMENT */\n    );\n  }\n\n  (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */\n\n\nfunction setLogLevel(logLevel) {\n  (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction registerCoreComponents(variant) {\n  _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\"\n  /* PRIVATE */\n  )); // Register `app` package.\n\n\n  registerVersion(name$o, version$1, variant); // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n\n  registerVersion(name$o, version$1, 'esm2017'); // Register platform SDK identifier (no version).\n\n  registerVersion('fire-js', '');\n}\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */\n\n\nregisterCoreComponents('');\n\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/@firebase/app/dist/esm/index.esm2017.js?");

/***/ }),

/***/ "./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": () => (/* binding */ Component),\n/* harmony export */   \"ComponentContainer\": () => (/* binding */ ComponentContainer),\n/* harmony export */   \"Provider\": () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"./node_modules/@firebase/util/dist/index.esm2017.js\");\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\n\nclass Component {\n  /**\r\n   *\r\n   * @param name The public service name, e.g. app, auth, firestore, database\r\n   * @param instanceFactory Service factory responsible for creating the public interface\r\n   * @param type whether the service provided by the component is public or private\r\n   */\n  constructor(name, instanceFactory, type) {\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\r\n     * Properties to be added to the service namespace\r\n     */\n\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\"\n    /* LAZY */\n    ;\n    this.onInstanceCreated = null;\n  }\n\n  setInstantiationMode(mode) {\n    this.instantiationMode = mode;\n    return this;\n  }\n\n  setMultipleInstances(multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  }\n\n  setServiceProps(props) {\n    this.serviceProps = props;\n    return this;\n  }\n\n  setInstanceCreatedCallback(callback) {\n    this.onInstanceCreated = callback;\n    return this;\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\n\nclass Provider {\n  constructor(name, container) {\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n    this.instancesOptions = new Map();\n    this.onInitCallbacks = new Map();\n  }\n  /**\r\n   * @param identifier A provider can provide mulitple instances of a service\r\n   * if this.component.multipleInstances is true.\r\n   */\n\n\n  get(identifier) {\n    // if multipleInstances is not supported, use the default name\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        // initialize the service if it can be auto-initialized\n        try {\n          const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {// when the instance factory throws an exception during get(), it should not cause\n          // a fatal error. We just return the unresolved promise in this case.\n        }\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  }\n\n  getImmediate(options) {\n    var _a; // if multipleInstances is not supported, use the default name\n\n\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n    const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n      if (optional) {\n        return null;\n      } else {\n        throw Error(`Service ${this.name} is not available`);\n      }\n    }\n  }\n\n  getComponent() {\n    return this.component;\n  }\n\n  setComponent(component) {\n    if (component.name !== this.name) {\n      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n    }\n\n    if (this.component) {\n      throw Error(`Component for ${this.name} has already been provided`);\n    }\n\n    this.component = component; // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n\n    if (!this.shouldAutoInitialize()) {\n      return;\n    } // if the service is eager, initialize the default instance\n\n\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({\n          instanceIdentifier: DEFAULT_ENTRY_NAME\n        });\n      } catch (e) {// when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    } // Create service instances for the pending promises and resolve them\n    // NOTE: if this.multipleInstances is false, only the default instance will be created\n    // and all promises with resolve with it regardless of the identifier.\n\n\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n      try {\n        // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n        const instance = this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n        instanceDeferred.resolve(instance);\n      } catch (e) {// when the instance factory throws an exception, it should not cause\n        // a fatal error. We just leave the promise unresolved.\n      }\n    }\n  }\n\n  clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  } // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n\n\n  async delete() {\n    const services = Array.from(this.instances.values());\n    await Promise.all([...services.filter(service => 'INTERNAL' in service) // legacy services\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    .map(service => service.INTERNAL.delete()), ...services.filter(service => '_delete' in service) // modularized services\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    .map(service => service._delete())]);\n  }\n\n  isComponentSet() {\n    return this.component != null;\n  }\n\n  isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instances.has(identifier);\n  }\n\n  getOptions(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instancesOptions.get(identifier) || {};\n  }\n\n  initialize(opts = {}) {\n    const {\n      options = {}\n    } = opts;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n    }\n\n    if (!this.isComponentSet()) {\n      throw Error(`Component ${this.name} has not been registered yet`);\n    }\n\n    const instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options\n    }); // resolve any pending promise waiting for the service instance\n\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n      if (normalizedIdentifier === normalizedDeferredIdentifier) {\n        instanceDeferred.resolve(instance);\n      }\n    }\n\n    return instance;\n  }\n  /**\r\n   *\r\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n   *\r\n   * @param identifier An optional instance identifier\r\n   * @returns a function to unregister the callback\r\n   */\n\n\n  onInit(callback, identifier) {\n    var _a;\n\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n    const existingInstance = this.instances.get(normalizedIdentifier);\n\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n\n    return () => {\n      existingCallbacks.delete(callback);\n    };\n  }\n  /**\r\n   * Invoke onInit callbacks synchronously\r\n   * @param instance the service instance`\r\n   */\n\n\n  invokeOnInitCallbacks(instance, identifier) {\n    const callbacks = this.onInitCallbacks.get(identifier);\n\n    if (!callbacks) {\n      return;\n    }\n\n    for (const callback of callbacks) {\n      try {\n        callback(instance, identifier);\n      } catch (_a) {// ignore errors in the onInit callback\n      }\n    }\n  }\n\n  getOrInitializeService({\n    instanceIdentifier,\n    options = {}\n  }) {\n    let instance = this.instances.get(instanceIdentifier);\n\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n      /**\r\n       * Invoke onInit listeners.\r\n       * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n       * while onInit listeners are registered by consumers of the provider.\r\n       */\n\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n      /**\r\n       * Order is important\r\n       * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n       * makes `isInitialized()` return true.\r\n       */\n\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n        } catch (_a) {// ignore errors in the onInstanceCreatedCallback\n        }\n      }\n    }\n\n    return instance || null;\n  }\n\n  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  }\n\n  shouldAutoInitialize() {\n    return !!this.component && this.component.instantiationMode !== \"EXPLICIT\"\n    /* EXPLICIT */\n    ;\n  }\n\n} // undefined should be passed to the service factory for the default instance\n\n\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\n\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\"\n  /* EAGER */\n  ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\n\n\nclass ComponentContainer {\n  constructor(name) {\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\r\n   *\r\n   * @param component Component being added\r\n   * @param overwrite When a component with the same name has already been registered,\r\n   * if overwrite is true: overwrite the existing component with the new component and create a new\r\n   * provider with the new component. It can be useful in tests where you want to use different mocks\r\n   * for different tests.\r\n   * if overwrite is false: throw an exception\r\n   */\n\n\n  addComponent(component) {\n    const provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n    }\n\n    provider.setComponent(component);\n  }\n\n  addOrOverwriteComponent(component) {\n    const provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n\n    this.addComponent(component);\n  }\n  /**\r\n   * getProvider provides a type safe interface where it can only be called with a field name\r\n   * present in NameServiceMapping interface.\r\n   *\r\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n   * themselves.\r\n   */\n\n\n  getProvider(name) {\n    if (this.providers.has(name)) {\n      return this.providers.get(name);\n    } // create a Provider for a service that hasn't registered with Firebase\n\n\n    const provider = new Provider(name, this);\n    this.providers.set(name, provider);\n    return provider;\n  }\n\n  getProviders() {\n    return Array.from(this.providers.values());\n  }\n\n}\n\n\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/@firebase/component/dist/esm/index.esm2017.js?");

/***/ }),

/***/ "./node_modules/@firebase/database/dist/index.esm2017.js":
/*!***************************************************************!*\
  !*** ./node_modules/@firebase/database/dist/index.esm2017.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataSnapshot\": () => (/* binding */ DataSnapshot),\n/* harmony export */   \"Database\": () => (/* binding */ Database),\n/* harmony export */   \"OnDisconnect\": () => (/* binding */ OnDisconnect),\n/* harmony export */   \"QueryConstraint\": () => (/* binding */ QueryConstraint),\n/* harmony export */   \"TransactionResult\": () => (/* binding */ TransactionResult),\n/* harmony export */   \"_QueryImpl\": () => (/* binding */ QueryImpl),\n/* harmony export */   \"_QueryParams\": () => (/* binding */ QueryParams),\n/* harmony export */   \"_ReferenceImpl\": () => (/* binding */ ReferenceImpl),\n/* harmony export */   \"_TEST_ACCESS_forceRestClient\": () => (/* binding */ forceRestClient),\n/* harmony export */   \"_TEST_ACCESS_hijackHash\": () => (/* binding */ hijackHash),\n/* harmony export */   \"_repoManagerDatabaseFromApp\": () => (/* binding */ repoManagerDatabaseFromApp),\n/* harmony export */   \"_setSDKVersion\": () => (/* binding */ setSDKVersion),\n/* harmony export */   \"_validatePathString\": () => (/* binding */ validatePathString),\n/* harmony export */   \"_validateWritablePath\": () => (/* binding */ validateWritablePath),\n/* harmony export */   \"child\": () => (/* binding */ child),\n/* harmony export */   \"connectDatabaseEmulator\": () => (/* binding */ connectDatabaseEmulator),\n/* harmony export */   \"enableLogging\": () => (/* binding */ enableLogging),\n/* harmony export */   \"endAt\": () => (/* binding */ endAt),\n/* harmony export */   \"endBefore\": () => (/* binding */ endBefore),\n/* harmony export */   \"equalTo\": () => (/* binding */ equalTo),\n/* harmony export */   \"get\": () => (/* binding */ get),\n/* harmony export */   \"getDatabase\": () => (/* binding */ getDatabase),\n/* harmony export */   \"goOffline\": () => (/* binding */ goOffline),\n/* harmony export */   \"goOnline\": () => (/* binding */ goOnline),\n/* harmony export */   \"increment\": () => (/* binding */ increment),\n/* harmony export */   \"limitToFirst\": () => (/* binding */ limitToFirst),\n/* harmony export */   \"limitToLast\": () => (/* binding */ limitToLast),\n/* harmony export */   \"off\": () => (/* binding */ off),\n/* harmony export */   \"onChildAdded\": () => (/* binding */ onChildAdded),\n/* harmony export */   \"onChildChanged\": () => (/* binding */ onChildChanged),\n/* harmony export */   \"onChildMoved\": () => (/* binding */ onChildMoved),\n/* harmony export */   \"onChildRemoved\": () => (/* binding */ onChildRemoved),\n/* harmony export */   \"onDisconnect\": () => (/* binding */ onDisconnect),\n/* harmony export */   \"onValue\": () => (/* binding */ onValue),\n/* harmony export */   \"orderByChild\": () => (/* binding */ orderByChild),\n/* harmony export */   \"orderByKey\": () => (/* binding */ orderByKey),\n/* harmony export */   \"orderByPriority\": () => (/* binding */ orderByPriority),\n/* harmony export */   \"orderByValue\": () => (/* binding */ orderByValue),\n/* harmony export */   \"push\": () => (/* binding */ push),\n/* harmony export */   \"query\": () => (/* binding */ query),\n/* harmony export */   \"ref\": () => (/* binding */ ref),\n/* harmony export */   \"refFromURL\": () => (/* binding */ refFromURL),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"runTransaction\": () => (/* binding */ runTransaction),\n/* harmony export */   \"serverTimestamp\": () => (/* binding */ serverTimestamp),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"setPriority\": () => (/* binding */ setPriority),\n/* harmony export */   \"setWithPriority\": () => (/* binding */ setWithPriority),\n/* harmony export */   \"startAfter\": () => (/* binding */ startAfter),\n/* harmony export */   \"startAt\": () => (/* binding */ startAt),\n/* harmony export */   \"update\": () => (/* binding */ update)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"./node_modules/@firebase/util/dist/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ \"./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\nconst name=\"@firebase/database\";const version=\"0.12.4\";/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** The semver (www.semver.org) version of the SDK. */let SDK_VERSION='';/**\r\n * SDK_VERSION should be set before any database instance is created\r\n * @internal\r\n */function setSDKVersion(version){SDK_VERSION=version;}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Wraps a DOM Storage object and:\r\n * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.\r\n * - prefixes names with \"firebase:\" to avoid collisions with app data.\r\n *\r\n * We automatically (see storage.js) create two such wrappers, one for sessionStorage,\r\n * and one for localStorage.\r\n *\r\n */class DOMStorageWrapper{/**\r\n     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)\r\n     */constructor(domStorage_){this.domStorage_=domStorage_;// Use a prefix to avoid collisions with other stuff saved by the app.\nthis.prefix_='firebase:';}/**\r\n     * @param key - The key to save the value under\r\n     * @param value - The value being stored, or null to remove the key.\r\n     */set(key,value){if(value==null){this.domStorage_.removeItem(this.prefixedName_(key));}else{this.domStorage_.setItem(this.prefixedName_(key),(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(value));}}/**\r\n     * @returns The value that was stored under this key, or null\r\n     */get(key){const storedVal=this.domStorage_.getItem(this.prefixedName_(key));if(storedVal==null){return null;}else{return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(storedVal);}}remove(key){this.domStorage_.removeItem(this.prefixedName_(key));}prefixedName_(name){return this.prefix_+name;}toString(){return this.domStorage_.toString();}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An in-memory storage implementation that matches the API of DOMStorageWrapper\r\n * (TODO: create interface for both to implement).\r\n */class MemoryStorage{constructor(){this.cache_={};this.isInMemoryStorage=true;}set(key,value){if(value==null){delete this.cache_[key];}else{this.cache_[key]=value;}}get(key){if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.cache_,key)){return this.cache_[key];}return null;}remove(key){delete this.cache_[key];}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.\r\n * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change\r\n * to reflect this type\r\n *\r\n * @param domStorageName - Name of the underlying storage object\r\n *   (e.g. 'localStorage' or 'sessionStorage').\r\n * @returns Turning off type information until a common interface is defined.\r\n */const createStoragefor=function(domStorageName){try{// NOTE: just accessing \"localStorage\" or \"window['localStorage']\" may throw a security exception,\n// so it must be inside the try/catch.\nif(typeof window!=='undefined'&&typeof window[domStorageName]!=='undefined'){// Need to test cache. Just because it's here doesn't mean it works\nconst domStorage=window[domStorageName];domStorage.setItem('firebase:sentinel','cache');domStorage.removeItem('firebase:sentinel');return new DOMStorageWrapper(domStorage);}}catch(e){}// Failed to create wrapper.  Just return in-memory storage.\n// TODO: log?\nreturn new MemoryStorage();};/** A storage object that lasts across sessions */const PersistentStorage=createStoragefor('localStorage');/** A storage object that only lasts one session */const SessionStorage=createStoragefor('sessionStorage');/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const logClient=new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/database');/**\r\n * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).\r\n */const LUIDGenerator=function(){let id=1;return function(){return id++;};}();/**\r\n * Sha1 hash of the input string\r\n * @param str - The string to hash\r\n * @returns {!string} The resulting hash\r\n */const sha1=function(str){const utf8Bytes=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringToByteArray)(str);const sha1=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Sha1();sha1.update(utf8Bytes);const sha1Bytes=sha1.digest();return _firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64.encodeByteArray(sha1Bytes);};const buildLogMessage_=function(...varArgs){let message='';for(let i=0;i<varArgs.length;i++){const arg=varArgs[i];if(Array.isArray(arg)||arg&&typeof arg==='object'&&// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntypeof arg.length==='number'){message+=buildLogMessage_.apply(null,arg);}else if(typeof arg==='object'){message+=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(arg);}else{message+=arg;}message+=' ';}return message;};/**\r\n * Use this for all debug messages in Firebase.\r\n */let logger=null;/**\r\n * Flag to check for log availability on first log message\r\n */let firstLog_=true;/**\r\n * The implementation of Firebase.enableLogging (defined here to break dependencies)\r\n * @param logger_ - A flag to turn on logging, or a custom logger\r\n * @param persistent - Whether or not to persist logging settings across refreshes\r\n */const enableLogging$1=function(logger_,persistent){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!persistent||logger_===true||logger_===false,\"Can't turn on custom loggers persistently.\");if(logger_===true){logClient.logLevel=_firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.VERBOSE;logger=logClient.log.bind(logClient);if(persistent){SessionStorage.set('logging_enabled',true);}}else if(typeof logger_==='function'){logger=logger_;}else{logger=null;SessionStorage.remove('logging_enabled');}};const log=function(...varArgs){if(firstLog_===true){firstLog_=false;if(logger===null&&SessionStorage.get('logging_enabled')===true){enableLogging$1(true);}}if(logger){const message=buildLogMessage_.apply(null,varArgs);logger(message);}};const logWrapper=function(prefix){return function(...varArgs){log(prefix,...varArgs);};};const error=function(...varArgs){const message='FIREBASE INTERNAL ERROR: '+buildLogMessage_(...varArgs);logClient.error(message);};const fatal=function(...varArgs){const message=`FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;logClient.error(message);throw new Error(message);};const warn=function(...varArgs){const message='FIREBASE WARNING: '+buildLogMessage_(...varArgs);logClient.warn(message);};/**\r\n * Logs a warning if the containing page uses https. Called when a call to new Firebase\r\n * does not use https.\r\n */const warnIfPageIsSecure=function(){// Be very careful accessing browser globals. Who knows what may or may not exist.\nif(typeof window!=='undefined'&&window.location&&window.location.protocol&&window.location.protocol.indexOf('https:')!==-1){warn('Insecure Firebase access from a secure page. '+'Please use https in calls to new Firebase().');}};/**\r\n * Returns true if data is NaN, or +/- Infinity.\r\n */const isInvalidJSONNumber=function(data){return typeof data==='number'&&(data!==data||// NaN\ndata===Number.POSITIVE_INFINITY||data===Number.NEGATIVE_INFINITY);};const executeWhenDOMReady=function(fn){if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()||document.readyState==='complete'){fn();}else{// Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which\n// fire before onload), but fall back to onload.\nlet called=false;const wrappedFn=function(){if(!document.body){setTimeout(wrappedFn,Math.floor(10));return;}if(!called){called=true;fn();}};if(document.addEventListener){document.addEventListener('DOMContentLoaded',wrappedFn,false);// fallback to onload.\nwindow.addEventListener('load',wrappedFn,false);// eslint-disable-next-line @typescript-eslint/no-explicit-any\n}else if(document.attachEvent){// IE.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ndocument.attachEvent('onreadystatechange',()=>{if(document.readyState==='complete'){wrappedFn();}});// fallback to onload.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nwindow.attachEvent('onload',wrappedFn);// jQuery has an extra hack for IE that we could employ (based on\n// http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.\n// I'm hoping we don't need it.\n}}};/**\r\n * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names\r\n */const MIN_NAME='[MIN_NAME]';/**\r\n * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names\r\n */const MAX_NAME='[MAX_NAME]';/**\r\n * Compares valid Firebase key names, plus min and max name\r\n */const nameCompare=function(a,b){if(a===b){return 0;}else if(a===MIN_NAME||b===MAX_NAME){return-1;}else if(b===MIN_NAME||a===MAX_NAME){return 1;}else{const aAsInt=tryParseInt(a),bAsInt=tryParseInt(b);if(aAsInt!==null){if(bAsInt!==null){return aAsInt-bAsInt===0?a.length-b.length:aAsInt-bAsInt;}else{return-1;}}else if(bAsInt!==null){return 1;}else{return a<b?-1:1;}}};/**\r\n * @returns {!number} comparison result.\r\n */const stringCompare=function(a,b){if(a===b){return 0;}else if(a<b){return-1;}else{return 1;}};const requireKey=function(key,obj){if(obj&&key in obj){return obj[key];}else{throw new Error('Missing required key ('+key+') in object: '+(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(obj));}};const ObjectToUniqueKey=function(obj){if(typeof obj!=='object'||obj===null){return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(obj);}const keys=[];// eslint-disable-next-line guard-for-in\nfor(const k in obj){keys.push(k);}// Export as json, but with the keys sorted.\nkeys.sort();let key='{';for(let i=0;i<keys.length;i++){if(i!==0){key+=',';}key+=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(keys[i]);key+=':';key+=ObjectToUniqueKey(obj[keys[i]]);}key+='}';return key;};/**\r\n * Splits a string into a number of smaller segments of maximum size\r\n * @param str - The string\r\n * @param segsize - The maximum number of chars in the string.\r\n * @returns The string, split into appropriately-sized chunks\r\n */const splitStringBySize=function(str,segsize){const len=str.length;if(len<=segsize){return[str];}const dataSegs=[];for(let c=0;c<len;c+=segsize){if(c+segsize>len){dataSegs.push(str.substring(c,len));}else{dataSegs.push(str.substring(c,c+segsize));}}return dataSegs;};/**\r\n * Apply a function to each (key, value) pair in an object or\r\n * apply a function to each (index, value) pair in an array\r\n * @param obj - The object or array to iterate over\r\n * @param fn - The function to apply\r\n */function each(obj,fn){for(const key in obj){if(obj.hasOwnProperty(key)){fn(key,obj[key]);}}}/**\r\n * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)\r\n * I made one modification at the end and removed the NaN / Infinity\r\n * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.\r\n * @param v - A double\r\n *\r\n */const doubleToIEEE754String=function(v){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!isInvalidJSONNumber(v),'Invalid JSON number');// MJL\nconst ebits=11,fbits=52;const bias=(1<<ebits-1)-1;let s,e,f,ln,i;// Compute sign, exponent, fraction\n// Skip NaN / Infinity handling --MJL.\nif(v===0){e=0;f=0;s=1/v===-Infinity?1:0;}else{s=v<0;v=Math.abs(v);if(v>=Math.pow(2,1-bias)){// Normalized\nln=Math.min(Math.floor(Math.log(v)/Math.LN2),bias);e=ln+bias;f=Math.round(v*Math.pow(2,fbits-ln)-Math.pow(2,fbits));}else{// Denormalized\ne=0;f=Math.round(v/Math.pow(2,1-bias-fbits));}}// Pack sign, exponent, fraction\nconst bits=[];for(i=fbits;i;i-=1){bits.push(f%2?1:0);f=Math.floor(f/2);}for(i=ebits;i;i-=1){bits.push(e%2?1:0);e=Math.floor(e/2);}bits.push(s?1:0);bits.reverse();const str=bits.join('');// Return the data as a hex string. --MJL\nlet hexByteString='';for(i=0;i<64;i+=8){let hexByte=parseInt(str.substr(i,8),2).toString(16);if(hexByte.length===1){hexByte='0'+hexByte;}hexByteString=hexByteString+hexByte;}return hexByteString.toLowerCase();};/**\r\n * Used to detect if we're in a Chrome content script (which executes in an\r\n * isolated environment where long-polling doesn't work).\r\n */const isChromeExtensionContentScript=function(){return!!(typeof window==='object'&&window['chrome']&&window['chrome']['extension']&&!/^chrome/.test(window.location.href));};/**\r\n * Used to detect if we're in a Windows 8 Store app.\r\n */const isWindowsStoreApp=function(){// Check for the presence of a couple WinRT globals\nreturn typeof Windows==='object'&&typeof Windows.UI==='object';};/**\r\n * Converts a server error code to a Javascript Error\r\n */function errorForServerCode(code,query){let reason='Unknown Error';if(code==='too_big'){reason='The data requested exceeds the maximum size '+'that can be accessed with a single request.';}else if(code==='permission_denied'){reason=\"Client doesn't have permission to access the desired data.\";}else if(code==='unavailable'){reason='The service is unavailable';}const error=new Error(code+' at '+query._path.toString()+': '+reason);// eslint-disable-next-line @typescript-eslint/no-explicit-any\nerror.code=code.toUpperCase();return error;}/**\r\n * Used to test for integer-looking strings\r\n */const INTEGER_REGEXP_=new RegExp('^-?(0*)\\\\d{1,10}$');/**\r\n * For use in keys, the minimum possible 32-bit integer.\r\n */const INTEGER_32_MIN=-2147483648;/**\r\n * For use in kyes, the maximum possible 32-bit integer.\r\n */const INTEGER_32_MAX=2147483647;/**\r\n * If the string contains a 32-bit integer, return it.  Else return null.\r\n */const tryParseInt=function(str){if(INTEGER_REGEXP_.test(str)){const intVal=Number(str);if(intVal>=INTEGER_32_MIN&&intVal<=INTEGER_32_MAX){return intVal;}}return null;};/**\r\n * Helper to run some code but catch any exceptions and re-throw them later.\r\n * Useful for preventing user callbacks from breaking internal code.\r\n *\r\n * Re-throwing the exception from a setTimeout is a little evil, but it's very\r\n * convenient (we don't have to try to figure out when is a safe point to\r\n * re-throw it), and the behavior seems reasonable:\r\n *\r\n * * If you aren't pausing on exceptions, you get an error in the console with\r\n *   the correct stack trace.\r\n * * If you're pausing on all exceptions, the debugger will pause on your\r\n *   exception and then again when we rethrow it.\r\n * * If you're only pausing on uncaught exceptions, the debugger will only pause\r\n *   on us re-throwing it.\r\n *\r\n * @param fn - The code to guard.\r\n */const exceptionGuard=function(fn){try{fn();}catch(e){// Re-throw exception when it's safe.\nsetTimeout(()=>{// It used to be that \"throw e\" would result in a good console error with\n// relevant context, but as of Chrome 39, you just get the firebase.js\n// file/line number where we re-throw it, which is useless. So we log\n// e.stack explicitly.\nconst stack=e.stack||'';warn('Exception was thrown by user callback.',stack);throw e;},Math.floor(0));}};/**\r\n * @returns {boolean} true if we think we're currently being crawled.\r\n */const beingCrawled=function(){const userAgent=typeof window==='object'&&window['navigator']&&window['navigator']['userAgent']||'';// For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we\n// believe to support JavaScript/AJAX rendering.\n// NOTE: Google Webmaster Tools doesn't really belong, but their \"This is how a visitor to your website\n// would have seen the page\" is flaky if we don't treat it as a crawler.\nreturn userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)>=0;};/**\r\n * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.\r\n *\r\n * It is removed with clearTimeout() as normal.\r\n *\r\n * @param fn - Function to run.\r\n * @param time - Milliseconds to wait before running.\r\n * @returns The setTimeout() return value.\r\n */const setTimeoutNonBlocking=function(fn,time){const timeout=setTimeout(fn,time);// eslint-disable-next-line @typescript-eslint/no-explicit-any\nif(typeof timeout==='object'&&timeout['unref']){// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntimeout['unref']();}return timeout;};/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Abstraction around AppCheck's token fetching capabilities.\r\n */class AppCheckTokenProvider{constructor(appName_,appCheckProvider){this.appName_=appName_;this.appCheckProvider=appCheckProvider;this.appCheck=appCheckProvider===null||appCheckProvider===void 0?void 0:appCheckProvider.getImmediate({optional:true});if(!this.appCheck){appCheckProvider===null||appCheckProvider===void 0?void 0:appCheckProvider.get().then(appCheck=>this.appCheck=appCheck);}}getToken(forceRefresh){if(!this.appCheck){return new Promise((resolve,reject)=>{// Support delayed initialization of FirebaseAppCheck. This allows our\n// customers to initialize the RTDB SDK before initializing Firebase\n// AppCheck and ensures that all requests are authenticated if a token\n// becomes available before the timoeout below expires.\nsetTimeout(()=>{if(this.appCheck){this.getToken(forceRefresh).then(resolve,reject);}else{resolve(null);}},0);});}return this.appCheck.getToken(forceRefresh);}addTokenChangeListener(listener){var _a;(_a=this.appCheckProvider)===null||_a===void 0?void 0:_a.get().then(appCheck=>appCheck.addTokenListener(listener));}notifyForInvalidToken(){warn(`Provided AppCheck credentials for the app named \"${this.appName_}\" `+'are invalid. This usually indicates your app was not initialized correctly.');}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Abstraction around FirebaseApp's token fetching capabilities.\r\n */class FirebaseAuthTokenProvider{constructor(appName_,firebaseOptions_,authProvider_){this.appName_=appName_;this.firebaseOptions_=firebaseOptions_;this.authProvider_=authProvider_;this.auth_=null;this.auth_=authProvider_.getImmediate({optional:true});if(!this.auth_){authProvider_.onInit(auth=>this.auth_=auth);}}getToken(forceRefresh){if(!this.auth_){return new Promise((resolve,reject)=>{// Support delayed initialization of FirebaseAuth. This allows our\n// customers to initialize the RTDB SDK before initializing Firebase\n// Auth and ensures that all requests are authenticated if a token\n// becomes available before the timoeout below expires.\nsetTimeout(()=>{if(this.auth_){this.getToken(forceRefresh).then(resolve,reject);}else{resolve(null);}},0);});}return this.auth_.getToken(forceRefresh).catch(error=>{// TODO: Need to figure out all the cases this is raised and whether\n// this makes sense.\nif(error&&error.code==='auth/token-not-initialized'){log('Got auth/token-not-initialized error.  Treating as null token.');return null;}else{return Promise.reject(error);}});}addTokenChangeListener(listener){// TODO: We might want to wrap the listener and call it with no args to\n// avoid a leaky abstraction, but that makes removing the listener harder.\nif(this.auth_){this.auth_.addAuthTokenListener(listener);}else{this.authProvider_.get().then(auth=>auth.addAuthTokenListener(listener));}}removeTokenChangeListener(listener){this.authProvider_.get().then(auth=>auth.removeAuthTokenListener(listener));}notifyForInvalidToken(){let errorMessage='Provided authentication credentials for the app named \"'+this.appName_+'\" are invalid. This usually indicates your app was not '+'initialized correctly. ';if('credential'in this.firebaseOptions_){errorMessage+='Make sure the \"credential\" property provided to initializeApp() '+'is authorized to access the specified \"databaseURL\" and is from the correct '+'project.';}else if('serviceAccount'in this.firebaseOptions_){errorMessage+='Make sure the \"serviceAccount\" property provided to initializeApp() '+'is authorized to access the specified \"databaseURL\" and is from the correct '+'project.';}else{errorMessage+='Make sure the \"apiKey\" and \"databaseURL\" properties provided to '+'initializeApp() match the values provided for your app at '+'https://console.firebase.google.com/.';}warn(errorMessage);}}/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */class EmulatorTokenProvider{constructor(accessToken){this.accessToken=accessToken;}getToken(forceRefresh){return Promise.resolve({accessToken:this.accessToken});}addTokenChangeListener(listener){// Invoke the listener immediately to match the behavior in Firebase Auth\n// (see packages/auth/src/auth.js#L1807)\nlistener(this.accessToken);}removeTokenChangeListener(listener){}notifyForInvalidToken(){}}/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */EmulatorTokenProvider.OWNER='owner';/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const PROTOCOL_VERSION='5';const VERSION_PARAM='v';const TRANSPORT_SESSION_PARAM='s';const REFERER_PARAM='r';const FORGE_REF='f';// Matches console.firebase.google.com, firebase-console-*.corp.google.com and\n// firebase.corp.google.com\nconst FORGE_DOMAIN_RE=/(console\\.firebase|firebase-console-\\w+\\.corp|firebase\\.corp)\\.google\\.com/;const LAST_SESSION_PARAM='ls';const APPLICATION_ID_PARAM='p';const APP_CHECK_TOKEN_PARAM='ac';const WEBSOCKET='websocket';const LONG_POLLING='long_polling';/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A class that holds metadata about a Repo object\r\n */class RepoInfo{/**\r\n     * @param host - Hostname portion of the url for the repo\r\n     * @param secure - Whether or not this repo is accessed over ssl\r\n     * @param namespace - The namespace represented by the repo\r\n     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).\r\n     * @param nodeAdmin - Whether this instance uses Admin SDK credentials\r\n     * @param persistenceKey - Override the default session persistence storage key\r\n     */constructor(host,secure,namespace,webSocketOnly,nodeAdmin=false,persistenceKey='',includeNamespaceInQueryParams=false){this.secure=secure;this.namespace=namespace;this.webSocketOnly=webSocketOnly;this.nodeAdmin=nodeAdmin;this.persistenceKey=persistenceKey;this.includeNamespaceInQueryParams=includeNamespaceInQueryParams;this._host=host.toLowerCase();this._domain=this._host.substr(this._host.indexOf('.')+1);this.internalHost=PersistentStorage.get('host:'+host)||this._host;}isCacheableHost(){return this.internalHost.substr(0,2)==='s-';}isCustomHost(){return this._domain!=='firebaseio.com'&&this._domain!=='firebaseio-demo.com';}get host(){return this._host;}set host(newHost){if(newHost!==this.internalHost){this.internalHost=newHost;if(this.isCacheableHost()){PersistentStorage.set('host:'+this._host,this.internalHost);}}}toString(){let str=this.toURLString();if(this.persistenceKey){str+='<'+this.persistenceKey+'>';}return str;}toURLString(){const protocol=this.secure?'https://':'http://';const query=this.includeNamespaceInQueryParams?`?ns=${this.namespace}`:'';return`${protocol}${this.host}/${query}`;}}function repoInfoNeedsQueryParam(repoInfo){return repoInfo.host!==repoInfo.internalHost||repoInfo.isCustomHost()||repoInfo.includeNamespaceInQueryParams;}/**\r\n * Returns the websocket URL for this repo\r\n * @param repoInfo - RepoInfo object\r\n * @param type - of connection\r\n * @param params - list\r\n * @returns The URL for this repo\r\n */function repoInfoConnectionURL(repoInfo,type,params){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof type==='string','typeof type must == string');(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof params==='object','typeof params must == object');let connURL;if(type===WEBSOCKET){connURL=(repoInfo.secure?'wss://':'ws://')+repoInfo.internalHost+'/.ws?';}else if(type===LONG_POLLING){connURL=(repoInfo.secure?'https://':'http://')+repoInfo.internalHost+'/.lp?';}else{throw new Error('Unknown connection type: '+type);}if(repoInfoNeedsQueryParam(repoInfo)){params['ns']=repoInfo.namespace;}const pairs=[];each(params,(key,value)=>{pairs.push(key+'='+value);});return connURL+pairs.join('&');}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Tracks a collection of stats.\r\n */class StatsCollection{constructor(){this.counters_={};}incrementCounter(name,amount=1){if(!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.counters_,name)){this.counters_[name]=0;}this.counters_[name]+=amount;}get(){return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(this.counters_);}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const collections={};const reporters={};function statsManagerGetCollection(repoInfo){const hashString=repoInfo.toString();if(!collections[hashString]){collections[hashString]=new StatsCollection();}return collections[hashString];}function statsManagerGetOrCreateReporter(repoInfo,creatorFunction){const hashString=repoInfo.toString();if(!reporters[hashString]){reporters[hashString]=creatorFunction();}return reporters[hashString];}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class ensures the packets from the server arrive in order\r\n * This class takes data from the server and ensures it gets passed into the callbacks in order.\r\n */class PacketReceiver{/**\r\n     * @param onMessage_\r\n     */constructor(onMessage_){this.onMessage_=onMessage_;this.pendingResponses=[];this.currentResponseNum=0;this.closeAfterResponse=-1;this.onClose=null;}closeAfter(responseNum,callback){this.closeAfterResponse=responseNum;this.onClose=callback;if(this.closeAfterResponse<this.currentResponseNum){this.onClose();this.onClose=null;}}/**\r\n     * Each message from the server comes with a response number, and an array of data. The responseNumber\r\n     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all\r\n     * browsers will respond in the same order as the requests we sent\r\n     */handleResponse(requestNum,data){this.pendingResponses[requestNum]=data;while(this.pendingResponses[this.currentResponseNum]){const toProcess=this.pendingResponses[this.currentResponseNum];delete this.pendingResponses[this.currentResponseNum];for(let i=0;i<toProcess.length;++i){if(toProcess[i]){exceptionGuard(()=>{this.onMessage_(toProcess[i]);});}}if(this.currentResponseNum===this.closeAfterResponse){if(this.onClose){this.onClose();this.onClose=null;}break;}this.currentResponseNum++;}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // URL query parameters associated with longpolling\nconst FIREBASE_LONGPOLL_START_PARAM='start';const FIREBASE_LONGPOLL_CLOSE_COMMAND='close';const FIREBASE_LONGPOLL_COMMAND_CB_NAME='pLPCommand';const FIREBASE_LONGPOLL_DATA_CB_NAME='pRTLPCB';const FIREBASE_LONGPOLL_ID_PARAM='id';const FIREBASE_LONGPOLL_PW_PARAM='pw';const FIREBASE_LONGPOLL_SERIAL_PARAM='ser';const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM='cb';const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM='seg';const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET='ts';const FIREBASE_LONGPOLL_DATA_PARAM='d';const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM='dframe';//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nconst MAX_URL_DATA_SIZE=1870;const SEG_HEADER_SIZE=30;//ie: &seg=8299234&ts=982389123&d=\nconst MAX_PAYLOAD_SIZE=MAX_URL_DATA_SIZE-SEG_HEADER_SIZE;/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n */const KEEPALIVE_REQUEST_INTERVAL=25000;/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n */const LP_CONNECT_TIMEOUT=30000;/**\r\n * This class manages a single long-polling connection.\r\n */class BrowserPollConnection{/**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The AppCheck token for this client.\r\n     * @param authToken The AuthToken to use for this connection.\r\n     * @param transportSessionId Optional transportSessionid if we are\r\n     * reconnecting for an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has\r\n     * already created a connection previously\r\n     */constructor(connId,repoInfo,applicationId,appCheckToken,authToken,transportSessionId,lastSessionId){this.connId=connId;this.repoInfo=repoInfo;this.applicationId=applicationId;this.appCheckToken=appCheckToken;this.authToken=authToken;this.transportSessionId=transportSessionId;this.lastSessionId=lastSessionId;this.bytesSent=0;this.bytesReceived=0;this.everConnected_=false;this.log_=logWrapper(connId);this.stats_=statsManagerGetCollection(repoInfo);this.urlFn=params=>{// Always add the token if we have one.\nif(this.appCheckToken){params[APP_CHECK_TOKEN_PARAM]=this.appCheckToken;}return repoInfoConnectionURL(repoInfo,LONG_POLLING,params);};}/**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */open(onMessage,onDisconnect){this.curSegmentNum=0;this.onDisconnect_=onDisconnect;this.myPacketOrderer=new PacketReceiver(onMessage);this.isClosed_=false;this.connectTimeoutTimer_=setTimeout(()=>{this.log_('Timed out trying to connect.');// Make sure we clear the host cache\nthis.onClosed_();this.connectTimeoutTimer_=null;// eslint-disable-next-line @typescript-eslint/no-explicit-any\n},Math.floor(LP_CONNECT_TIMEOUT));// Ensure we delay the creation of the iframe until the DOM is loaded.\nexecuteWhenDOMReady(()=>{if(this.isClosed_){return;}//Set up a callback that gets triggered once a connection is set up.\nthis.scriptTagHolder=new FirebaseIFrameScriptHolder((...args)=>{const[command,arg1,arg2,arg3,arg4]=args;this.incrementIncomingBytes_(args);if(!this.scriptTagHolder){return;// we closed the connection.\n}if(this.connectTimeoutTimer_){clearTimeout(this.connectTimeoutTimer_);this.connectTimeoutTimer_=null;}this.everConnected_=true;if(command===FIREBASE_LONGPOLL_START_PARAM){this.id=arg1;this.password=arg2;}else if(command===FIREBASE_LONGPOLL_CLOSE_COMMAND){// Don't clear the host cache. We got a response from the server, so we know it's reachable\nif(arg1){// We aren't expecting any more data (other than what the server's already in the process of sending us\n// through our already open polls), so don't send any more.\nthis.scriptTagHolder.sendNewPolls=false;// arg1 in this case is the last response number sent by the server. We should try to receive\n// all of the responses up to this one before closing\nthis.myPacketOrderer.closeAfter(arg1,()=>{this.onClosed_();});}else{this.onClosed_();}}else{throw new Error('Unrecognized command received: '+command);}},(...args)=>{const[pN,data]=args;this.incrementIncomingBytes_(args);this.myPacketOrderer.handleResponse(pN,data);},()=>{this.onClosed_();},this.urlFn);//Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n//from cache.\nconst urlParams={};urlParams[FIREBASE_LONGPOLL_START_PARAM]='t';urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM]=Math.floor(Math.random()*100000000);if(this.scriptTagHolder.uniqueCallbackIdentifier){urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM]=this.scriptTagHolder.uniqueCallbackIdentifier;}urlParams[VERSION_PARAM]=PROTOCOL_VERSION;if(this.transportSessionId){urlParams[TRANSPORT_SESSION_PARAM]=this.transportSessionId;}if(this.lastSessionId){urlParams[LAST_SESSION_PARAM]=this.lastSessionId;}if(this.applicationId){urlParams[APPLICATION_ID_PARAM]=this.applicationId;}if(this.appCheckToken){urlParams[APP_CHECK_TOKEN_PARAM]=this.appCheckToken;}if(typeof location!=='undefined'&&location.hostname&&FORGE_DOMAIN_RE.test(location.hostname)){urlParams[REFERER_PARAM]=FORGE_REF;}const connectURL=this.urlFn(urlParams);this.log_('Connecting via long-poll to '+connectURL);this.scriptTagHolder.addTag(connectURL,()=>{/* do nothing */});});}/**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */start(){this.scriptTagHolder.startLongPoll(this.id,this.password);this.addDisconnectPingFrame(this.id,this.password);}/**\r\n     * Forces long polling to be considered as a potential transport\r\n     */static forceAllow(){BrowserPollConnection.forceAllow_=true;}/**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */static forceDisallow(){BrowserPollConnection.forceDisallow_=true;}// Static method, use string literal so it can be accessed in a generic way\nstatic isAvailable(){if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()){return false;}else if(BrowserPollConnection.forceAllow_){return true;}else{// NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n// the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\nreturn!BrowserPollConnection.forceDisallow_&&typeof document!=='undefined'&&document.createElement!=null&&!isChromeExtensionContentScript()&&!isWindowsStoreApp();}}/**\r\n     * No-op for polling\r\n     */markConnectionHealthy(){}/**\r\n     * Stops polling and cleans up the iframe\r\n     */shutdown_(){this.isClosed_=true;if(this.scriptTagHolder){this.scriptTagHolder.close();this.scriptTagHolder=null;}//remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\nif(this.myDisconnFrame){document.body.removeChild(this.myDisconnFrame);this.myDisconnFrame=null;}if(this.connectTimeoutTimer_){clearTimeout(this.connectTimeoutTimer_);this.connectTimeoutTimer_=null;}}/**\r\n     * Triggered when this transport is closed\r\n     */onClosed_(){if(!this.isClosed_){this.log_('Longpoll is closing itself');this.shutdown_();if(this.onDisconnect_){this.onDisconnect_(this.everConnected_);this.onDisconnect_=null;}}}/**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */close(){if(!this.isClosed_){this.log_('Longpoll is being closed.');this.shutdown_();}}/**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param data - The JSON data to transmit.\r\n     */send(data){const dataStr=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data);this.bytesSent+=dataStr.length;this.stats_.incrementCounter('bytes_sent',dataStr.length);//first, lets get the base64-encoded data\nconst base64data=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64Encode)(dataStr);//We can only fit a certain amount in each URL, so we need to split this request\n//up into multiple pieces if it doesn't fit in one request.\nconst dataSegs=splitStringBySize(base64data,MAX_PAYLOAD_SIZE);//Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n//of segments so that we can reassemble the packet on the server.\nfor(let i=0;i<dataSegs.length;i++){this.scriptTagHolder.enqueueSegment(this.curSegmentNum,dataSegs.length,dataSegs[i]);this.curSegmentNum++;}}/**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     */addDisconnectPingFrame(id,pw){if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()){return;}this.myDisconnFrame=document.createElement('iframe');const urlParams={};urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM]='t';urlParams[FIREBASE_LONGPOLL_ID_PARAM]=id;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=pw;this.myDisconnFrame.src=this.urlFn(urlParams);this.myDisconnFrame.style.display='none';document.body.appendChild(this.myDisconnFrame);}/**\r\n     * Used to track the bytes received by this client\r\n     */incrementIncomingBytes_(args){// TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\nconst bytesReceived=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(args).length;this.bytesReceived+=bytesReceived;this.stats_.incrementCounter('bytes_received',bytesReceived);}}/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n *********************************************************************************************/class FirebaseIFrameScriptHolder{/**\r\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */constructor(commandCB,onMessageCB,onDisconnect,urlFn){this.onDisconnect=onDisconnect;this.urlFn=urlFn;//We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n//problems in some browsers.\nthis.outstandingRequests=new Set();//A queue of the pending segments waiting for transmission to the server.\nthis.pendingSegs=[];//A serial number. We use this for two things:\n// 1) A way to ensure the browser doesn't cache responses to polls\n// 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n//    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n//    JSONP code in the order it was added to the iframe.\nthis.currentSerial=Math.floor(Math.random()*100000000);// This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n// incoming data from the server that we're waiting for).\nthis.sendNewPolls=true;if(!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()){//Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n//iframes where we put the long-polling script tags. We have two callbacks:\n//   1) Command Callback - Triggered for control issues, like starting a connection.\n//   2) Message Callback - Triggered when new data arrives.\nthis.uniqueCallbackIdentifier=LUIDGenerator();window[FIREBASE_LONGPOLL_COMMAND_CB_NAME+this.uniqueCallbackIdentifier]=commandCB;window[FIREBASE_LONGPOLL_DATA_CB_NAME+this.uniqueCallbackIdentifier]=onMessageCB;//Create an iframe for us to add script tags to.\nthis.myIFrame=FirebaseIFrameScriptHolder.createIFrame_();// Set the iframe's contents.\nlet script='';// if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n// for ie9, but ie8 needs to do it again in the document itself.\nif(this.myIFrame.src&&this.myIFrame.src.substr(0,'javascript:'.length)==='javascript:'){const currentDomain=document.domain;script='<script>document.domain=\"'+currentDomain+'\";</script>';}const iframeContents='<html><body>'+script+'</body></html>';try{this.myIFrame.doc.open();this.myIFrame.doc.write(iframeContents);this.myIFrame.doc.close();}catch(e){log('frame writing exception');if(e.stack){log(e.stack);}log(e);}}else{this.commandCB=commandCB;this.onMessageCB=onMessageCB;}}/**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     */static createIFrame_(){const iframe=document.createElement('iframe');iframe.style.display='none';// This is necessary in order to initialize the document inside the iframe\nif(document.body){document.body.appendChild(iframe);try{// If document.domain has been modified in IE, this will throw an error, and we need to set the\n// domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n// Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\nconst a=iframe.contentWindow.document;if(!a){// Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\nlog('No IE domain setting required');}}catch(e){const domain=document.domain;iframe.src=\"javascript:void((function(){document.open();document.domain='\"+domain+\"';document.close();})())\";}}else{// LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n// never gets hit.\nthrow'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';}// Get the document of the iframe in a browser-specific way.\nif(iframe.contentDocument){iframe.doc=iframe.contentDocument;// Firefox, Opera, Safari\n}else if(iframe.contentWindow){iframe.doc=iframe.contentWindow.document;// Internet Explorer\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n}else if(iframe.document){// eslint-disable-next-line @typescript-eslint/no-explicit-any\niframe.doc=iframe.document;//others?\n}return iframe;}/**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */close(){//Mark this iframe as dead, so no new requests are sent.\nthis.alive=false;if(this.myIFrame){//We have to actually remove all of the html inside this iframe before removing it from the\n//window, or IE will continue loading and executing the script tags we've already added, which\n//can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\nthis.myIFrame.doc.body.innerHTML='';setTimeout(()=>{if(this.myIFrame!==null){document.body.removeChild(this.myIFrame);this.myIFrame=null;}},Math.floor(0));}// Protect from being called recursively.\nconst onDisconnect=this.onDisconnect;if(onDisconnect){this.onDisconnect=null;onDisconnect();}}/**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param id - The ID of this connection\r\n     * @param pw - The password for this connection\r\n     */startLongPoll(id,pw){this.myID=id;this.myPW=pw;this.alive=true;//send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\nwhile(this.newRequest_()){}}/**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */newRequest_(){// We keep one outstanding request open all the time to receive data, but if we need to send data\n// (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n// close the old request.\nif(this.alive&&this.sendNewPolls&&this.outstandingRequests.size<(this.pendingSegs.length>0?2:1)){//construct our url\nthis.currentSerial++;const urlParams={};urlParams[FIREBASE_LONGPOLL_ID_PARAM]=this.myID;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=this.myPW;urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM]=this.currentSerial;let theURL=this.urlFn(urlParams);//Now add as much data as we can.\nlet curDataString='';let i=0;while(this.pendingSegs.length>0){//first, lets see if the next segment will fit.\nconst nextSeg=this.pendingSegs[0];if(nextSeg.d.length+SEG_HEADER_SIZE+curDataString.length<=MAX_URL_DATA_SIZE){//great, the segment will fit. Lets append it.\nconst theSeg=this.pendingSegs.shift();curDataString=curDataString+'&'+FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM+i+'='+theSeg.seg+'&'+FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET+i+'='+theSeg.ts+'&'+FIREBASE_LONGPOLL_DATA_PARAM+i+'='+theSeg.d;i++;}else{break;}}theURL=theURL+curDataString;this.addLongPollTag_(theURL,this.currentSerial);return true;}else{return false;}}/**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */enqueueSegment(segnum,totalsegs,data){//add this to the queue of segments to send.\nthis.pendingSegs.push({seg:segnum,ts:totalsegs,d:data});//send the data immediately if there isn't already data being transmitted, unless\n//startLongPoll hasn't been called yet.\nif(this.alive){this.newRequest_();}}/**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param url - The URL of the script tag.\r\n     * @param serial - The serial number of the request.\r\n     */addLongPollTag_(url,serial){//remember that we sent this request.\nthis.outstandingRequests.add(serial);const doNewRequest=()=>{this.outstandingRequests.delete(serial);this.newRequest_();};// If this request doesn't return on its own accord (by the server sending us some data), we'll\n// create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\nconst keepaliveTimeout=setTimeout(doNewRequest,Math.floor(KEEPALIVE_REQUEST_INTERVAL));const readyStateCB=()=>{// Request completed.  Cancel the keepalive.\nclearTimeout(keepaliveTimeout);// Trigger a new request so we can continue receiving data.\ndoNewRequest();};this.addTag(url,readyStateCB);}/**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param url - The URL for the script tag source.\r\n     * @param loadCB - A callback to be triggered once the script has loaded.\r\n     */addTag(url,loadCB){if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nthis.doNodeLongPoll(url,loadCB);}else{setTimeout(()=>{try{// if we're already closed, don't add this poll\nif(!this.sendNewPolls){return;}const newScript=this.myIFrame.doc.createElement('script');newScript.type='text/javascript';newScript.async=true;newScript.src=url;// eslint-disable-next-line @typescript-eslint/no-explicit-any\nnewScript.onload=newScript.onreadystatechange=function(){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst rstate=newScript.readyState;if(!rstate||rstate==='loaded'||rstate==='complete'){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nnewScript.onload=newScript.onreadystatechange=null;if(newScript.parentNode){newScript.parentNode.removeChild(newScript);}loadCB();}};newScript.onerror=()=>{log('Long-poll script failed to load: '+url);this.sendNewPolls=false;this.close();};this.myIFrame.doc.body.appendChild(newScript);}catch(e){// TODO: we should make this error visible somehow\n}},Math.floor(1));}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const WEBSOCKET_MAX_FRAME_SIZE=16384;const WEBSOCKET_KEEPALIVE_INTERVAL=45000;let WebSocketImpl=null;if(typeof MozWebSocket!=='undefined'){WebSocketImpl=MozWebSocket;}else if(typeof WebSocket!=='undefined'){WebSocketImpl=WebSocket;}/**\r\n * Create a new websocket connection with the given callbacks.\r\n */class WebSocketConnection{/**\r\n     * @param connId identifier for this transport\r\n     * @param repoInfo The info for the websocket endpoint.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The App Check Token for this client.\r\n     * @param authToken The Auth Token for this client.\r\n     * @param transportSessionId Optional transportSessionId if this is connecting\r\n     * to an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if there was a previous\r\n     * connection\r\n     */constructor(connId,repoInfo,applicationId,appCheckToken,authToken,transportSessionId,lastSessionId){this.connId=connId;this.applicationId=applicationId;this.appCheckToken=appCheckToken;this.authToken=authToken;this.keepaliveTimer=null;this.frames=null;this.totalFrames=0;this.bytesSent=0;this.bytesReceived=0;this.log_=logWrapper(this.connId);this.stats_=statsManagerGetCollection(repoInfo);this.connURL=WebSocketConnection.connectionURL_(repoInfo,transportSessionId,lastSessionId,appCheckToken);this.nodeAdmin=repoInfo.nodeAdmin;}/**\r\n     * @param repoInfo - The info for the websocket endpoint.\r\n     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport\r\n     *                                         session\r\n     * @param lastSessionId - Optional lastSessionId if there was a previous connection\r\n     * @returns connection url\r\n     */static connectionURL_(repoInfo,transportSessionId,lastSessionId,appCheckToken){const urlParams={};urlParams[VERSION_PARAM]=PROTOCOL_VERSION;if(!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()&&typeof location!=='undefined'&&location.hostname&&FORGE_DOMAIN_RE.test(location.hostname)){urlParams[REFERER_PARAM]=FORGE_REF;}if(transportSessionId){urlParams[TRANSPORT_SESSION_PARAM]=transportSessionId;}if(lastSessionId){urlParams[LAST_SESSION_PARAM]=lastSessionId;}if(appCheckToken){urlParams[APP_CHECK_TOKEN_PARAM]=appCheckToken;}return repoInfoConnectionURL(repoInfo,WEBSOCKET,urlParams);}/**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */open(onMessage,onDisconnect){this.onDisconnect=onDisconnect;this.onMessage=onMessage;this.log_('Websocket connecting to '+this.connURL);this.everConnected_=false;// Assume failure until proven otherwise.\nPersistentStorage.set('previous_websocket_failure',true);try{if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()){const device=this.nodeAdmin?'AdminNode':'Node';// UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\nconst options={headers:{'User-Agent':`Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`,'X-Firebase-GMPID':this.applicationId||''}};// If using Node with admin creds, AppCheck-related checks are unnecessary.\n// Note that we send the credentials here even if they aren't admin credentials, which is\n// not a problem.\n// Note that this header is just used to bypass appcheck, and the token should still be sent\n// through the websocket connection once it is established.\nif(this.authToken){options.headers['Authorization']=`Bearer ${this.authToken}`;}if(this.appCheckToken){options.headers['X-Firebase-AppCheck']=this.appCheckToken;}// Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\nconst env=process['env'];const proxy=this.connURL.indexOf('wss://')===0?env['HTTPS_PROXY']||env['https_proxy']:env['HTTP_PROXY']||env['http_proxy'];if(proxy){options['proxy']={origin:proxy};}this.mySock=new WebSocketImpl(this.connURL,[],options);}else{const options={headers:{'X-Firebase-GMPID':this.applicationId||'','X-Firebase-AppCheck':this.appCheckToken||''}};this.mySock=new WebSocketImpl(this.connURL,[],options);}}catch(e){this.log_('Error instantiating WebSocket.');const error=e.message||e.data;if(error){this.log_(error);}this.onClosed_();return;}this.mySock.onopen=()=>{this.log_('Websocket connected.');this.everConnected_=true;};this.mySock.onclose=()=>{this.log_('Websocket connection was disconnected.');this.mySock=null;this.onClosed_();};this.mySock.onmessage=m=>{this.handleIncomingFrame(m);};this.mySock.onerror=e=>{this.log_('WebSocket error.  Closing connection.');// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst error=e.message||e.data;if(error){this.log_(error);}this.onClosed_();};}/**\r\n     * No-op for websockets, we don't need to do anything once the connection is confirmed as open\r\n     */start(){}static forceDisallow(){WebSocketConnection.forceDisallow_=true;}static isAvailable(){let isOldAndroid=false;if(typeof navigator!=='undefined'&&navigator.userAgent){const oldAndroidRegex=/Android ([0-9]{0,}\\.[0-9]{0,})/;const oldAndroidMatch=navigator.userAgent.match(oldAndroidRegex);if(oldAndroidMatch&&oldAndroidMatch.length>1){if(parseFloat(oldAndroidMatch[1])<4.4){isOldAndroid=true;}}}return!isOldAndroid&&WebSocketImpl!==null&&!WebSocketConnection.forceDisallow_;}/**\r\n     * Returns true if we previously failed to connect with this transport.\r\n     */static previouslyFailed(){// If our persistent storage is actually only in-memory storage,\n// we default to assuming that it previously failed to be safe.\nreturn PersistentStorage.isInMemoryStorage||PersistentStorage.get('previous_websocket_failure')===true;}markConnectionHealthy(){PersistentStorage.remove('previous_websocket_failure');}appendFrame_(data){this.frames.push(data);if(this.frames.length===this.totalFrames){const fullMess=this.frames.join('');this.frames=null;const jsonMess=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(fullMess);//handle the message\nthis.onMessage(jsonMess);}}/**\r\n     * @param frameCount - The number of frames we are expecting from the server\r\n     */handleNewFrameCount_(frameCount){this.totalFrames=frameCount;this.frames=[];}/**\r\n     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\r\n     * @returns Any remaining data to be process, or null if there is none\r\n     */extractFrameCount_(data){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.frames===null,'We already have a frame buffer');// TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n// currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\nif(data.length<=6){const frameCount=Number(data);if(!isNaN(frameCount)){this.handleNewFrameCount_(frameCount);return null;}}this.handleNewFrameCount_(1);return data;}/**\r\n     * Process a websocket frame that has arrived from the server.\r\n     * @param mess - The frame data\r\n     */handleIncomingFrame(mess){if(this.mySock===null){return;// Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n}const data=mess['data'];this.bytesReceived+=data.length;this.stats_.incrementCounter('bytes_received',data.length);this.resetKeepAlive();if(this.frames!==null){// we're buffering\nthis.appendFrame_(data);}else{// try to parse out a frame count, otherwise, assume 1 and process it\nconst remainingData=this.extractFrameCount_(data);if(remainingData!==null){this.appendFrame_(remainingData);}}}/**\r\n     * Send a message to the server\r\n     * @param data - The JSON object to transmit\r\n     */send(data){this.resetKeepAlive();const dataStr=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data);this.bytesSent+=dataStr.length;this.stats_.incrementCounter('bytes_sent',dataStr.length);//We can only fit a certain amount in each websocket frame, so we need to split this request\n//up into multiple pieces if it doesn't fit in one request.\nconst dataSegs=splitStringBySize(dataStr,WEBSOCKET_MAX_FRAME_SIZE);//Send the length header\nif(dataSegs.length>1){this.sendString_(String(dataSegs.length));}//Send the actual data in segments.\nfor(let i=0;i<dataSegs.length;i++){this.sendString_(dataSegs[i]);}}shutdown_(){this.isClosed_=true;if(this.keepaliveTimer){clearInterval(this.keepaliveTimer);this.keepaliveTimer=null;}if(this.mySock){this.mySock.close();this.mySock=null;}}onClosed_(){if(!this.isClosed_){this.log_('WebSocket is closing itself');this.shutdown_();// since this is an internal close, trigger the close listener\nif(this.onDisconnect){this.onDisconnect(this.everConnected_);this.onDisconnect=null;}}}/**\r\n     * External-facing close handler.\r\n     * Close the websocket and kill the connection.\r\n     */close(){if(!this.isClosed_){this.log_('WebSocket is being closed');this.shutdown_();}}/**\r\n     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\r\n     * the last activity.\r\n     */resetKeepAlive(){clearInterval(this.keepaliveTimer);this.keepaliveTimer=setInterval(()=>{//If there has been no websocket activity for a while, send a no-op\nif(this.mySock){this.sendString_('0');}this.resetKeepAlive();// eslint-disable-next-line @typescript-eslint/no-explicit-any\n},Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));}/**\r\n     * Send a string over the websocket.\r\n     *\r\n     * @param str - String to send.\r\n     */sendString_(str){// Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n// calls for some unknown reason.  We treat these as an error and disconnect.\n// See https://app.asana.com/0/58926111402292/68021340250410\ntry{this.mySock.send(str);}catch(e){this.log_('Exception thrown from WebSocket.send():',e.message||e.data,'Closing connection.');setTimeout(this.onClosed_.bind(this),0);}}}/**\r\n * Number of response before we consider the connection \"healthy.\"\r\n */WebSocketConnection.responsesRequiredToBeHealthy=2;/**\r\n * Time to wait for the connection te become healthy before giving up.\r\n */WebSocketConnection.healthyTimeout=30000;/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n */class TransportManager{/**\r\n     * @param repoInfo - Metadata around the namespace we're connecting to\r\n     */constructor(repoInfo){this.initTransports_(repoInfo);}static get ALL_TRANSPORTS(){return[BrowserPollConnection,WebSocketConnection];}initTransports_(repoInfo){const isWebSocketsAvailable=WebSocketConnection&&WebSocketConnection['isAvailable']();let isSkipPollConnection=isWebSocketsAvailable&&!WebSocketConnection.previouslyFailed();if(repoInfo.webSocketOnly){if(!isWebSocketsAvailable){warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");}isSkipPollConnection=true;}if(isSkipPollConnection){this.transports_=[WebSocketConnection];}else{const transports=this.transports_=[];for(const transport of TransportManager.ALL_TRANSPORTS){if(transport&&transport['isAvailable']()){transports.push(transport);}}}}/**\r\n     * @returns The constructor for the initial transport to use\r\n     */initialTransport(){if(this.transports_.length>0){return this.transports_[0];}else{throw new Error('No transports available');}}/**\r\n     * @returns The constructor for the next transport, or null\r\n     */upgradeTransport(){if(this.transports_.length>1){return this.transports_[1];}else{return null;}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Abort upgrade attempt if it takes longer than 60s.\nconst UPGRADE_TIMEOUT=60000;// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS=5000;// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nconst BYTES_SENT_HEALTHY_OVERRIDE=10*1024;const BYTES_RECEIVED_HEALTHY_OVERRIDE=100*1024;const MESSAGE_TYPE='t';const MESSAGE_DATA='d';const CONTROL_SHUTDOWN='s';const CONTROL_RESET='r';const CONTROL_ERROR='e';const CONTROL_PONG='o';const SWITCH_ACK='a';const END_TRANSMISSION='n';const PING='p';const SERVER_HELLO='h';/**\r\n * Creates a new real-time connection to the server using whichever method works\r\n * best in the current browser.\r\n */class Connection{/**\r\n     * @param id - an id for this connection\r\n     * @param repoInfo_ - the info for the endpoint to connect to\r\n     * @param applicationId_ - the Firebase App ID for this project\r\n     * @param appCheckToken_ - The App Check Token for this device.\r\n     * @param authToken_ - The auth token for this session.\r\n     * @param onMessage_ - the callback to be triggered when a server-push message arrives\r\n     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.\r\n     * @param onDisconnect_ - the callback to be triggered when a connection was lost\r\n     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.\r\n     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\r\n     */constructor(id,repoInfo_,applicationId_,appCheckToken_,authToken_,onMessage_,onReady_,onDisconnect_,onKill_,lastSessionId){this.id=id;this.repoInfo_=repoInfo_;this.applicationId_=applicationId_;this.appCheckToken_=appCheckToken_;this.authToken_=authToken_;this.onMessage_=onMessage_;this.onReady_=onReady_;this.onDisconnect_=onDisconnect_;this.onKill_=onKill_;this.lastSessionId=lastSessionId;this.connectionCount=0;this.pendingDataMessages=[];this.state_=0/* CONNECTING */;this.log_=logWrapper('c:'+this.id+':');this.transportManager_=new TransportManager(repoInfo_);this.log_('Connection created');this.start_();}/**\r\n     * Starts a connection attempt\r\n     */start_(){const conn=this.transportManager_.initialTransport();this.conn_=new conn(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,null,this.lastSessionId);// For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n// can consider the transport healthy.\nthis.primaryResponsesRequired_=conn['responsesRequiredToBeHealthy']||0;const onMessageReceived=this.connReceiver_(this.conn_);const onConnectionLost=this.disconnReceiver_(this.conn_);this.tx_=this.conn_;this.rx_=this.conn_;this.secondaryConn_=null;this.isHealthy_=false;/*\r\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\r\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\r\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\r\n         * still have the context of your originating frame.\r\n         */setTimeout(()=>{// this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\nthis.conn_&&this.conn_.open(onMessageReceived,onConnectionLost);},Math.floor(0));const healthyTimeoutMS=conn['healthyTimeout']||0;if(healthyTimeoutMS>0){this.healthyTimeout_=setTimeoutNonBlocking(()=>{this.healthyTimeout_=null;if(!this.isHealthy_){if(this.conn_&&this.conn_.bytesReceived>BYTES_RECEIVED_HEALTHY_OVERRIDE){this.log_('Connection exceeded healthy timeout but has received '+this.conn_.bytesReceived+' bytes.  Marking connection healthy.');this.isHealthy_=true;this.conn_.markConnectionHealthy();}else if(this.conn_&&this.conn_.bytesSent>BYTES_SENT_HEALTHY_OVERRIDE){this.log_('Connection exceeded healthy timeout but has sent '+this.conn_.bytesSent+' bytes.  Leaving connection alive.');// NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n// the server.\n}else{this.log_('Closing unhealthy connection after timeout.');this.close();}}// eslint-disable-next-line @typescript-eslint/no-explicit-any\n},Math.floor(healthyTimeoutMS));}}nextTransportId_(){return'c:'+this.id+':'+this.connectionCount++;}disconnReceiver_(conn){return everConnected=>{if(conn===this.conn_){this.onConnectionLost_(everConnected);}else if(conn===this.secondaryConn_){this.log_('Secondary connection lost.');this.onSecondaryConnectionLost_();}else{this.log_('closing an old connection');}};}connReceiver_(conn){return message=>{if(this.state_!==2/* DISCONNECTED */){if(conn===this.rx_){this.onPrimaryMessageReceived_(message);}else if(conn===this.secondaryConn_){this.onSecondaryMessageReceived_(message);}else{this.log_('message on old connection');}}};}/**\r\n     * @param dataMsg - An arbitrary data message to be sent to the server\r\n     */sendRequest(dataMsg){// wrap in a data message envelope and send it on\nconst msg={t:'d',d:dataMsg};this.sendData_(msg);}tryCleanupConnection(){if(this.tx_===this.secondaryConn_&&this.rx_===this.secondaryConn_){this.log_('cleaning up and promoting a connection: '+this.secondaryConn_.connId);this.conn_=this.secondaryConn_;this.secondaryConn_=null;// the server will shutdown the old connection\n}}onSecondaryControl_(controlData){if(MESSAGE_TYPE in controlData){const cmd=controlData[MESSAGE_TYPE];if(cmd===SWITCH_ACK){this.upgradeIfSecondaryHealthy_();}else if(cmd===CONTROL_RESET){// Most likely the session wasn't valid. Abandon the switch attempt\nthis.log_('Got a reset on secondary, closing it');this.secondaryConn_.close();// If we were already using this connection for something, than we need to fully close\nif(this.tx_===this.secondaryConn_||this.rx_===this.secondaryConn_){this.close();}}else if(cmd===CONTROL_PONG){this.log_('got pong on secondary.');this.secondaryResponsesRequired_--;this.upgradeIfSecondaryHealthy_();}}}onSecondaryMessageReceived_(parsedData){const layer=requireKey('t',parsedData);const data=requireKey('d',parsedData);if(layer==='c'){this.onSecondaryControl_(data);}else if(layer==='d'){// got a data message, but we're still second connection. Need to buffer it up\nthis.pendingDataMessages.push(data);}else{throw new Error('Unknown protocol layer: '+layer);}}upgradeIfSecondaryHealthy_(){if(this.secondaryResponsesRequired_<=0){this.log_('Secondary connection is healthy.');this.isHealthy_=true;this.secondaryConn_.markConnectionHealthy();this.proceedWithUpgrade_();}else{// Send a ping to make sure the connection is healthy.\nthis.log_('sending ping on secondary.');this.secondaryConn_.send({t:'c',d:{t:PING,d:{}}});}}proceedWithUpgrade_(){// tell this connection to consider itself open\nthis.secondaryConn_.start();// send ack\nthis.log_('sending client ack on secondary');this.secondaryConn_.send({t:'c',d:{t:SWITCH_ACK,d:{}}});// send end packet on primary transport, switch to sending on this one\n// can receive on this one, buffer responses until end received on primary transport\nthis.log_('Ending transmission on primary');this.conn_.send({t:'c',d:{t:END_TRANSMISSION,d:{}}});this.tx_=this.secondaryConn_;this.tryCleanupConnection();}onPrimaryMessageReceived_(parsedData){// Must refer to parsedData properties in quotes, so closure doesn't touch them.\nconst layer=requireKey('t',parsedData);const data=requireKey('d',parsedData);if(layer==='c'){this.onControl_(data);}else if(layer==='d'){this.onDataMessage_(data);}}onDataMessage_(message){this.onPrimaryResponse_();// We don't do anything with data messages, just kick them up a level\nthis.onMessage_(message);}onPrimaryResponse_(){if(!this.isHealthy_){this.primaryResponsesRequired_--;if(this.primaryResponsesRequired_<=0){this.log_('Primary connection is healthy.');this.isHealthy_=true;this.conn_.markConnectionHealthy();}}}onControl_(controlData){const cmd=requireKey(MESSAGE_TYPE,controlData);if(MESSAGE_DATA in controlData){const payload=controlData[MESSAGE_DATA];if(cmd===SERVER_HELLO){this.onHandshake_(payload);}else if(cmd===END_TRANSMISSION){this.log_('recvd end transmission on primary');this.rx_=this.secondaryConn_;for(let i=0;i<this.pendingDataMessages.length;++i){this.onDataMessage_(this.pendingDataMessages[i]);}this.pendingDataMessages=[];this.tryCleanupConnection();}else if(cmd===CONTROL_SHUTDOWN){// This was previously the 'onKill' callback passed to the lower-level connection\n// payload in this case is the reason for the shutdown. Generally a human-readable error\nthis.onConnectionShutdown_(payload);}else if(cmd===CONTROL_RESET){// payload in this case is the host we should contact\nthis.onReset_(payload);}else if(cmd===CONTROL_ERROR){error('Server Error: '+payload);}else if(cmd===CONTROL_PONG){this.log_('got pong on primary.');this.onPrimaryResponse_();this.sendPingOnPrimaryIfNecessary_();}else{error('Unknown control packet command: '+cmd);}}}/**\r\n     * @param handshake - The handshake data returned from the server\r\n     */onHandshake_(handshake){const timestamp=handshake.ts;const version=handshake.v;const host=handshake.h;this.sessionId=handshake.s;this.repoInfo_.host=host;// if we've already closed the connection, then don't bother trying to progress further\nif(this.state_===0/* CONNECTING */){this.conn_.start();this.onConnectionEstablished_(this.conn_,timestamp);if(PROTOCOL_VERSION!==version){warn('Protocol version mismatch detected');}// TODO: do we want to upgrade? when? maybe a delay?\nthis.tryStartUpgrade_();}}tryStartUpgrade_(){const conn=this.transportManager_.upgradeTransport();if(conn){this.startUpgrade_(conn);}}startUpgrade_(conn){this.secondaryConn_=new conn(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,this.sessionId);// For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n// can consider the transport healthy.\nthis.secondaryResponsesRequired_=conn['responsesRequiredToBeHealthy']||0;const onMessage=this.connReceiver_(this.secondaryConn_);const onDisconnect=this.disconnReceiver_(this.secondaryConn_);this.secondaryConn_.open(onMessage,onDisconnect);// If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\nsetTimeoutNonBlocking(()=>{if(this.secondaryConn_){this.log_('Timed out trying to upgrade.');this.secondaryConn_.close();}},Math.floor(UPGRADE_TIMEOUT));}onReset_(host){this.log_('Reset packet received.  New host: '+host);this.repoInfo_.host=host;// TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n// We don't currently support resets after the connection has already been established\nif(this.state_===1/* CONNECTED */){this.close();}else{// Close whatever connections we have open and start again.\nthis.closeConnections_();this.start_();}}onConnectionEstablished_(conn,timestamp){this.log_('Realtime connection established.');this.conn_=conn;this.state_=1/* CONNECTED */;if(this.onReady_){this.onReady_(timestamp,this.sessionId);this.onReady_=null;}// If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n// send some pings.\nif(this.primaryResponsesRequired_===0){this.log_('Primary connection is healthy.');this.isHealthy_=true;}else{setTimeoutNonBlocking(()=>{this.sendPingOnPrimaryIfNecessary_();},Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));}}sendPingOnPrimaryIfNecessary_(){// If the connection isn't considered healthy yet, we'll send a noop ping packet request.\nif(!this.isHealthy_&&this.state_===1/* CONNECTED */){this.log_('sending ping on primary.');this.sendData_({t:'c',d:{t:PING,d:{}}});}}onSecondaryConnectionLost_(){const conn=this.secondaryConn_;this.secondaryConn_=null;if(this.tx_===conn||this.rx_===conn){// we are relying on this connection already in some capacity. Therefore, a failure is real\nthis.close();}}/**\r\n     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if\r\n     * we should flush the host cache\r\n     */onConnectionLost_(everConnected){this.conn_=null;// NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n// called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\nif(!everConnected&&this.state_===0/* CONNECTING */){this.log_('Realtime connection failed.');// Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\nif(this.repoInfo_.isCacheableHost()){PersistentStorage.remove('host:'+this.repoInfo_.host);// reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\nthis.repoInfo_.internalHost=this.repoInfo_.host;}}else if(this.state_===1/* CONNECTED */){this.log_('Realtime connection lost.');}this.close();}onConnectionShutdown_(reason){this.log_('Connection shutdown command received. Shutting down...');if(this.onKill_){this.onKill_(reason);this.onKill_=null;}// We intentionally don't want to fire onDisconnect (kill is a different case),\n// so clear the callback.\nthis.onDisconnect_=null;this.close();}sendData_(data){if(this.state_!==1/* CONNECTED */){throw'Connection is not connected';}else{this.tx_.send(data);}}/**\r\n     * Cleans up this connection, calling the appropriate callbacks\r\n     */close(){if(this.state_!==2/* DISCONNECTED */){this.log_('Closing realtime connection.');this.state_=2/* DISCONNECTED */;this.closeConnections_();if(this.onDisconnect_){this.onDisconnect_();this.onDisconnect_=null;}}}closeConnections_(){this.log_('Shutting down all connections');if(this.conn_){this.conn_.close();this.conn_=null;}if(this.secondaryConn_){this.secondaryConn_.close();this.secondaryConn_=null;}if(this.healthyTimeout_){clearTimeout(this.healthyTimeout_);this.healthyTimeout_=null;}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Interface defining the set of actions that can be performed against the Firebase server\r\n * (basically corresponds to our wire protocol).\r\n *\r\n * @interface\r\n */class ServerActions{put(pathString,data,onComplete,hash){}merge(pathString,data,onComplete,hash){}/**\r\n     * Refreshes the auth token for the current connection.\r\n     * @param token - The authentication token\r\n     */refreshAuthToken(token){}/**\r\n     * Refreshes the app check token for the current connection.\r\n     * @param token The app check token\r\n     */refreshAppCheckToken(token){}onDisconnectPut(pathString,data,onComplete){}onDisconnectMerge(pathString,data,onComplete){}onDisconnectCancel(pathString,onComplete){}reportStats(stats){}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Base class to be used if you want to emit events. Call the constructor with\r\n * the set of allowed event names.\r\n */class EventEmitter{constructor(allowedEvents_){this.allowedEvents_=allowedEvents_;this.listeners_={};(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(Array.isArray(allowedEvents_)&&allowedEvents_.length>0,'Requires a non-empty array');}/**\r\n     * To be called by derived classes to trigger events.\r\n     */trigger(eventType,...varArgs){if(Array.isArray(this.listeners_[eventType])){// Clone the list, since callbacks could add/remove listeners.\nconst listeners=[...this.listeners_[eventType]];for(let i=0;i<listeners.length;i++){listeners[i].callback.apply(listeners[i].context,varArgs);}}}on(eventType,callback,context){this.validateEventType_(eventType);this.listeners_[eventType]=this.listeners_[eventType]||[];this.listeners_[eventType].push({callback,context});const eventData=this.getInitialEvent(eventType);if(eventData){callback.apply(context,eventData);}}off(eventType,callback,context){this.validateEventType_(eventType);const listeners=this.listeners_[eventType]||[];for(let i=0;i<listeners.length;i++){if(listeners[i].callback===callback&&(!context||context===listeners[i].context)){listeners.splice(i,1);return;}}}validateEventType_(eventType){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.allowedEvents_.find(et=>{return et===eventType;}),'Unknown event: '+eventType);}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Monitors online state (as reported by window.online/offline events).\r\n *\r\n * The expectation is that this could have many false positives (thinks we are online\r\n * when we're not), but no false negatives.  So we can safely use it to determine when\r\n * we definitely cannot reach the internet.\r\n */class OnlineMonitor extends EventEmitter{constructor(){super(['online']);this.online_=true;// We've had repeated complaints that Cordova apps can get stuck \"offline\", e.g.\n// https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810\n// It would seem that the 'online' event does not always fire consistently. So we disable it\n// for Cordova.\nif(typeof window!=='undefined'&&typeof window.addEventListener!=='undefined'&&!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isMobileCordova)()){window.addEventListener('online',()=>{if(!this.online_){this.online_=true;this.trigger('online',true);}},false);window.addEventListener('offline',()=>{if(this.online_){this.online_=false;this.trigger('online',false);}},false);}}static getInstance(){return new OnlineMonitor();}getInitialEvent(eventType){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventType==='online','Unknown event type: '+eventType);return[this.online_];}currentlyOnline(){return this.online_;}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Maximum key depth. */const MAX_PATH_DEPTH=32;/** Maximum number of (UTF8) bytes in a Firebase path. */const MAX_PATH_LENGTH_BYTES=768;/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */class Path{/**\r\n     * @param pathOrString - Path string to parse, or another path, or the raw\r\n     * tokens array\r\n     */constructor(pathOrString,pieceNum){if(pieceNum===void 0){this.pieces_=pathOrString.split('/');// Remove empty pieces.\nlet copyTo=0;for(let i=0;i<this.pieces_.length;i++){if(this.pieces_[i].length>0){this.pieces_[copyTo]=this.pieces_[i];copyTo++;}}this.pieces_.length=copyTo;this.pieceNum_=0;}else{this.pieces_=pathOrString;this.pieceNum_=pieceNum;}}toString(){let pathString='';for(let i=this.pieceNum_;i<this.pieces_.length;i++){if(this.pieces_[i]!==''){pathString+='/'+this.pieces_[i];}}return pathString||'/';}}function newEmptyPath(){return new Path('');}function pathGetFront(path){if(path.pieceNum_>=path.pieces_.length){return null;}return path.pieces_[path.pieceNum_];}/**\r\n * @returns The number of segments in this path\r\n */function pathGetLength(path){return path.pieces_.length-path.pieceNum_;}function pathPopFront(path){let pieceNum=path.pieceNum_;if(pieceNum<path.pieces_.length){pieceNum++;}return new Path(path.pieces_,pieceNum);}function pathGetBack(path){if(path.pieceNum_<path.pieces_.length){return path.pieces_[path.pieces_.length-1];}return null;}function pathToUrlEncodedString(path){let pathString='';for(let i=path.pieceNum_;i<path.pieces_.length;i++){if(path.pieces_[i]!==''){pathString+='/'+encodeURIComponent(String(path.pieces_[i]));}}return pathString||'/';}/**\r\n * Shallow copy of the parts of the path.\r\n *\r\n */function pathSlice(path,begin=0){return path.pieces_.slice(path.pieceNum_+begin);}function pathParent(path){if(path.pieceNum_>=path.pieces_.length){return null;}const pieces=[];for(let i=path.pieceNum_;i<path.pieces_.length-1;i++){pieces.push(path.pieces_[i]);}return new Path(pieces,0);}function pathChild(path,childPathObj){const pieces=[];for(let i=path.pieceNum_;i<path.pieces_.length;i++){pieces.push(path.pieces_[i]);}if(childPathObj instanceof Path){for(let i=childPathObj.pieceNum_;i<childPathObj.pieces_.length;i++){pieces.push(childPathObj.pieces_[i]);}}else{const childPieces=childPathObj.split('/');for(let i=0;i<childPieces.length;i++){if(childPieces[i].length>0){pieces.push(childPieces[i]);}}}return new Path(pieces,0);}/**\r\n * @returns True if there are no segments in this path\r\n */function pathIsEmpty(path){return path.pieceNum_>=path.pieces_.length;}/**\r\n * @returns The path from outerPath to innerPath\r\n */function newRelativePath(outerPath,innerPath){const outer=pathGetFront(outerPath),inner=pathGetFront(innerPath);if(outer===null){return innerPath;}else if(outer===inner){return newRelativePath(pathPopFront(outerPath),pathPopFront(innerPath));}else{throw new Error('INTERNAL ERROR: innerPath ('+innerPath+') is not within '+'outerPath ('+outerPath+')');}}/**\r\n * @returns -1, 0, 1 if left is less, equal, or greater than the right.\r\n */function pathCompare(left,right){const leftKeys=pathSlice(left,0);const rightKeys=pathSlice(right,0);for(let i=0;i<leftKeys.length&&i<rightKeys.length;i++){const cmp=nameCompare(leftKeys[i],rightKeys[i]);if(cmp!==0){return cmp;}}if(leftKeys.length===rightKeys.length){return 0;}return leftKeys.length<rightKeys.length?-1:1;}/**\r\n * @returns true if paths are the same.\r\n */function pathEquals(path,other){if(pathGetLength(path)!==pathGetLength(other)){return false;}for(let i=path.pieceNum_,j=other.pieceNum_;i<=path.pieces_.length;i++,j++){if(path.pieces_[i]!==other.pieces_[j]){return false;}}return true;}/**\r\n * @returns True if this path is a parent (or the same as) other\r\n */function pathContains(path,other){let i=path.pieceNum_;let j=other.pieceNum_;if(pathGetLength(path)>pathGetLength(other)){return false;}while(i<path.pieces_.length){if(path.pieces_[i]!==other.pieces_[j]){return false;}++i;++j;}return true;}/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */class ValidationPath{/**\r\n     * @param path - Initial Path.\r\n     * @param errorPrefix_ - Prefix for any error messages.\r\n     */constructor(path,errorPrefix_){this.errorPrefix_=errorPrefix_;this.parts_=pathSlice(path,0);/** Initialize to number of '/' chars needed in path. */this.byteLength_=Math.max(1,this.parts_.length);for(let i=0;i<this.parts_.length;i++){this.byteLength_+=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(this.parts_[i]);}validationPathCheckValid(this);}}function validationPathPush(validationPath,child){// Count the needed '/'\nif(validationPath.parts_.length>0){validationPath.byteLength_+=1;}validationPath.parts_.push(child);validationPath.byteLength_+=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(child);validationPathCheckValid(validationPath);}function validationPathPop(validationPath){const last=validationPath.parts_.pop();validationPath.byteLength_-=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(last);// Un-count the previous '/'\nif(validationPath.parts_.length>0){validationPath.byteLength_-=1;}}function validationPathCheckValid(validationPath){if(validationPath.byteLength_>MAX_PATH_LENGTH_BYTES){throw new Error(validationPath.errorPrefix_+'has a key path longer than '+MAX_PATH_LENGTH_BYTES+' bytes ('+validationPath.byteLength_+').');}if(validationPath.parts_.length>MAX_PATH_DEPTH){throw new Error(validationPath.errorPrefix_+'path specified exceeds the maximum depth that can be written ('+MAX_PATH_DEPTH+') or object contains a cycle '+validationPathToErrorString(validationPath));}}/**\r\n * String for use in error messages - uses '.' notation for path.\r\n */function validationPathToErrorString(validationPath){if(validationPath.parts_.length===0){return'';}return\"in property '\"+validationPath.parts_.join('.')+\"'\";}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class VisibilityMonitor extends EventEmitter{constructor(){super(['visible']);let hidden;let visibilityChange;if(typeof document!=='undefined'&&typeof document.addEventListener!=='undefined'){if(typeof document['hidden']!=='undefined'){// Opera 12.10 and Firefox 18 and later support\nvisibilityChange='visibilitychange';hidden='hidden';}else if(typeof document['mozHidden']!=='undefined'){visibilityChange='mozvisibilitychange';hidden='mozHidden';}else if(typeof document['msHidden']!=='undefined'){visibilityChange='msvisibilitychange';hidden='msHidden';}else if(typeof document['webkitHidden']!=='undefined'){visibilityChange='webkitvisibilitychange';hidden='webkitHidden';}}// Initially, we always assume we are visible. This ensures that in browsers\n// without page visibility support or in cases where we are never visible\n// (e.g. chrome extension), we act as if we are visible, i.e. don't delay\n// reconnects\nthis.visible_=true;if(visibilityChange){document.addEventListener(visibilityChange,()=>{const visible=!document[hidden];if(visible!==this.visible_){this.visible_=visible;this.trigger('visible',visible);}},false);}}static getInstance(){return new VisibilityMonitor();}getInitialEvent(eventType){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventType==='visible','Unknown event type: '+eventType);return[this.visible_];}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const RECONNECT_MIN_DELAY=1000;const RECONNECT_MAX_DELAY_DEFAULT=60*5*1000;// 5 minutes in milliseconds (Case: 1858)\nconst GET_CONNECT_TIMEOUT=3*1000;const RECONNECT_MAX_DELAY_FOR_ADMINS=30*1000;// 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER=1.3;const RECONNECT_DELAY_RESET_TIMEOUT=30000;// Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON='server_kill';// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_TOKEN_THRESHOLD=3;/**\r\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\r\n *\r\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\r\n * in quotes to make sure the closure compiler does not minify them.\r\n */class PersistentConnection extends ServerActions{/**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param applicationId_ - The Firebase App ID for this project\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */constructor(repoInfo_,applicationId_,onDataUpdate_,onConnectStatus_,onServerInfoUpdate_,authTokenProvider_,appCheckTokenProvider_,authOverride_){super();this.repoInfo_=repoInfo_;this.applicationId_=applicationId_;this.onDataUpdate_=onDataUpdate_;this.onConnectStatus_=onConnectStatus_;this.onServerInfoUpdate_=onServerInfoUpdate_;this.authTokenProvider_=authTokenProvider_;this.appCheckTokenProvider_=appCheckTokenProvider_;this.authOverride_=authOverride_;// Used for diagnostic logging.\nthis.id=PersistentConnection.nextPersistentConnectionId_++;this.log_=logWrapper('p:'+this.id+':');this.interruptReasons_={};this.listens=new Map();this.outstandingPuts_=[];this.outstandingGets_=[];this.outstandingPutCount_=0;this.outstandingGetCount_=0;this.onDisconnectRequestQueue_=[];this.connected_=false;this.reconnectDelay_=RECONNECT_MIN_DELAY;this.maxReconnectDelay_=RECONNECT_MAX_DELAY_DEFAULT;this.securityDebugCallback_=null;this.lastSessionId=null;this.establishConnectionTimer_=null;this.visible_=false;// Before we get connected, we keep a queue of pending messages to send.\nthis.requestCBHash_={};this.requestNumber_=0;this.realtime_=null;this.authToken_=null;this.appCheckToken_=null;this.forceTokenRefresh_=false;this.invalidAuthTokenCount_=0;this.invalidAppCheckTokenCount_=0;this.firstConnection_=true;this.lastConnectionAttemptTime_=null;this.lastConnectionEstablishedTime_=null;if(authOverride_&&!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()){throw new Error('Auth override specified in options, but not supported on non Node.js platforms');}VisibilityMonitor.getInstance().on('visible',this.onVisible_,this);if(repoInfo_.host.indexOf('fblocal')===-1){OnlineMonitor.getInstance().on('online',this.onOnline_,this);}}sendRequest(action,body,onResponse){const curReqNum=++this.requestNumber_;const msg={r:curReqNum,a:action,b:body};this.log_((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(msg));(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected_,\"sendRequest call when we're not connected not allowed.\");this.realtime_.sendRequest(msg);if(onResponse){this.requestCBHash_[curReqNum]=onResponse;}}get(query){this.initConnection_();const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();const request={p:query._path.toString(),q:query._queryObject};const outstandingGet={action:'g',request,onComplete:message=>{const payload=message['d'];if(message['s']==='ok'){this.onDataUpdate_(request['p'],payload,/*isMerge*/false,/*tag*/null);deferred.resolve(payload);}else{deferred.reject(payload);}}};this.outstandingGets_.push(outstandingGet);this.outstandingGetCount_++;const index=this.outstandingGets_.length-1;if(!this.connected_){setTimeout(()=>{const get=this.outstandingGets_[index];if(get===undefined||outstandingGet!==get){return;}delete this.outstandingGets_[index];this.outstandingGetCount_--;if(this.outstandingGetCount_===0){this.outstandingGets_=[];}this.log_('get '+index+' timed out on connection');deferred.reject(new Error('Client is offline.'));},GET_CONNECT_TIMEOUT);}if(this.connected_){this.sendGet_(index);}return deferred.promise;}listen(query,currentHashFn,tag,onComplete){this.initConnection_();const queryId=query._queryIdentifier;const pathString=query._path.toString();this.log_('Listen called for '+pathString+' '+queryId);if(!this.listens.has(pathString)){this.listens.set(pathString,new Map());}(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault()||!query._queryParams.loadsAllData(),'listen() called for non-default but complete query');(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.listens.get(pathString).has(queryId),'listen() called twice for same path/queryId.');const listenSpec={onComplete,hashFn:currentHashFn,query,tag};this.listens.get(pathString).set(queryId,listenSpec);if(this.connected_){this.sendListen_(listenSpec);}}sendGet_(index){const get=this.outstandingGets_[index];this.sendRequest('g',get.request,message=>{delete this.outstandingGets_[index];this.outstandingGetCount_--;if(this.outstandingGetCount_===0){this.outstandingGets_=[];}if(get.onComplete){get.onComplete(message);}});}sendListen_(listenSpec){const query=listenSpec.query;const pathString=query._path.toString();const queryId=query._queryIdentifier;this.log_('Listen on '+pathString+' for '+queryId);const req={/*path*/p:pathString};const action='q';// Only bother to send query if it's non-default.\nif(listenSpec.tag){req['q']=query._queryObject;req['t']=listenSpec.tag;}req[/*hash*/'h']=listenSpec.hashFn();this.sendRequest(action,req,message=>{const payload=message[/*data*/'d'];const status=message[/*status*/'s'];// print warnings in any case...\nPersistentConnection.warnOnListenWarnings_(payload,query);const currentListenSpec=this.listens.get(pathString)&&this.listens.get(pathString).get(queryId);// only trigger actions if the listen hasn't been removed and readded\nif(currentListenSpec===listenSpec){this.log_('listen response',message);if(status!=='ok'){this.removeListen_(pathString,queryId);}if(listenSpec.onComplete){listenSpec.onComplete(status,payload);}}});}static warnOnListenWarnings_(payload,query){if(payload&&typeof payload==='object'&&(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(payload,'w')){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst warnings=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(payload,'w');if(Array.isArray(warnings)&&~warnings.indexOf('no_index')){const indexSpec='\".indexOn\": \"'+query._queryParams.getIndex().toString()+'\"';const indexPath=query._path.toString();warn(`Using an unspecified index. Your data will be downloaded and `+`filtered on the client. Consider adding ${indexSpec} at `+`${indexPath} to your security rules for better performance.`);}}}refreshAuthToken(token){this.authToken_=token;this.log_('Auth token refreshed');if(this.authToken_){this.tryAuth();}else{//If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n//the credential so we dont become authenticated next time we connect.\nif(this.connected_){this.sendRequest('unauth',{},()=>{});}}this.reduceReconnectDelayIfAdminCredential_(token);}reduceReconnectDelayIfAdminCredential_(credential){// NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n// Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\nconst isFirebaseSecret=credential&&credential.length===40;if(isFirebaseSecret||(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isAdmin)(credential)){this.log_('Admin auth credential detected.  Reducing max reconnect time.');this.maxReconnectDelay_=RECONNECT_MAX_DELAY_FOR_ADMINS;}}refreshAppCheckToken(token){this.appCheckToken_=token;this.log_('App check token refreshed');if(this.appCheckToken_){this.tryAppCheck();}else{//If we're connected we want to let the server know to unauthenticate us.\n//If we're not connected, simply delete the credential so we dont become\n// authenticated next time we connect.\nif(this.connected_){this.sendRequest('unappeck',{},()=>{});}}}/**\r\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\r\n     * a auth revoked (the connection is closed).\r\n     */tryAuth(){if(this.connected_&&this.authToken_){const token=this.authToken_;const authMethod=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isValidFormat)(token)?'auth':'gauth';const requestData={cred:token};if(this.authOverride_===null){requestData['noauth']=true;}else if(typeof this.authOverride_==='object'){requestData['authvar']=this.authOverride_;}this.sendRequest(authMethod,requestData,res=>{const status=res[/*status*/'s'];const data=res[/*data*/'d']||'error';if(this.authToken_===token){if(status==='ok'){this.invalidAuthTokenCount_=0;}else{// Triggers reconnect and force refresh for auth token\nthis.onAuthRevoked_(status,data);}}});}}/**\r\n     * Attempts to authenticate with the given token. If the authentication\r\n     * attempt fails, it's triggered like the token was revoked (the connection is\r\n     * closed).\r\n     */tryAppCheck(){if(this.connected_&&this.appCheckToken_){this.sendRequest('appcheck',{'token':this.appCheckToken_},res=>{const status=res[/*status*/'s'];const data=res[/*data*/'d']||'error';if(status==='ok'){this.invalidAppCheckTokenCount_=0;}else{this.onAppCheckRevoked_(status,data);}});}}/**\r\n     * @inheritDoc\r\n     */unlisten(query,tag){const pathString=query._path.toString();const queryId=query._queryIdentifier;this.log_('Unlisten called for '+pathString+' '+queryId);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault()||!query._queryParams.loadsAllData(),'unlisten() called for non-default but complete query');const listen=this.removeListen_(pathString,queryId);if(listen&&this.connected_){this.sendUnlisten_(pathString,queryId,query._queryObject,tag);}}sendUnlisten_(pathString,queryId,queryObj,tag){this.log_('Unlisten on '+pathString+' for '+queryId);const req={/*path*/p:pathString};const action='n';// Only bother sending queryId if it's non-default.\nif(tag){req['q']=queryObj;req['t']=tag;}this.sendRequest(action,req);}onDisconnectPut(pathString,data,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_('o',pathString,data,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString,action:'o',data,onComplete});}}onDisconnectMerge(pathString,data,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_('om',pathString,data,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString,action:'om',data,onComplete});}}onDisconnectCancel(pathString,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_('oc',pathString,null,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString,action:'oc',data:null,onComplete});}}sendOnDisconnect_(action,pathString,data,onComplete){const request={/*path*/p:pathString,/*data*/d:data};this.log_('onDisconnect '+action,request);this.sendRequest(action,request,response=>{if(onComplete){setTimeout(()=>{onComplete(response[/*status*/'s'],response[/* data */'d']);},Math.floor(0));}});}put(pathString,data,onComplete,hash){this.putInternal('p',pathString,data,onComplete,hash);}merge(pathString,data,onComplete,hash){this.putInternal('m',pathString,data,onComplete,hash);}putInternal(action,pathString,data,onComplete,hash){this.initConnection_();const request={/*path*/p:pathString,/*data*/d:data};if(hash!==undefined){request[/*hash*/'h']=hash;}// TODO: Only keep track of the most recent put for a given path?\nthis.outstandingPuts_.push({action,request,onComplete});this.outstandingPutCount_++;const index=this.outstandingPuts_.length-1;if(this.connected_){this.sendPut_(index);}else{this.log_('Buffering put: '+pathString);}}sendPut_(index){const action=this.outstandingPuts_[index].action;const request=this.outstandingPuts_[index].request;const onComplete=this.outstandingPuts_[index].onComplete;this.outstandingPuts_[index].queued=this.connected_;this.sendRequest(action,request,message=>{this.log_(action+' response',message);delete this.outstandingPuts_[index];this.outstandingPutCount_--;// Clean up array occasionally.\nif(this.outstandingPutCount_===0){this.outstandingPuts_=[];}if(onComplete){onComplete(message[/*status*/'s'],message[/* data */'d']);}});}reportStats(stats){// If we're not connected, we just drop the stats.\nif(this.connected_){const request={/*counters*/c:stats};this.log_('reportStats',request);this.sendRequest(/*stats*/'s',request,result=>{const status=result[/*status*/'s'];if(status!=='ok'){const errorReason=result[/* data */'d'];this.log_('reportStats','Error sending stats: '+errorReason);}});}}onDataMessage_(message){if('r'in message){// this is a response\nthis.log_('from server: '+(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(message));const reqNum=message['r'];const onResponse=this.requestCBHash_[reqNum];if(onResponse){delete this.requestCBHash_[reqNum];onResponse(message[/*body*/'b']);}}else if('error'in message){throw'A server-side error has occurred: '+message['error'];}else if('a'in message){// a and b are action and body, respectively\nthis.onDataPush_(message['a'],message['b']);}}onDataPush_(action,body){this.log_('handleServerMessage',action,body);if(action==='d'){this.onDataUpdate_(body[/*path*/'p'],body[/*data*/'d'],/*isMerge*/false,body['t']);}else if(action==='m'){this.onDataUpdate_(body[/*path*/'p'],body[/*data*/'d'],/*isMerge=*/true,body['t']);}else if(action==='c'){this.onListenRevoked_(body[/*path*/'p'],body[/*query*/'q']);}else if(action==='ac'){this.onAuthRevoked_(body[/*status code*/'s'],body[/* explanation */'d']);}else if(action==='apc'){this.onAppCheckRevoked_(body[/*status code*/'s'],body[/* explanation */'d']);}else if(action==='sd'){this.onSecurityDebugPacket_(body);}else{error('Unrecognized action received from server: '+(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(action)+'\\nAre you using the latest client?');}}onReady_(timestamp,sessionId){this.log_('connection ready');this.connected_=true;this.lastConnectionEstablishedTime_=new Date().getTime();this.handleTimestamp_(timestamp);this.lastSessionId=sessionId;if(this.firstConnection_){this.sendConnectStats_();}this.restoreState_();this.firstConnection_=false;this.onConnectStatus_(true);}scheduleConnect_(timeout){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.realtime_,\"Scheduling a connect when we're already connected/ing?\");if(this.establishConnectionTimer_){clearTimeout(this.establishConnectionTimer_);}// NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n// Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\nthis.establishConnectionTimer_=setTimeout(()=>{this.establishConnectionTimer_=null;this.establishConnection_();// eslint-disable-next-line @typescript-eslint/no-explicit-any\n},Math.floor(timeout));}initConnection_(){if(!this.realtime_&&this.firstConnection_){this.scheduleConnect_(0);}}onVisible_(visible){// NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\nif(visible&&!this.visible_&&this.reconnectDelay_===this.maxReconnectDelay_){this.log_('Window became visible.  Reducing delay.');this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}this.visible_=visible;}onOnline_(online){if(online){this.log_('Browser went online.');this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}else{this.log_('Browser went offline.  Killing connection.');if(this.realtime_){this.realtime_.close();}}}onRealtimeDisconnect_(){this.log_('data client disconnected');this.connected_=false;this.realtime_=null;// Since we don't know if our sent transactions succeeded or not, we need to cancel them.\nthis.cancelSentTransactions_();// Clear out the pending requests.\nthis.requestCBHash_={};if(this.shouldReconnect_()){if(!this.visible_){this.log_(\"Window isn't visible.  Delaying reconnect.\");this.reconnectDelay_=this.maxReconnectDelay_;this.lastConnectionAttemptTime_=new Date().getTime();}else if(this.lastConnectionEstablishedTime_){// If we've been connected long enough, reset reconnect delay to minimum.\nconst timeSinceLastConnectSucceeded=new Date().getTime()-this.lastConnectionEstablishedTime_;if(timeSinceLastConnectSucceeded>RECONNECT_DELAY_RESET_TIMEOUT){this.reconnectDelay_=RECONNECT_MIN_DELAY;}this.lastConnectionEstablishedTime_=null;}const timeSinceLastConnectAttempt=new Date().getTime()-this.lastConnectionAttemptTime_;let reconnectDelay=Math.max(0,this.reconnectDelay_-timeSinceLastConnectAttempt);reconnectDelay=Math.random()*reconnectDelay;this.log_('Trying to reconnect in '+reconnectDelay+'ms');this.scheduleConnect_(reconnectDelay);// Adjust reconnect delay for next time.\nthis.reconnectDelay_=Math.min(this.maxReconnectDelay_,this.reconnectDelay_*RECONNECT_DELAY_MULTIPLIER);}this.onConnectStatus_(false);}async establishConnection_(){if(this.shouldReconnect_()){this.log_('Making a connection attempt');this.lastConnectionAttemptTime_=new Date().getTime();this.lastConnectionEstablishedTime_=null;const onDataMessage=this.onDataMessage_.bind(this);const onReady=this.onReady_.bind(this);const onDisconnect=this.onRealtimeDisconnect_.bind(this);const connId=this.id+':'+PersistentConnection.nextConnectionId_++;const lastSessionId=this.lastSessionId;let canceled=false;let connection=null;const closeFn=function(){if(connection){connection.close();}else{canceled=true;onDisconnect();}};const sendRequestFn=function(msg){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(connection,\"sendRequest call when we're not connected not allowed.\");connection.sendRequest(msg);};this.realtime_={close:closeFn,sendRequest:sendRequestFn};const forceRefresh=this.forceTokenRefresh_;this.forceTokenRefresh_=false;try{// First fetch auth and app check token, and establish connection after\n// fetching the token was successful\nconst[authToken,appCheckToken]=await Promise.all([this.authTokenProvider_.getToken(forceRefresh),this.appCheckTokenProvider_.getToken(forceRefresh)]);if(!canceled){log('getToken() completed. Creating connection.');this.authToken_=authToken&&authToken.accessToken;this.appCheckToken_=appCheckToken&&appCheckToken.token;connection=new Connection(connId,this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,onDataMessage,onReady,onDisconnect,/* onKill= */reason=>{warn(reason+' ('+this.repoInfo_.toString()+')');this.interrupt(SERVER_KILL_INTERRUPT_REASON);},lastSessionId);}else{log('getToken() completed but was canceled');}}catch(error){this.log_('Failed to get token: '+error);if(!canceled){if(this.repoInfo_.nodeAdmin){// This may be a critical error for the Admin Node.js SDK, so log a warning.\n// But getToken() may also just have temporarily failed, so we still want to\n// continue retrying.\nwarn(error);}closeFn();}}}}interrupt(reason){log('Interrupting connection for reason: '+reason);this.interruptReasons_[reason]=true;if(this.realtime_){this.realtime_.close();}else{if(this.establishConnectionTimer_){clearTimeout(this.establishConnectionTimer_);this.establishConnectionTimer_=null;}if(this.connected_){this.onRealtimeDisconnect_();}}}resume(reason){log('Resuming connection for reason: '+reason);delete this.interruptReasons_[reason];if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.interruptReasons_)){this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}}handleTimestamp_(timestamp){const delta=timestamp-new Date().getTime();this.onServerInfoUpdate_({serverTimeOffset:delta});}cancelSentTransactions_(){for(let i=0;i<this.outstandingPuts_.length;i++){const put=this.outstandingPuts_[i];if(put&&/*hash*/'h'in put.request&&put.queued){if(put.onComplete){put.onComplete('disconnect');}delete this.outstandingPuts_[i];this.outstandingPutCount_--;}}// Clean up array occasionally.\nif(this.outstandingPutCount_===0){this.outstandingPuts_=[];}}onListenRevoked_(pathString,query){// Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\nlet queryId;if(!query){queryId='default';}else{queryId=query.map(q=>ObjectToUniqueKey(q)).join('$');}const listen=this.removeListen_(pathString,queryId);if(listen&&listen.onComplete){listen.onComplete('permission_denied');}}removeListen_(pathString,queryId){const normalizedPathString=new Path(pathString).toString();// normalize path.\nlet listen;if(this.listens.has(normalizedPathString)){const map=this.listens.get(normalizedPathString);listen=map.get(queryId);map.delete(queryId);if(map.size===0){this.listens.delete(normalizedPathString);}}else{// all listens for this path has already been removed\nlisten=undefined;}return listen;}onAuthRevoked_(statusCode,explanation){log('Auth token revoked: '+statusCode+'/'+explanation);this.authToken_=null;this.forceTokenRefresh_=true;this.realtime_.close();if(statusCode==='invalid_token'||statusCode==='permission_denied'){// We'll wait a couple times before logging the warning / increasing the\n// retry period since oauth tokens will report as \"invalid\" if they're\n// just expired. Plus there may be transient issues that resolve themselves.\nthis.invalidAuthTokenCount_++;if(this.invalidAuthTokenCount_>=INVALID_TOKEN_THRESHOLD){// Set a long reconnect delay because recovery is unlikely\nthis.reconnectDelay_=RECONNECT_MAX_DELAY_FOR_ADMINS;// Notify the auth token provider that the token is invalid, which will log\n// a warning\nthis.authTokenProvider_.notifyForInvalidToken();}}}onAppCheckRevoked_(statusCode,explanation){log('App check token revoked: '+statusCode+'/'+explanation);this.appCheckToken_=null;this.forceTokenRefresh_=true;// Note: We don't close the connection as the developer may not have\n// enforcement enabled. The backend closes connections with enforcements.\nif(statusCode==='invalid_token'||statusCode==='permission_denied'){// We'll wait a couple times before logging the warning / increasing the\n// retry period since oauth tokens will report as \"invalid\" if they're\n// just expired. Plus there may be transient issues that resolve themselves.\nthis.invalidAppCheckTokenCount_++;if(this.invalidAppCheckTokenCount_>=INVALID_TOKEN_THRESHOLD){this.appCheckTokenProvider_.notifyForInvalidToken();}}}onSecurityDebugPacket_(body){if(this.securityDebugCallback_){this.securityDebugCallback_(body);}else{if('msg'in body){console.log('FIREBASE: '+body['msg'].replace('\\n','\\nFIREBASE: '));}}}restoreState_(){//Re-authenticate ourselves if we have a credential stored.\nthis.tryAuth();this.tryAppCheck();// Puts depend on having received the corresponding data update from the server before they complete, so we must\n// make sure to send listens before puts.\nfor(const queries of this.listens.values()){for(const listenSpec of queries.values()){this.sendListen_(listenSpec);}}for(let i=0;i<this.outstandingPuts_.length;i++){if(this.outstandingPuts_[i]){this.sendPut_(i);}}while(this.onDisconnectRequestQueue_.length){const request=this.onDisconnectRequestQueue_.shift();this.sendOnDisconnect_(request.action,request.pathString,request.data,request.onComplete);}for(let i=0;i<this.outstandingGets_.length;i++){if(this.outstandingGets_[i]){this.sendGet_(i);}}}/**\r\n     * Sends client stats for first connection\r\n     */sendConnectStats_(){const stats={};let clientName='js';if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()){if(this.repoInfo_.nodeAdmin){clientName='admin_node';}else{clientName='node';}}stats['sdk.'+clientName+'.'+SDK_VERSION.replace(/\\./g,'-')]=1;if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isMobileCordova)()){stats['framework.cordova']=1;}else if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isReactNative)()){stats['framework.reactnative']=1;}this.reportStats(stats);}shouldReconnect_(){const online=OnlineMonitor.getInstance().currentlyOnline();return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.interruptReasons_)&&online;}}PersistentConnection.nextPersistentConnectionId_=0;/**\r\n * Counter for number of connections created. Mainly used for tagging in the logs\r\n */PersistentConnection.nextConnectionId_=0;/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class NamedNode{constructor(name,node){this.name=name;this.node=node;}static Wrap(name,node){return new NamedNode(name,node);}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class Index{/**\r\n     * @returns A standalone comparison function for\r\n     * this index\r\n     */getCompare(){return this.compare.bind(this);}/**\r\n     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,\r\n     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.\r\n     *\r\n     *\r\n     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode\r\n     */indexedValueChanged(oldNode,newNode){const oldWrapped=new NamedNode(MIN_NAME,oldNode);const newWrapped=new NamedNode(MIN_NAME,newNode);return this.compare(oldWrapped,newWrapped)!==0;}/**\r\n     * @returns a node wrapper that will sort equal to or less than\r\n     * any other node wrapper, using this index\r\n     */minPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nreturn NamedNode.MIN;}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */let __EMPTY_NODE;class KeyIndex extends Index{static get __EMPTY_NODE(){return __EMPTY_NODE;}static set __EMPTY_NODE(val){__EMPTY_NODE=val;}compare(a,b){return nameCompare(a.name,b.name);}isDefinedOn(node){// We could probably return true here (since every node has a key), but it's never called\n// so just leaving unimplemented for now.\nthrow (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('KeyIndex.isDefinedOn not expected to be called.');}indexedValueChanged(oldNode,newNode){return false;// The key for a node never changes.\n}minPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nreturn NamedNode.MIN;}maxPost(){// TODO: This should really be created once and cached in a static property, but\n// NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\nreturn new NamedNode(MAX_NAME,__EMPTY_NODE);}makePost(indexValue,name){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof indexValue==='string','KeyIndex indexValue must always be a string.');// We just use empty node, but it'll never be compared, since our comparator only looks at name.\nreturn new NamedNode(indexValue,__EMPTY_NODE);}/**\r\n     * @returns String representation for inclusion in a query spec\r\n     */toString(){return'.key';}}const KEY_INDEX=new KeyIndex();/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An iterator over an LLRBNode.\r\n */class SortedMapIterator{/**\r\n     * @param node - Node to iterate.\r\n     * @param isReverse_ - Whether or not to iterate in reverse\r\n     */constructor(node,startKey,comparator,isReverse_,resultGenerator_=null){this.isReverse_=isReverse_;this.resultGenerator_=resultGenerator_;this.nodeStack_=[];let cmp=1;while(!node.isEmpty()){node=node;cmp=startKey?comparator(node.key,startKey):1;// flip the comparison if we're going in reverse\nif(isReverse_){cmp*=-1;}if(cmp<0){// This node is less than our start key. ignore it\nif(this.isReverse_){node=node.left;}else{node=node.right;}}else if(cmp===0){// This node is exactly equal to our start key. Push it on the stack, but stop iterating;\nthis.nodeStack_.push(node);break;}else{// This node is greater than our start key, add it to the stack and move to the next one\nthis.nodeStack_.push(node);if(this.isReverse_){node=node.right;}else{node=node.left;}}}}getNext(){if(this.nodeStack_.length===0){return null;}let node=this.nodeStack_.pop();let result;if(this.resultGenerator_){result=this.resultGenerator_(node.key,node.value);}else{result={key:node.key,value:node.value};}if(this.isReverse_){node=node.left;while(!node.isEmpty()){this.nodeStack_.push(node);node=node.right;}}else{node=node.right;while(!node.isEmpty()){this.nodeStack_.push(node);node=node.left;}}return result;}hasNext(){return this.nodeStack_.length>0;}peek(){if(this.nodeStack_.length===0){return null;}const node=this.nodeStack_[this.nodeStack_.length-1];if(this.resultGenerator_){return this.resultGenerator_(node.key,node.value);}else{return{key:node.key,value:node.value};}}}/**\r\n * Represents a node in a Left-leaning Red-Black tree.\r\n */class LLRBNode{/**\r\n     * @param key - Key associated with this node.\r\n     * @param value - Value associated with this node.\r\n     * @param color - Whether this node is red.\r\n     * @param left - Left child.\r\n     * @param right - Right child.\r\n     */constructor(key,value,color,left,right){this.key=key;this.value=value;this.color=color!=null?color:LLRBNode.RED;this.left=left!=null?left:SortedMap.EMPTY_NODE;this.right=right!=null?right:SortedMap.EMPTY_NODE;}/**\r\n     * Returns a copy of the current node, optionally replacing pieces of it.\r\n     *\r\n     * @param key - New key for the node, or null.\r\n     * @param value - New value for the node, or null.\r\n     * @param color - New color for the node, or null.\r\n     * @param left - New left child for the node, or null.\r\n     * @param right - New right child for the node, or null.\r\n     * @returns The node copy.\r\n     */copy(key,value,color,left,right){return new LLRBNode(key!=null?key:this.key,value!=null?value:this.value,color!=null?color:this.color,left!=null?left:this.left,right!=null?right:this.right);}/**\r\n     * @returns The total number of nodes in the tree.\r\n     */count(){return this.left.count()+1+this.right.count();}/**\r\n     * @returns True if the tree is empty.\r\n     */isEmpty(){return false;}/**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     *   node.  If it returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */inorderTraversal(action){return this.left.inorderTraversal(action)||!!action(this.key,this.value)||this.right.inorderTraversal(action);}/**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */reverseTraversal(action){return this.right.reverseTraversal(action)||action(this.key,this.value)||this.left.reverseTraversal(action);}/**\r\n     * @returns The minimum node in the tree.\r\n     */min_(){if(this.left.isEmpty()){return this;}else{return this.left.min_();}}/**\r\n     * @returns The maximum key in the tree.\r\n     */minKey(){return this.min_().key;}/**\r\n     * @returns The maximum key in the tree.\r\n     */maxKey(){if(this.right.isEmpty()){return this.key;}else{return this.right.maxKey();}}/**\r\n     * @param key - Key to insert.\r\n     * @param value - Value to insert.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the key/value added.\r\n     */insert(key,value,comparator){let n=this;const cmp=comparator(key,n.key);if(cmp<0){n=n.copy(null,null,null,n.left.insert(key,value,comparator),null);}else if(cmp===0){n=n.copy(null,value,null,null,null);}else{n=n.copy(null,null,null,null,n.right.insert(key,value,comparator));}return n.fixUp_();}/**\r\n     * @returns New tree, with the minimum key removed.\r\n     */removeMin_(){if(this.left.isEmpty()){return SortedMap.EMPTY_NODE;}let n=this;if(!n.left.isRed_()&&!n.left.left.isRed_()){n=n.moveRedLeft_();}n=n.copy(null,null,null,n.left.removeMin_(),null);return n.fixUp_();}/**\r\n     * @param key - The key of the item to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the specified item removed.\r\n     */remove(key,comparator){let n,smallest;n=this;if(comparator(key,n.key)<0){if(!n.left.isEmpty()&&!n.left.isRed_()&&!n.left.left.isRed_()){n=n.moveRedLeft_();}n=n.copy(null,null,null,n.left.remove(key,comparator),null);}else{if(n.left.isRed_()){n=n.rotateRight_();}if(!n.right.isEmpty()&&!n.right.isRed_()&&!n.right.left.isRed_()){n=n.moveRedRight_();}if(comparator(key,n.key)===0){if(n.right.isEmpty()){return SortedMap.EMPTY_NODE;}else{smallest=n.right.min_();n=n.copy(smallest.key,smallest.value,null,null,n.right.removeMin_());}}n=n.copy(null,null,null,null,n.right.remove(key,comparator));}return n.fixUp_();}/**\r\n     * @returns Whether this is a RED node.\r\n     */isRed_(){return this.color;}/**\r\n     * @returns New tree after performing any needed rotations.\r\n     */fixUp_(){let n=this;if(n.right.isRed_()&&!n.left.isRed_()){n=n.rotateLeft_();}if(n.left.isRed_()&&n.left.left.isRed_()){n=n.rotateRight_();}if(n.left.isRed_()&&n.right.isRed_()){n=n.colorFlip_();}return n;}/**\r\n     * @returns New tree, after moveRedLeft.\r\n     */moveRedLeft_(){let n=this.colorFlip_();if(n.right.left.isRed_()){n=n.copy(null,null,null,null,n.right.rotateRight_());n=n.rotateLeft_();n=n.colorFlip_();}return n;}/**\r\n     * @returns New tree, after moveRedRight.\r\n     */moveRedRight_(){let n=this.colorFlip_();if(n.left.left.isRed_()){n=n.rotateRight_();n=n.colorFlip_();}return n;}/**\r\n     * @returns New tree, after rotateLeft.\r\n     */rotateLeft_(){const nl=this.copy(null,null,LLRBNode.RED,null,this.right.left);return this.right.copy(null,null,this.color,nl,null);}/**\r\n     * @returns New tree, after rotateRight.\r\n     */rotateRight_(){const nr=this.copy(null,null,LLRBNode.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,nr);}/**\r\n     * @returns Newt ree, after colorFlip.\r\n     */colorFlip_(){const left=this.left.copy(null,null,!this.left.color,null,null);const right=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,left,right);}/**\r\n     * For testing.\r\n     *\r\n     * @returns True if all is well.\r\n     */checkMaxDepth_(){const blackDepth=this.check_();return Math.pow(2.0,blackDepth)<=this.count()+1;}check_(){if(this.isRed_()&&this.left.isRed_()){throw new Error('Red node has red child('+this.key+','+this.value+')');}if(this.right.isRed_()){throw new Error('Right child of ('+this.key+','+this.value+') is red');}const blackDepth=this.left.check_();if(blackDepth!==this.right.check_()){throw new Error('Black depths differ');}else{return blackDepth+(this.isRed_()?0:1);}}}LLRBNode.RED=true;LLRBNode.BLACK=false;/**\r\n * Represents an empty node (a leaf node in the Red-Black Tree).\r\n */class LLRBEmptyNode{/**\r\n     * Returns a copy of the current node.\r\n     *\r\n     * @returns The node copy.\r\n     */copy(key,value,color,left,right){return this;}/**\r\n     * Returns a copy of the tree, with the specified key/value added.\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item added.\r\n     */insert(key,value,comparator){return new LLRBNode(key,value,null);}/**\r\n     * Returns a copy of the tree, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item removed.\r\n     */remove(key,comparator){return this;}/**\r\n     * @returns The total number of nodes in the tree.\r\n     */count(){return 0;}/**\r\n     * @returns True if the tree is empty.\r\n     */isEmpty(){return true;}/**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */inorderTraversal(action){return false;}/**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */reverseTraversal(action){return false;}minKey(){return null;}maxKey(){return null;}check_(){return 0;}/**\r\n     * @returns Whether this node is red.\r\n     */isRed_(){return false;}}/**\r\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n * tree.\r\n */class SortedMap{/**\r\n     * @param comparator_ - Key comparator.\r\n     * @param root_ - Optional root node for the map.\r\n     */constructor(comparator_,root_=SortedMap.EMPTY_NODE){this.comparator_=comparator_;this.root_=root_;}/**\r\n     * Returns a copy of the map, with the specified key/value added or replaced.\r\n     * (TODO: We should perhaps rename this method to 'put')\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @returns New map, with item added.\r\n     */insert(key,value){return new SortedMap(this.comparator_,this.root_.insert(key,value,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null));}/**\r\n     * Returns a copy of the map, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @returns New map, with item removed.\r\n     */remove(key){return new SortedMap(this.comparator_,this.root_.remove(key,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null));}/**\r\n     * Returns the value of the node with the given key, or null.\r\n     *\r\n     * @param key - The key to look up.\r\n     * @returns The value of the node with the given key, or null if the\r\n     * key doesn't exist.\r\n     */get(key){let cmp;let node=this.root_;while(!node.isEmpty()){cmp=this.comparator_(key,node.key);if(cmp===0){return node.value;}else if(cmp<0){node=node.left;}else if(cmp>0){node=node.right;}}return null;}/**\r\n     * Returns the key of the item *before* the specified key, or null if key is the first item.\r\n     * @param key - The key to find the predecessor of\r\n     * @returns The predecessor key.\r\n     */getPredecessorKey(key){let cmp,node=this.root_,rightParent=null;while(!node.isEmpty()){cmp=this.comparator_(key,node.key);if(cmp===0){if(!node.left.isEmpty()){node=node.left;while(!node.right.isEmpty()){node=node.right;}return node.key;}else if(rightParent){return rightParent.key;}else{return null;// first item.\n}}else if(cmp<0){node=node.left;}else if(cmp>0){rightParent=node;node=node.right;}}throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');}/**\r\n     * @returns True if the map is empty.\r\n     */isEmpty(){return this.root_.isEmpty();}/**\r\n     * @returns The total number of nodes in the map.\r\n     */count(){return this.root_.count();}/**\r\n     * @returns The minimum key in the map.\r\n     */minKey(){return this.root_.minKey();}/**\r\n     * @returns The maximum key in the map.\r\n     */maxKey(){return this.root_.maxKey();}/**\r\n     * Traverses the map in key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */inorderTraversal(action){return this.root_.inorderTraversal(action);}/**\r\n     * Traverses the map in reverse key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns True if the traversal was aborted.\r\n     */reverseTraversal(action){return this.root_.reverseTraversal(action);}/**\r\n     * Returns an iterator over the SortedMap.\r\n     * @returns The iterator.\r\n     */getIterator(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,false,resultGenerator);}getIteratorFrom(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,false,resultGenerator);}getReverseIteratorFrom(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,true,resultGenerator);}getReverseIterator(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,true,resultGenerator);}}/**\r\n * Always use the same empty node, to reduce memory.\r\n */SortedMap.EMPTY_NODE=new LLRBEmptyNode();/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */function NAME_ONLY_COMPARATOR(left,right){return nameCompare(left.name,right.name);}function NAME_COMPARATOR(left,right){return nameCompare(left,right);}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */let MAX_NODE$2;function setMaxNode$1(val){MAX_NODE$2=val;}const priorityHashText=function(priority){if(typeof priority==='number'){return'number:'+doubleToIEEE754String(priority);}else{return'string:'+priority;}};/**\r\n * Validates that a priority snapshot Node is valid.\r\n */const validatePriorityNode=function(priorityNode){if(priorityNode.isLeafNode()){const val=priorityNode.val();(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof val==='string'||typeof val==='number'||typeof val==='object'&&(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(val,'.sv'),'Priority must be a string or number.');}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priorityNode===MAX_NODE$2||priorityNode.isEmpty(),'priority of unexpected type.');}// Don't call getPriority() on MAX_NODE to avoid hitting assertion.\n(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priorityNode===MAX_NODE$2||priorityNode.getPriority().isEmpty(),\"Priority nodes can't have a priority of their own.\");};/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */let __childrenNodeConstructor;/**\r\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\r\n * implements Node and stores the value of the node (a string,\r\n * number, or boolean) accessible via getValue().\r\n */class LeafNode{/**\r\n     * @param value_ - The value to store in this leaf node. The object type is\r\n     * possible in the event of a deferred value\r\n     * @param priorityNode_ - The priority of this node.\r\n     */constructor(value_,priorityNode_=LeafNode.__childrenNodeConstructor.EMPTY_NODE){this.value_=value_;this.priorityNode_=priorityNode_;this.lazyHash_=null;(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.value_!==undefined&&this.value_!==null,\"LeafNode shouldn't be created with null/undefined value.\");validatePriorityNode(this.priorityNode_);}static set __childrenNodeConstructor(val){__childrenNodeConstructor=val;}static get __childrenNodeConstructor(){return __childrenNodeConstructor;}/** @inheritDoc */isLeafNode(){return true;}/** @inheritDoc */getPriority(){return this.priorityNode_;}/** @inheritDoc */updatePriority(newPriorityNode){return new LeafNode(this.value_,newPriorityNode);}/** @inheritDoc */getImmediateChild(childName){// Hack to treat priority as a regular child\nif(childName==='.priority'){return this.priorityNode_;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE;}}/** @inheritDoc */getChild(path){if(pathIsEmpty(path)){return this;}else if(pathGetFront(path)==='.priority'){return this.priorityNode_;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE;}}hasChild(){return false;}/** @inheritDoc */getPredecessorChildName(childName,childNode){return null;}/** @inheritDoc */updateImmediateChild(childName,newChildNode){if(childName==='.priority'){return this.updatePriority(newChildNode);}else if(newChildNode.isEmpty()&&childName!=='.priority'){return this;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName,newChildNode).updatePriority(this.priorityNode_);}}/** @inheritDoc */updateChild(path,newChildNode){const front=pathGetFront(path);if(front===null){return newChildNode;}else if(newChildNode.isEmpty()&&front!=='.priority'){return this;}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(front!=='.priority'||pathGetLength(path)===1,'.priority must be the last token in a path');return this.updateImmediateChild(front,LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path),newChildNode));}}/** @inheritDoc */isEmpty(){return false;}/** @inheritDoc */numChildren(){return 0;}/** @inheritDoc */forEachChild(index,action){return false;}val(exportFormat){if(exportFormat&&!this.getPriority().isEmpty()){return{'.value':this.getValue(),'.priority':this.getPriority().val()};}else{return this.getValue();}}/** @inheritDoc */hash(){if(this.lazyHash_===null){let toHash='';if(!this.priorityNode_.isEmpty()){toHash+='priority:'+priorityHashText(this.priorityNode_.val())+':';}const type=typeof this.value_;toHash+=type+':';if(type==='number'){toHash+=doubleToIEEE754String(this.value_);}else{toHash+=this.value_;}this.lazyHash_=sha1(toHash);}return this.lazyHash_;}/**\r\n     * Returns the value of the leaf node.\r\n     * @returns The value of the node.\r\n     */getValue(){return this.value_;}compareTo(other){if(other===LeafNode.__childrenNodeConstructor.EMPTY_NODE){return 1;}else if(other instanceof LeafNode.__childrenNodeConstructor){return-1;}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(other.isLeafNode(),'Unknown node type');return this.compareToLeafNode_(other);}}/**\r\n     * Comparison specifically for two leaf nodes\r\n     */compareToLeafNode_(otherLeaf){const otherLeafType=typeof otherLeaf.value_;const thisLeafType=typeof this.value_;const otherIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);const thisIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(otherIndex>=0,'Unknown leaf type: '+otherLeafType);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(thisIndex>=0,'Unknown leaf type: '+thisLeafType);if(otherIndex===thisIndex){// Same type, compare values\nif(thisLeafType==='object'){// Deferred value nodes are all equal, but we should also never get to this point...\nreturn 0;}else{// Note that this works because true > false, all others are number or string comparisons\nif(this.value_<otherLeaf.value_){return-1;}else if(this.value_===otherLeaf.value_){return 0;}else{return 1;}}}else{return thisIndex-otherIndex;}}withIndex(){return this;}isIndexed(){return true;}equals(other){if(other===this){return true;}else if(other.isLeafNode()){const otherLeaf=other;return this.value_===otherLeaf.value_&&this.priorityNode_.equals(otherLeaf.priorityNode_);}else{return false;}}}/**\r\n * The sort order for comparing leaf nodes of different types. If two leaf nodes have\r\n * the same type, the comparison falls back to their value\r\n */LeafNode.VALUE_TYPE_ORDER=['object','boolean','number','string'];/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */let nodeFromJSON$1;let MAX_NODE$1;function setNodeFromJSON(val){nodeFromJSON$1=val;}function setMaxNode(val){MAX_NODE$1=val;}class PriorityIndex extends Index{compare(a,b){const aPriority=a.node.getPriority();const bPriority=b.node.getPriority();const indexCmp=aPriority.compareTo(bPriority);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}}isDefinedOn(node){return!node.getPriority().isEmpty();}indexedValueChanged(oldNode,newNode){return!oldNode.getPriority().equals(newNode.getPriority());}minPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nreturn NamedNode.MIN;}maxPost(){return new NamedNode(MAX_NAME,new LeafNode('[PRIORITY-POST]',MAX_NODE$1));}makePost(indexValue,name){const priorityNode=nodeFromJSON$1(indexValue);return new NamedNode(name,new LeafNode('[PRIORITY-POST]',priorityNode));}/**\r\n     * @returns String representation for inclusion in a query spec\r\n     */toString(){return'.priority';}}const PRIORITY_INDEX=new PriorityIndex();/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const LOG_2=Math.log(2);class Base12Num{constructor(length){const logBase2=num=>// eslint-disable-next-line @typescript-eslint/no-explicit-any\nparseInt(Math.log(num)/LOG_2,10);const bitMask=bits=>parseInt(Array(bits+1).join('1'),2);this.count=logBase2(length+1);this.current_=this.count-1;const mask=bitMask(this.count);this.bits_=length+1&mask;}nextBitIsOne(){//noinspection JSBitwiseOperatorUsage\nconst result=!(this.bits_&0x1<<this.current_);this.current_--;return result;}}/**\r\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\r\n * function\r\n *\r\n * Uses the algorithm described in the paper linked here:\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\r\n *\r\n * @param childList - Unsorted list of children\r\n * @param cmp - The comparison method to be used\r\n * @param keyFn - An optional function to extract K from a node wrapper, if K's\r\n * type is not NamedNode\r\n * @param mapSortFn - An optional override for comparator used by the generated sorted map\r\n */const buildChildSet=function(childList,cmp,keyFn,mapSortFn){childList.sort(cmp);const buildBalancedTree=function(low,high){const length=high-low;let namedNode;let key;if(length===0){return null;}else if(length===1){namedNode=childList[low];key=keyFn?keyFn(namedNode):namedNode;return new LLRBNode(key,namedNode.node,LLRBNode.BLACK,null,null);}else{// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst middle=parseInt(length/2,10)+low;const left=buildBalancedTree(low,middle);const right=buildBalancedTree(middle+1,high);namedNode=childList[middle];key=keyFn?keyFn(namedNode):namedNode;return new LLRBNode(key,namedNode.node,LLRBNode.BLACK,left,right);}};const buildFrom12Array=function(base12){let node=null;let root=null;let index=childList.length;const buildPennant=function(chunkSize,color){const low=index-chunkSize;const high=index;index-=chunkSize;const childTree=buildBalancedTree(low+1,high);const namedNode=childList[low];const key=keyFn?keyFn(namedNode):namedNode;attachPennant(new LLRBNode(key,namedNode.node,color,null,childTree));};const attachPennant=function(pennant){if(node){node.left=pennant;node=pennant;}else{root=pennant;node=pennant;}};for(let i=0;i<base12.count;++i){const isOne=base12.nextBitIsOne();// The number of nodes taken in each slice is 2^(arr.length - (i + 1))\nconst chunkSize=Math.pow(2,base12.count-(i+1));if(isOne){buildPennant(chunkSize,LLRBNode.BLACK);}else{// current == 2\nbuildPennant(chunkSize,LLRBNode.BLACK);buildPennant(chunkSize,LLRBNode.RED);}}return root;};const base12=new Base12Num(childList.length);const root=buildFrom12Array(base12);// eslint-disable-next-line @typescript-eslint/no-explicit-any\nreturn new SortedMap(mapSortFn||cmp,root);};/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */let _defaultIndexMap;const fallbackObject={};class IndexMap{constructor(indexes_,indexSet_){this.indexes_=indexes_;this.indexSet_=indexSet_;}/**\r\n     * The default IndexMap for nodes without a priority\r\n     */static get Default(){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(fallbackObject&&PRIORITY_INDEX,'ChildrenNode.ts has not been loaded');_defaultIndexMap=_defaultIndexMap||new IndexMap({'.priority':fallbackObject},{'.priority':PRIORITY_INDEX});return _defaultIndexMap;}get(indexKey){const sortedMap=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.indexes_,indexKey);if(!sortedMap){throw new Error('No index defined for '+indexKey);}if(sortedMap instanceof SortedMap){return sortedMap;}else{// The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n// regular child map\nreturn null;}}hasIndex(indexDefinition){return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.indexSet_,indexDefinition.toString());}addIndex(indexDefinition,existingChildren){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(indexDefinition!==KEY_INDEX,\"KeyIndex always exists and isn't meant to be added to the IndexMap.\");const childList=[];let sawIndexedValue=false;const iter=existingChildren.getIterator(NamedNode.Wrap);let next=iter.getNext();while(next){sawIndexedValue=sawIndexedValue||indexDefinition.isDefinedOn(next.node);childList.push(next);next=iter.getNext();}let newIndex;if(sawIndexedValue){newIndex=buildChildSet(childList,indexDefinition.getCompare());}else{newIndex=fallbackObject;}const indexName=indexDefinition.toString();const newIndexSet=Object.assign({},this.indexSet_);newIndexSet[indexName]=indexDefinition;const newIndexes=Object.assign({},this.indexes_);newIndexes[indexName]=newIndex;return new IndexMap(newIndexes,newIndexSet);}/**\r\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\r\n     */addToIndexes(namedNode,existingChildren){const newIndexes=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(this.indexes_,(indexedChildren,indexName)=>{const index=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.indexSet_,indexName);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(index,'Missing index implementation for '+indexName);if(indexedChildren===fallbackObject){// Check to see if we need to index everything\nif(index.isDefinedOn(namedNode.node)){// We need to build this index\nconst childList=[];const iter=existingChildren.getIterator(NamedNode.Wrap);let next=iter.getNext();while(next){if(next.name!==namedNode.name){childList.push(next);}next=iter.getNext();}childList.push(namedNode);return buildChildSet(childList,index.getCompare());}else{// No change, this remains a fallback\nreturn fallbackObject;}}else{const existingSnap=existingChildren.get(namedNode.name);let newChildren=indexedChildren;if(existingSnap){newChildren=newChildren.remove(new NamedNode(namedNode.name,existingSnap));}return newChildren.insert(namedNode,namedNode.node);}});return new IndexMap(newIndexes,this.indexSet_);}/**\r\n     * Create a new IndexMap instance with the given value removed\r\n     */removeFromIndexes(namedNode,existingChildren){const newIndexes=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(this.indexes_,indexedChildren=>{if(indexedChildren===fallbackObject){// This is the fallback. Just return it, nothing to do in this case\nreturn indexedChildren;}else{const existingSnap=existingChildren.get(namedNode.name);if(existingSnap){return indexedChildren.remove(new NamedNode(namedNode.name,existingSnap));}else{// No record of this child\nreturn indexedChildren;}}});return new IndexMap(newIndexes,this.indexSet_);}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // TODO: For memory savings, don't store priorityNode_ if it's empty.\nlet EMPTY_NODE;/**\r\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\r\n * (i.e. nodes with children).  It implements Node and stores the\r\n * list of children in the children property, sorted by child name.\r\n */class ChildrenNode{/**\r\n     * @param children_ - List of children of this node..\r\n     * @param priorityNode_ - The priority of this node (as a snapshot node).\r\n     */constructor(children_,priorityNode_,indexMap_){this.children_=children_;this.priorityNode_=priorityNode_;this.indexMap_=indexMap_;this.lazyHash_=null;/**\r\n         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\r\n         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\r\n         * class instead of an empty ChildrenNode.\r\n         */if(this.priorityNode_){validatePriorityNode(this.priorityNode_);}if(this.children_.isEmpty()){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.priorityNode_||this.priorityNode_.isEmpty(),'An empty node cannot have a priority');}}static get EMPTY_NODE(){return EMPTY_NODE||(EMPTY_NODE=new ChildrenNode(new SortedMap(NAME_COMPARATOR),null,IndexMap.Default));}/** @inheritDoc */isLeafNode(){return false;}/** @inheritDoc */getPriority(){return this.priorityNode_||EMPTY_NODE;}/** @inheritDoc */updatePriority(newPriorityNode){if(this.children_.isEmpty()){// Don't allow priorities on empty nodes\nreturn this;}else{return new ChildrenNode(this.children_,newPriorityNode,this.indexMap_);}}/** @inheritDoc */getImmediateChild(childName){// Hack to treat priority as a regular child\nif(childName==='.priority'){return this.getPriority();}else{const child=this.children_.get(childName);return child===null?EMPTY_NODE:child;}}/** @inheritDoc */getChild(path){const front=pathGetFront(path);if(front===null){return this;}return this.getImmediateChild(front).getChild(pathPopFront(path));}/** @inheritDoc */hasChild(childName){return this.children_.get(childName)!==null;}/** @inheritDoc */updateImmediateChild(childName,newChildNode){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(newChildNode,'We should always be passing snapshot nodes');if(childName==='.priority'){return this.updatePriority(newChildNode);}else{const namedNode=new NamedNode(childName,newChildNode);let newChildren,newIndexMap;if(newChildNode.isEmpty()){newChildren=this.children_.remove(childName);newIndexMap=this.indexMap_.removeFromIndexes(namedNode,this.children_);}else{newChildren=this.children_.insert(childName,newChildNode);newIndexMap=this.indexMap_.addToIndexes(namedNode,this.children_);}const newPriority=newChildren.isEmpty()?EMPTY_NODE:this.priorityNode_;return new ChildrenNode(newChildren,newPriority,newIndexMap);}}/** @inheritDoc */updateChild(path,newChildNode){const front=pathGetFront(path);if(front===null){return newChildNode;}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(path)!=='.priority'||pathGetLength(path)===1,'.priority must be the last token in a path');const newImmediateChild=this.getImmediateChild(front).updateChild(pathPopFront(path),newChildNode);return this.updateImmediateChild(front,newImmediateChild);}}/** @inheritDoc */isEmpty(){return this.children_.isEmpty();}/** @inheritDoc */numChildren(){return this.children_.count();}/** @inheritDoc */val(exportFormat){if(this.isEmpty()){return null;}const obj={};let numKeys=0,maxKey=0,allIntegerKeys=true;this.forEachChild(PRIORITY_INDEX,(key,childNode)=>{obj[key]=childNode.val(exportFormat);numKeys++;if(allIntegerKeys&&ChildrenNode.INTEGER_REGEXP_.test(key)){maxKey=Math.max(maxKey,Number(key));}else{allIntegerKeys=false;}});if(!exportFormat&&allIntegerKeys&&maxKey<2*numKeys){// convert to array.\nconst array=[];// eslint-disable-next-line guard-for-in\nfor(const key in obj){array[key]=obj[key];}return array;}else{if(exportFormat&&!this.getPriority().isEmpty()){obj['.priority']=this.getPriority().val();}return obj;}}/** @inheritDoc */hash(){if(this.lazyHash_===null){let toHash='';if(!this.getPriority().isEmpty()){toHash+='priority:'+priorityHashText(this.getPriority().val())+':';}this.forEachChild(PRIORITY_INDEX,(key,childNode)=>{const childHash=childNode.hash();if(childHash!==''){toHash+=':'+key+':'+childHash;}});this.lazyHash_=toHash===''?'':sha1(toHash);}return this.lazyHash_;}/** @inheritDoc */getPredecessorChildName(childName,childNode,index){const idx=this.resolveIndex_(index);if(idx){const predecessor=idx.getPredecessorKey(new NamedNode(childName,childNode));return predecessor?predecessor.name:null;}else{return this.children_.getPredecessorKey(childName);}}getFirstChildName(indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){const minKey=idx.minKey();return minKey&&minKey.name;}else{return this.children_.minKey();}}getFirstChild(indexDefinition){const minKey=this.getFirstChildName(indexDefinition);if(minKey){return new NamedNode(minKey,this.children_.get(minKey));}else{return null;}}/**\r\n     * Given an index, return the key name of the largest value we have, according to that index\r\n     */getLastChildName(indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){const maxKey=idx.maxKey();return maxKey&&maxKey.name;}else{return this.children_.maxKey();}}getLastChild(indexDefinition){const maxKey=this.getLastChildName(indexDefinition);if(maxKey){return new NamedNode(maxKey,this.children_.get(maxKey));}else{return null;}}forEachChild(index,action){const idx=this.resolveIndex_(index);if(idx){return idx.inorderTraversal(wrappedNode=>{return action(wrappedNode.name,wrappedNode.node);});}else{return this.children_.inorderTraversal(action);}}getIterator(indexDefinition){return this.getIteratorFrom(indexDefinition.minPost(),indexDefinition);}getIteratorFrom(startPost,indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){return idx.getIteratorFrom(startPost,key=>key);}else{const iterator=this.children_.getIteratorFrom(startPost.name,NamedNode.Wrap);let next=iterator.peek();while(next!=null&&indexDefinition.compare(next,startPost)<0){iterator.getNext();next=iterator.peek();}return iterator;}}getReverseIterator(indexDefinition){return this.getReverseIteratorFrom(indexDefinition.maxPost(),indexDefinition);}getReverseIteratorFrom(endPost,indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){return idx.getReverseIteratorFrom(endPost,key=>{return key;});}else{const iterator=this.children_.getReverseIteratorFrom(endPost.name,NamedNode.Wrap);let next=iterator.peek();while(next!=null&&indexDefinition.compare(next,endPost)>0){iterator.getNext();next=iterator.peek();}return iterator;}}compareTo(other){if(this.isEmpty()){if(other.isEmpty()){return 0;}else{return-1;}}else if(other.isLeafNode()||other.isEmpty()){return 1;}else if(other===MAX_NODE){return-1;}else{// Must be another node with children.\nreturn 0;}}withIndex(indexDefinition){if(indexDefinition===KEY_INDEX||this.indexMap_.hasIndex(indexDefinition)){return this;}else{const newIndexMap=this.indexMap_.addIndex(indexDefinition,this.children_);return new ChildrenNode(this.children_,this.priorityNode_,newIndexMap);}}isIndexed(index){return index===KEY_INDEX||this.indexMap_.hasIndex(index);}equals(other){if(other===this){return true;}else if(other.isLeafNode()){return false;}else{const otherChildrenNode=other;if(!this.getPriority().equals(otherChildrenNode.getPriority())){return false;}else if(this.children_.count()===otherChildrenNode.children_.count()){const thisIter=this.getIterator(PRIORITY_INDEX);const otherIter=otherChildrenNode.getIterator(PRIORITY_INDEX);let thisCurrent=thisIter.getNext();let otherCurrent=otherIter.getNext();while(thisCurrent&&otherCurrent){if(thisCurrent.name!==otherCurrent.name||!thisCurrent.node.equals(otherCurrent.node)){return false;}thisCurrent=thisIter.getNext();otherCurrent=otherIter.getNext();}return thisCurrent===null&&otherCurrent===null;}else{return false;}}}/**\r\n     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\r\n     * instead.\r\n     *\r\n     */resolveIndex_(indexDefinition){if(indexDefinition===KEY_INDEX){return null;}else{return this.indexMap_.get(indexDefinition.toString());}}}ChildrenNode.INTEGER_REGEXP_=/^(0|[1-9]\\d*)$/;class MaxNode extends ChildrenNode{constructor(){super(new SortedMap(NAME_COMPARATOR),ChildrenNode.EMPTY_NODE,IndexMap.Default);}compareTo(other){if(other===this){return 0;}else{return 1;}}equals(other){// Not that we every compare it, but MAX_NODE is only ever equal to itself\nreturn other===this;}getPriority(){return this;}getImmediateChild(childName){return ChildrenNode.EMPTY_NODE;}isEmpty(){return false;}}/**\r\n * Marker that will sort higher than any other snapshot.\r\n */const MAX_NODE=new MaxNode();Object.defineProperties(NamedNode,{MIN:{value:new NamedNode(MIN_NAME,ChildrenNode.EMPTY_NODE)},MAX:{value:new NamedNode(MAX_NAME,MAX_NODE)}});/**\r\n * Reference Extensions\r\n */KeyIndex.__EMPTY_NODE=ChildrenNode.EMPTY_NODE;LeafNode.__childrenNodeConstructor=ChildrenNode;setMaxNode$1(MAX_NODE);setMaxNode(MAX_NODE);/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const USE_HINZE=true;/**\r\n * Constructs a snapshot node representing the passed JSON and returns it.\r\n * @param json - JSON to create a node for.\r\n * @param priority - Optional priority to use.  This will be ignored if the\r\n * passed JSON contains a .priority property.\r\n */function nodeFromJSON(json,priority=null){if(json===null){return ChildrenNode.EMPTY_NODE;}if(typeof json==='object'&&'.priority'in json){priority=json['.priority'];}(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priority===null||typeof priority==='string'||typeof priority==='number'||typeof priority==='object'&&'.sv'in priority,'Invalid priority type found: '+typeof priority);if(typeof json==='object'&&'.value'in json&&json['.value']!==null){json=json['.value'];}// Valid leaf nodes include non-objects or server-value wrapper objects\nif(typeof json!=='object'||'.sv'in json){const jsonLeaf=json;return new LeafNode(jsonLeaf,nodeFromJSON(priority));}if(!(json instanceof Array)&&USE_HINZE){const children=[];let childrenHavePriority=false;const hinzeJsonObj=json;each(hinzeJsonObj,(key,child)=>{if(key.substring(0,1)!=='.'){// Ignore metadata nodes\nconst childNode=nodeFromJSON(child);if(!childNode.isEmpty()){childrenHavePriority=childrenHavePriority||!childNode.getPriority().isEmpty();children.push(new NamedNode(key,childNode));}}});if(children.length===0){return ChildrenNode.EMPTY_NODE;}const childSet=buildChildSet(children,NAME_ONLY_COMPARATOR,namedNode=>namedNode.name,NAME_COMPARATOR);if(childrenHavePriority){const sortedChildSet=buildChildSet(children,PRIORITY_INDEX.getCompare());return new ChildrenNode(childSet,nodeFromJSON(priority),new IndexMap({'.priority':sortedChildSet},{'.priority':PRIORITY_INDEX}));}else{return new ChildrenNode(childSet,nodeFromJSON(priority),IndexMap.Default);}}else{let node=ChildrenNode.EMPTY_NODE;each(json,(key,childData)=>{if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(json,key)){if(key.substring(0,1)!=='.'){// ignore metadata nodes.\nconst childNode=nodeFromJSON(childData);if(childNode.isLeafNode()||!childNode.isEmpty()){node=node.updateImmediateChild(key,childNode);}}}});return node.updatePriority(nodeFromJSON(priority));}}setNodeFromJSON(nodeFromJSON);/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class PathIndex extends Index{constructor(indexPath_){super();this.indexPath_=indexPath_;(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!pathIsEmpty(indexPath_)&&pathGetFront(indexPath_)!=='.priority',\"Can't create PathIndex with empty path or .priority key\");}extractChild(snap){return snap.getChild(this.indexPath_);}isDefinedOn(node){return!node.getChild(this.indexPath_).isEmpty();}compare(a,b){const aChild=this.extractChild(a.node);const bChild=this.extractChild(b.node);const indexCmp=aChild.compareTo(bChild);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}}makePost(indexValue,name){const valueNode=nodeFromJSON(indexValue);const node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,valueNode);return new NamedNode(name,node);}maxPost(){const node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,MAX_NODE);return new NamedNode(MAX_NAME,node);}toString(){return pathSlice(this.indexPath_,0).join('/');}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class ValueIndex extends Index{compare(a,b){const indexCmp=a.node.compareTo(b.node);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}}isDefinedOn(node){return true;}indexedValueChanged(oldNode,newNode){return!oldNode.equals(newNode);}minPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nreturn NamedNode.MIN;}maxPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any\nreturn NamedNode.MAX;}makePost(indexValue,name){const valueNode=nodeFromJSON(indexValue);return new NamedNode(name,valueNode);}/**\r\n     * @returns String representation for inclusion in a query spec\r\n     */toString(){return'.value';}}const VALUE_INDEX=new ValueIndex();/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Modeled after base64 web-safe chars, but ordered by ASCII.\nconst PUSH_CHARS='-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';const MIN_PUSH_CHAR='-';const MAX_PUSH_CHAR='z';const MAX_KEY_LEN=786;/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */const nextPushId=function(){// Timestamp of last push, used to prevent local collisions if you push twice\n// in one ms.\nlet lastPushTime=0;// We generate 72-bits of randomness which get turned into 12 characters and\n// appended to the timestamp to prevent collisions with other clients. We\n// store the last characters we generated because in the event of a collision,\n// we'll use those same characters except \"incremented\" by one.\nconst lastRandChars=[];return function(now){const duplicateTime=now===lastPushTime;lastPushTime=now;let i;const timeStampChars=new Array(8);for(i=7;i>=0;i--){timeStampChars[i]=PUSH_CHARS.charAt(now%64);// NOTE: Can't use << here because javascript will convert to int and lose\n// the upper bits.\nnow=Math.floor(now/64);}(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(now===0,'Cannot push at time == 0');let id=timeStampChars.join('');if(!duplicateTime){for(i=0;i<12;i++){lastRandChars[i]=Math.floor(Math.random()*64);}}else{// If the timestamp hasn't changed since last push, use the same random\n// number, except incremented by 1.\nfor(i=11;i>=0&&lastRandChars[i]===63;i--){lastRandChars[i]=0;}lastRandChars[i]++;}for(i=0;i<12;i++){id+=PUSH_CHARS.charAt(lastRandChars[i]);}(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(id.length===20,'nextPushId: Length should be 20.');return id;};}();const successor=function(key){if(key===''+INTEGER_32_MAX){// See https://firebase.google.com/docs/database/web/lists-of-data#data-order\nreturn MIN_PUSH_CHAR;}const keyAsInt=tryParseInt(key);if(keyAsInt!=null){return''+(keyAsInt+1);}const next=new Array(key.length);for(let i=0;i<next.length;i++){next[i]=key.charAt(i);}if(next.length<MAX_KEY_LEN){next.push(MIN_PUSH_CHAR);return next.join('');}let i=next.length-1;while(i>=0&&next[i]===MAX_PUSH_CHAR){i--;}// `successor` was called on the largest possible key, so return the\n// MAX_NAME, which sorts larger than all keys.\nif(i===-1){return MAX_NAME;}const source=next[i];const sourcePlusOne=PUSH_CHARS.charAt(PUSH_CHARS.indexOf(source)+1);next[i]=sourcePlusOne;return next.slice(0,i+1).join('');};// `key` is assumed to be non-empty.\nconst predecessor=function(key){if(key===''+INTEGER_32_MIN){return MIN_NAME;}const keyAsInt=tryParseInt(key);if(keyAsInt!=null){return''+(keyAsInt-1);}const next=new Array(key.length);for(let i=0;i<next.length;i++){next[i]=key.charAt(i);}// If `key` ends in `MIN_PUSH_CHAR`, the largest key lexicographically\n// smaller than `key`, is `key[0:key.length - 1]`. The next key smaller\n// than that, `predecessor(predecessor(key))`, is\n//\n// `key[0:key.length - 2] + (key[key.length - 1] - 1) + \\\n//   { MAX_PUSH_CHAR repeated MAX_KEY_LEN - (key.length - 1) times }\n//\n// analogous to increment/decrement for base-10 integers.\n//\n// This works because lexigographic comparison works character-by-character,\n// using length as a tie-breaker if one key is a prefix of the other.\nif(next[next.length-1]===MIN_PUSH_CHAR){if(next.length===1){// See https://firebase.google.com/docs/database/web/lists-of-data#orderbykey\nreturn''+INTEGER_32_MAX;}delete next[next.length-1];return next.join('');}// Replace the last character with it's immediate predecessor, and\n// fill the suffix of the key with MAX_PUSH_CHAR. This is the\n// lexicographically largest possible key smaller than `key`.\nnext[next.length-1]=PUSH_CHARS.charAt(PUSH_CHARS.indexOf(next[next.length-1])-1);return next.join('')+MAX_PUSH_CHAR.repeat(MAX_KEY_LEN-next.length);};/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */function changeValue(snapshotNode){return{type:\"value\"/* VALUE */,snapshotNode};}function changeChildAdded(childName,snapshotNode){return{type:\"child_added\"/* CHILD_ADDED */,snapshotNode,childName};}function changeChildRemoved(childName,snapshotNode){return{type:\"child_removed\"/* CHILD_REMOVED */,snapshotNode,childName};}function changeChildChanged(childName,snapshotNode,oldSnap){return{type:\"child_changed\"/* CHILD_CHANGED */,snapshotNode,childName,oldSnap};}function changeChildMoved(childName,snapshotNode){return{type:\"child_moved\"/* CHILD_MOVED */,snapshotNode,childName};}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\r\n */class IndexedFilter{constructor(index_){this.index_=index_;}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(snap.isIndexed(this.index_),'A node must be indexed if only a child is updated');const oldChild=snap.getImmediateChild(key);// Check if anything actually changed.\nif(oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))){// There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n// In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n// to avoid treating these cases as \"nothing changed.\"\nif(oldChild.isEmpty()===newChild.isEmpty()){// Nothing changed.\n// This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n//assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\nreturn snap;}}if(optChangeAccumulator!=null){if(newChild.isEmpty()){if(snap.hasChild(key)){optChangeAccumulator.trackChildChange(changeChildRemoved(key,oldChild));}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(snap.isLeafNode(),'A child remove without an old child only makes sense on a leaf node');}}else if(oldChild.isEmpty()){optChangeAccumulator.trackChildChange(changeChildAdded(key,newChild));}else{optChangeAccumulator.trackChildChange(changeChildChanged(key,newChild,oldChild));}}if(snap.isLeafNode()&&newChild.isEmpty()){return snap;}else{// Make sure the node is indexed\nreturn snap.updateImmediateChild(key,newChild).withIndex(this.index_);}}updateFullNode(oldSnap,newSnap,optChangeAccumulator){if(optChangeAccumulator!=null){if(!oldSnap.isLeafNode()){oldSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{if(!newSnap.hasChild(key)){optChangeAccumulator.trackChildChange(changeChildRemoved(key,childNode));}});}if(!newSnap.isLeafNode()){newSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{if(oldSnap.hasChild(key)){const oldChild=oldSnap.getImmediateChild(key);if(!oldChild.equals(childNode)){optChangeAccumulator.trackChildChange(changeChildChanged(key,childNode,oldChild));}}else{optChangeAccumulator.trackChildChange(changeChildAdded(key,childNode));}});}}return newSnap.withIndex(this.index_);}updatePriority(oldSnap,newPriority){if(oldSnap.isEmpty()){return ChildrenNode.EMPTY_NODE;}else{return oldSnap.updatePriority(newPriority);}}filtersNodes(){return false;}getIndexedFilter(){return this;}getIndex(){return this.index_;}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\r\n */class RangedFilter{constructor(params){this.indexedFilter_=new IndexedFilter(params.getIndex());this.index_=params.getIndex();this.startPost_=RangedFilter.getStartPost_(params);this.endPost_=RangedFilter.getEndPost_(params);}getStartPost(){return this.startPost_;}getEndPost(){return this.endPost_;}matches(node){return this.index_.compare(this.getStartPost(),node)<=0&&this.index_.compare(node,this.getEndPost())<=0;}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){if(!this.matches(new NamedNode(key,newChild))){newChild=ChildrenNode.EMPTY_NODE;}return this.indexedFilter_.updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator);}updateFullNode(oldSnap,newSnap,optChangeAccumulator){if(newSnap.isLeafNode()){// Make sure we have a children node with the correct index, not a leaf node;\nnewSnap=ChildrenNode.EMPTY_NODE;}let filtered=newSnap.withIndex(this.index_);// Don't support priorities on queries\nfiltered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);const self=this;newSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{if(!self.matches(new NamedNode(key,childNode))){filtered=filtered.updateImmediateChild(key,ChildrenNode.EMPTY_NODE);}});return this.indexedFilter_.updateFullNode(oldSnap,filtered,optChangeAccumulator);}updatePriority(oldSnap,newPriority){// Don't support priorities on queries\nreturn oldSnap;}filtersNodes(){return true;}getIndexedFilter(){return this.indexedFilter_;}getIndex(){return this.index_;}static getStartPost_(params){if(params.hasStart()){const startName=params.getIndexStartName();return params.getIndex().makePost(params.getIndexStartValue(),startName);}else{return params.getIndex().minPost();}}static getEndPost_(params){if(params.hasEnd()){const endName=params.getIndexEndName();return params.getIndex().makePost(params.getIndexEndValue(),endName);}else{return params.getIndex().maxPost();}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\r\n */class LimitedFilter{constructor(params){this.rangedFilter_=new RangedFilter(params);this.index_=params.getIndex();this.limit_=params.getLimit();this.reverse_=!params.isViewFromLeft();}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){if(!this.rangedFilter_.matches(new NamedNode(key,newChild))){newChild=ChildrenNode.EMPTY_NODE;}if(snap.getImmediateChild(key).equals(newChild)){// No change\nreturn snap;}else if(snap.numChildren()<this.limit_){return this.rangedFilter_.getIndexedFilter().updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator);}else{return this.fullLimitUpdateChild_(snap,key,newChild,source,optChangeAccumulator);}}updateFullNode(oldSnap,newSnap,optChangeAccumulator){let filtered;if(newSnap.isLeafNode()||newSnap.isEmpty()){// Make sure we have a children node with the correct index, not a leaf node;\nfiltered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);}else{if(this.limit_*2<newSnap.numChildren()&&newSnap.isIndexed(this.index_)){// Easier to build up a snapshot, since what we're given has more than twice the elements we want\nfiltered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);// anchor to the startPost, endPost, or last element as appropriate\nlet iterator;if(this.reverse_){iterator=newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(),this.index_);}else{iterator=newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(),this.index_);}let count=0;while(iterator.hasNext()&&count<this.limit_){const next=iterator.getNext();let inRange;if(this.reverse_){inRange=this.index_.compare(this.rangedFilter_.getStartPost(),next)<=0;}else{inRange=this.index_.compare(next,this.rangedFilter_.getEndPost())<=0;}if(inRange){filtered=filtered.updateImmediateChild(next.name,next.node);count++;}else{// if we have reached the end post, we cannot keep adding elemments\nbreak;}}}else{// The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\nfiltered=newSnap.withIndex(this.index_);// Don't support priorities on queries\nfiltered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);let startPost;let endPost;let cmp;let iterator;if(this.reverse_){iterator=filtered.getReverseIterator(this.index_);startPost=this.rangedFilter_.getEndPost();endPost=this.rangedFilter_.getStartPost();const indexCompare=this.index_.getCompare();cmp=(a,b)=>indexCompare(b,a);}else{iterator=filtered.getIterator(this.index_);startPost=this.rangedFilter_.getStartPost();endPost=this.rangedFilter_.getEndPost();cmp=this.index_.getCompare();}let count=0;let foundStartPost=false;while(iterator.hasNext()){const next=iterator.getNext();if(!foundStartPost&&cmp(startPost,next)<=0){// start adding\nfoundStartPost=true;}const inRange=foundStartPost&&count<this.limit_&&cmp(next,endPost)<=0;if(inRange){count++;}else{filtered=filtered.updateImmediateChild(next.name,ChildrenNode.EMPTY_NODE);}}}}return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap,filtered,optChangeAccumulator);}updatePriority(oldSnap,newPriority){// Don't support priorities on queries\nreturn oldSnap;}filtersNodes(){return true;}getIndexedFilter(){return this.rangedFilter_.getIndexedFilter();}getIndex(){return this.index_;}fullLimitUpdateChild_(snap,childKey,childSnap,source,changeAccumulator){// TODO: rename all cache stuff etc to general snap terminology\nlet cmp;if(this.reverse_){const indexCmp=this.index_.getCompare();cmp=(a,b)=>indexCmp(b,a);}else{cmp=this.index_.getCompare();}const oldEventCache=snap;(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(oldEventCache.numChildren()===this.limit_,'');const newChildNamedNode=new NamedNode(childKey,childSnap);const windowBoundary=this.reverse_?oldEventCache.getFirstChild(this.index_):oldEventCache.getLastChild(this.index_);const inRange=this.rangedFilter_.matches(newChildNamedNode);if(oldEventCache.hasChild(childKey)){const oldChildSnap=oldEventCache.getImmediateChild(childKey);let nextChild=source.getChildAfterChild(this.index_,windowBoundary,this.reverse_);while(nextChild!=null&&(nextChild.name===childKey||oldEventCache.hasChild(nextChild.name))){// There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n// been applied to the limited filter yet. Ignore this next child which will be updated later in\n// the limited filter...\nnextChild=source.getChildAfterChild(this.index_,nextChild,this.reverse_);}const compareNext=nextChild==null?1:cmp(nextChild,newChildNamedNode);const remainsInWindow=inRange&&!childSnap.isEmpty()&&compareNext>=0;if(remainsInWindow){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildChanged(childKey,childSnap,oldChildSnap));}return oldEventCache.updateImmediateChild(childKey,childSnap);}else{if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildRemoved(childKey,oldChildSnap));}const newEventCache=oldEventCache.updateImmediateChild(childKey,ChildrenNode.EMPTY_NODE);const nextChildInRange=nextChild!=null&&this.rangedFilter_.matches(nextChild);if(nextChildInRange){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildAdded(nextChild.name,nextChild.node));}return newEventCache.updateImmediateChild(nextChild.name,nextChild.node);}else{return newEventCache;}}}else if(childSnap.isEmpty()){// we're deleting a node, but it was not in the window, so ignore it\nreturn snap;}else if(inRange){if(cmp(windowBoundary,newChildNamedNode)>=0){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name,windowBoundary.node));changeAccumulator.trackChildChange(changeChildAdded(childKey,childSnap));}return oldEventCache.updateImmediateChild(childKey,childSnap).updateImmediateChild(windowBoundary.name,ChildrenNode.EMPTY_NODE);}else{return snap;}}else{return snap;}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a\r\n * range to be returned for a particular location. It is assumed that validation of parameters is done at the\r\n * user-facing API level, so it is not done here.\r\n *\r\n * @internal\r\n */class QueryParams{constructor(){this.limitSet_=false;this.startSet_=false;this.startNameSet_=false;this.startAfterSet_=false;this.endSet_=false;this.endNameSet_=false;this.endBeforeSet_=false;this.limit_=0;this.viewFrom_='';this.indexStartValue_=null;this.indexStartName_='';this.indexEndValue_=null;this.indexEndName_='';this.index_=PRIORITY_INDEX;}hasStart(){return this.startSet_;}hasStartAfter(){return this.startAfterSet_;}hasEndBefore(){return this.endBeforeSet_;}/**\r\n     * @returns True if it would return from left.\r\n     */isViewFromLeft(){if(this.viewFrom_===''){// limit(), rather than limitToFirst or limitToLast was called.\n// This means that only one of startSet_ and endSet_ is true. Use them\n// to calculate which side of the view to anchor to. If neither is set,\n// anchor to the end.\nreturn this.startSet_;}else{return this.viewFrom_===\"l\"/* VIEW_FROM_LEFT */;}}/**\r\n     * Only valid to call if hasStart() returns true\r\n     */getIndexStartValue(){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startSet_,'Only valid if start has been set');return this.indexStartValue_;}/**\r\n     * Only valid to call if hasStart() returns true.\r\n     * Returns the starting key name for the range defined by these query parameters\r\n     */getIndexStartName(){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startSet_,'Only valid if start has been set');if(this.startNameSet_){return this.indexStartName_;}else{return MIN_NAME;}}hasEnd(){return this.endSet_;}/**\r\n     * Only valid to call if hasEnd() returns true.\r\n     */getIndexEndValue(){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.endSet_,'Only valid if end has been set');return this.indexEndValue_;}/**\r\n     * Only valid to call if hasEnd() returns true.\r\n     * Returns the end key name for the range defined by these query parameters\r\n     */getIndexEndName(){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.endSet_,'Only valid if end has been set');if(this.endNameSet_){return this.indexEndName_;}else{return MAX_NAME;}}hasLimit(){return this.limitSet_;}/**\r\n     * @returns True if a limit has been set and it has been explicitly anchored\r\n     */hasAnchoredLimit(){return this.limitSet_&&this.viewFrom_!=='';}/**\r\n     * Only valid to call if hasLimit() returns true\r\n     */getLimit(){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.limitSet_,'Only valid if limit has been set');return this.limit_;}getIndex(){return this.index_;}loadsAllData(){return!(this.startSet_||this.endSet_||this.limitSet_);}isDefault(){return this.loadsAllData()&&this.index_===PRIORITY_INDEX;}copy(){const copy=new QueryParams();copy.limitSet_=this.limitSet_;copy.limit_=this.limit_;copy.startSet_=this.startSet_;copy.indexStartValue_=this.indexStartValue_;copy.startNameSet_=this.startNameSet_;copy.indexStartName_=this.indexStartName_;copy.endSet_=this.endSet_;copy.indexEndValue_=this.indexEndValue_;copy.endNameSet_=this.endNameSet_;copy.indexEndName_=this.indexEndName_;copy.index_=this.index_;copy.viewFrom_=this.viewFrom_;return copy;}}function queryParamsGetNodeFilter(queryParams){if(queryParams.loadsAllData()){return new IndexedFilter(queryParams.getIndex());}else if(queryParams.hasLimit()){return new LimitedFilter(queryParams);}else{return new RangedFilter(queryParams);}}function queryParamsLimitToFirst(queryParams,newLimit){const newParams=queryParams.copy();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_=\"l\"/* VIEW_FROM_LEFT */;return newParams;}function queryParamsLimitToLast(queryParams,newLimit){const newParams=queryParams.copy();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_=\"r\"/* VIEW_FROM_RIGHT */;return newParams;}function queryParamsStartAt(queryParams,indexValue,key){const newParams=queryParams.copy();newParams.startSet_=true;if(indexValue===undefined){indexValue=null;}newParams.indexStartValue_=indexValue;if(key!=null){newParams.startNameSet_=true;newParams.indexStartName_=key;}else{newParams.startNameSet_=false;newParams.indexStartName_='';}return newParams;}function queryParamsStartAfter(queryParams,indexValue,key){let params;if(queryParams.index_===KEY_INDEX){if(typeof indexValue==='string'){indexValue=successor(indexValue);}params=queryParamsStartAt(queryParams,indexValue,key);}else{let childKey;if(key==null){childKey=MAX_NAME;}else{childKey=successor(key);}params=queryParamsStartAt(queryParams,indexValue,childKey);}params.startAfterSet_=true;return params;}function queryParamsEndAt(queryParams,indexValue,key){const newParams=queryParams.copy();newParams.endSet_=true;if(indexValue===undefined){indexValue=null;}newParams.indexEndValue_=indexValue;if(key!==undefined){newParams.endNameSet_=true;newParams.indexEndName_=key;}else{newParams.endNameSet_=false;newParams.indexEndName_='';}return newParams;}function queryParamsEndBefore(queryParams,indexValue,key){let childKey;let params;if(queryParams.index_===KEY_INDEX){if(typeof indexValue==='string'){indexValue=predecessor(indexValue);}params=queryParamsEndAt(queryParams,indexValue,key);}else{if(key==null){childKey=MIN_NAME;}else{childKey=predecessor(key);}params=queryParamsEndAt(queryParams,indexValue,childKey);}params.endBeforeSet_=true;return params;}function queryParamsOrderBy(queryParams,index){const newParams=queryParams.copy();newParams.index_=index;return newParams;}/**\r\n * Returns a set of REST query string parameters representing this query.\r\n *\r\n * @returns query string parameters\r\n */function queryParamsToRestQueryStringParameters(queryParams){const qs={};if(queryParams.isDefault()){return qs;}let orderBy;if(queryParams.index_===PRIORITY_INDEX){orderBy=\"$priority\"/* PRIORITY_INDEX */;}else if(queryParams.index_===VALUE_INDEX){orderBy=\"$value\"/* VALUE_INDEX */;}else if(queryParams.index_===KEY_INDEX){orderBy=\"$key\"/* KEY_INDEX */;}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queryParams.index_ instanceof PathIndex,'Unrecognized index type!');orderBy=queryParams.index_.toString();}qs[\"orderBy\"/* ORDER_BY */]=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(orderBy);if(queryParams.startSet_){qs[\"startAt\"/* START_AT */]=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexStartValue_);if(queryParams.startNameSet_){qs[\"startAt\"/* START_AT */]+=','+(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexStartName_);}}if(queryParams.endSet_){qs[\"endAt\"/* END_AT */]=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexEndValue_);if(queryParams.endNameSet_){qs[\"endAt\"/* END_AT */]+=','+(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexEndName_);}}if(queryParams.limitSet_){if(queryParams.isViewFromLeft()){qs[\"limitToFirst\"/* LIMIT_TO_FIRST */]=queryParams.limit_;}else{qs[\"limitToLast\"/* LIMIT_TO_LAST */]=queryParams.limit_;}}return qs;}function queryParamsGetQueryObject(queryParams){const obj={};if(queryParams.startSet_){obj[\"sp\"/* INDEX_START_VALUE */]=queryParams.indexStartValue_;if(queryParams.startNameSet_){obj[\"sn\"/* INDEX_START_NAME */]=queryParams.indexStartName_;}}if(queryParams.endSet_){obj[\"ep\"/* INDEX_END_VALUE */]=queryParams.indexEndValue_;if(queryParams.endNameSet_){obj[\"en\"/* INDEX_END_NAME */]=queryParams.indexEndName_;}}if(queryParams.limitSet_){obj[\"l\"/* LIMIT */]=queryParams.limit_;let viewFrom=queryParams.viewFrom_;if(viewFrom===''){if(queryParams.isViewFromLeft()){viewFrom=\"l\"/* VIEW_FROM_LEFT */;}else{viewFrom=\"r\"/* VIEW_FROM_RIGHT */;}}obj[\"vf\"/* VIEW_FROM */]=viewFrom;}// For now, priority index is the default, so we only specify if it's some other index\nif(queryParams.index_!==PRIORITY_INDEX){obj[\"i\"/* INDEX */]=queryParams.index_.toString();}return obj;}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An implementation of ServerActions that communicates with the server via REST requests.\r\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\r\n * persistent connection (using WebSockets or long-polling)\r\n */class ReadonlyRestClient extends ServerActions{/**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */constructor(repoInfo_,onDataUpdate_,authTokenProvider_,appCheckTokenProvider_){super();this.repoInfo_=repoInfo_;this.onDataUpdate_=onDataUpdate_;this.authTokenProvider_=authTokenProvider_;this.appCheckTokenProvider_=appCheckTokenProvider_;/** @private {function(...[*])} */this.log_=logWrapper('p:rest:');/**\r\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\r\n         * that's been removed. :-/\r\n         */this.listens_={};}reportStats(stats){throw new Error('Method not implemented.');}static getListenId_(query,tag){if(tag!==undefined){return'tag$'+tag;}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault(),\"should have a tag if it's not a default query.\");return query._path.toString();}}/** @inheritDoc */listen(query,currentHashFn,tag,onComplete){const pathString=query._path.toString();this.log_('Listen called for '+pathString+' '+query._queryIdentifier);// Mark this listener so we can tell if it's removed.\nconst listenId=ReadonlyRestClient.getListenId_(query,tag);const thisListen={};this.listens_[listenId]=thisListen;const queryStringParameters=queryParamsToRestQueryStringParameters(query._queryParams);this.restRequest_(pathString+'.json',queryStringParameters,(error,result)=>{let data=result;if(error===404){data=null;error=null;}if(error===null){this.onDataUpdate_(pathString,data,/*isMerge=*/false,tag);}if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.listens_,listenId)===thisListen){let status;if(!error){status='ok';}else if(error===401){status='permission_denied';}else{status='rest_error:'+error;}onComplete(status,null);}});}/** @inheritDoc */unlisten(query,tag){const listenId=ReadonlyRestClient.getListenId_(query,tag);delete this.listens_[listenId];}get(query){const queryStringParameters=queryParamsToRestQueryStringParameters(query._queryParams);const pathString=query._path.toString();const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();this.restRequest_(pathString+'.json',queryStringParameters,(error,result)=>{let data=result;if(error===404){data=null;error=null;}if(error===null){this.onDataUpdate_(pathString,data,/*isMerge=*/false,/*tag=*/null);deferred.resolve(data);}else{deferred.reject(new Error(data));}});return deferred.promise;}/** @inheritDoc */refreshAuthToken(token){// no-op since we just always call getToken.\n}/**\r\n     * Performs a REST request to the given path, with the provided query string parameters,\r\n     * and any auth credentials we have.\r\n     */restRequest_(pathString,queryStringParameters={},callback){queryStringParameters['format']='export';return Promise.all([this.authTokenProvider_.getToken(/*forceRefresh=*/false),this.appCheckTokenProvider_.getToken(/*forceRefresh=*/false)]).then(([authToken,appCheckToken])=>{if(authToken&&authToken.accessToken){queryStringParameters['auth']=authToken.accessToken;}if(appCheckToken&&appCheckToken.token){queryStringParameters['ac']=appCheckToken.token;}const url=(this.repoInfo_.secure?'https://':'http://')+this.repoInfo_.host+pathString+'?'+'ns='+this.repoInfo_.namespace+(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.querystring)(queryStringParameters);this.log_('Sending REST request for '+url);const xhr=new XMLHttpRequest();xhr.onreadystatechange=()=>{if(callback&&xhr.readyState===4){this.log_('REST Response for '+url+' received. status:',xhr.status,'response:',xhr.responseText);let res=null;if(xhr.status>=200&&xhr.status<300){try{res=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(xhr.responseText);}catch(e){warn('Failed to parse JSON response for '+url+': '+xhr.responseText);}callback(null,res);}else{// 401 and 404 are expected.\nif(xhr.status!==401&&xhr.status!==404){warn('Got unsuccessful REST response for '+url+' Status: '+xhr.status);}callback(xhr.status);}callback=null;}};xhr.open('GET',url,/*asynchronous=*/true);xhr.send();});}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Mutable object which basically just stores a reference to the \"latest\" immutable snapshot.\r\n */class SnapshotHolder{constructor(){this.rootNode_=ChildrenNode.EMPTY_NODE;}getNode(path){return this.rootNode_.getChild(path);}updateSnapshot(path,newSnapshotNode){this.rootNode_=this.rootNode_.updateChild(path,newSnapshotNode);}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */function newSparseSnapshotTree(){return{value:null,children:new Map()};}/**\r\n * Stores the given node at the specified path. If there is already a node\r\n * at a shallower path, it merges the new data into that snapshot node.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @param data - The new data, or null.\r\n */function sparseSnapshotTreeRemember(sparseSnapshotTree,path,data){if(pathIsEmpty(path)){sparseSnapshotTree.value=data;sparseSnapshotTree.children.clear();}else if(sparseSnapshotTree.value!==null){sparseSnapshotTree.value=sparseSnapshotTree.value.updateChild(path,data);}else{const childKey=pathGetFront(path);if(!sparseSnapshotTree.children.has(childKey)){sparseSnapshotTree.children.set(childKey,newSparseSnapshotTree());}const child=sparseSnapshotTree.children.get(childKey);path=pathPopFront(path);sparseSnapshotTreeRemember(child,path,data);}}/**\r\n * Purge the data at path from the cache.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns True if this node should now be removed.\r\n */function sparseSnapshotTreeForget(sparseSnapshotTree,path){if(pathIsEmpty(path)){sparseSnapshotTree.value=null;sparseSnapshotTree.children.clear();return true;}else{if(sparseSnapshotTree.value!==null){if(sparseSnapshotTree.value.isLeafNode()){// We're trying to forget a node that doesn't exist\nreturn false;}else{const value=sparseSnapshotTree.value;sparseSnapshotTree.value=null;value.forEachChild(PRIORITY_INDEX,(key,tree)=>{sparseSnapshotTreeRemember(sparseSnapshotTree,new Path(key),tree);});return sparseSnapshotTreeForget(sparseSnapshotTree,path);}}else if(sparseSnapshotTree.children.size>0){const childKey=pathGetFront(path);path=pathPopFront(path);if(sparseSnapshotTree.children.has(childKey)){const safeToRemove=sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey),path);if(safeToRemove){sparseSnapshotTree.children.delete(childKey);}}return sparseSnapshotTree.children.size===0;}else{return true;}}}/**\r\n * Recursively iterates through all of the stored tree and calls the\r\n * callback on each one.\r\n *\r\n * @param prefixPath - Path to look up node for.\r\n * @param func - The function to invoke for each tree.\r\n */function sparseSnapshotTreeForEachTree(sparseSnapshotTree,prefixPath,func){if(sparseSnapshotTree.value!==null){func(prefixPath,sparseSnapshotTree.value);}else{sparseSnapshotTreeForEachChild(sparseSnapshotTree,(key,tree)=>{const path=new Path(prefixPath.toString()+'/'+key);sparseSnapshotTreeForEachTree(tree,path,func);});}}/**\r\n * Iterates through each immediate child and triggers the callback.\r\n * Only seems to be used in tests.\r\n *\r\n * @param func - The function to invoke for each child.\r\n */function sparseSnapshotTreeForEachChild(sparseSnapshotTree,func){sparseSnapshotTree.children.forEach((tree,key)=>{func(key,tree);});}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns the delta from the previous call to get stats.\r\n *\r\n * @param collection_ - The collection to \"listen\" to.\r\n */class StatsListener{constructor(collection_){this.collection_=collection_;this.last_=null;}get(){const newStats=this.collection_.get();const delta=Object.assign({},newStats);if(this.last_){each(this.last_,(stat,value)=>{delta[stat]=delta[stat]-value;});}this.last_=newStats;return delta;}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nconst FIRST_STATS_MIN_TIME=10*1000;const FIRST_STATS_MAX_TIME=30*1000;// We'll continue to report stats on average every 5 minutes.\nconst REPORT_STATS_INTERVAL=5*60*1000;class StatsReporter{constructor(collection,server_){this.server_=server_;this.statsToReport_={};this.statsListener_=new StatsListener(collection);const timeout=FIRST_STATS_MIN_TIME+(FIRST_STATS_MAX_TIME-FIRST_STATS_MIN_TIME)*Math.random();setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(timeout));}reportStats_(){const stats=this.statsListener_.get();const reportedStats={};let haveStatsToReport=false;each(stats,(stat,value)=>{if(value>0&&(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.statsToReport_,stat)){reportedStats[stat]=value;haveStatsToReport=true;}});if(haveStatsToReport){this.server_.reportStats(reportedStats);}// queue our next run.\nsetTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(Math.random()*2*REPORT_STATS_INTERVAL));}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n *\r\n * @enum\r\n */var OperationType;(function(OperationType){OperationType[OperationType[\"OVERWRITE\"]=0]=\"OVERWRITE\";OperationType[OperationType[\"MERGE\"]=1]=\"MERGE\";OperationType[OperationType[\"ACK_USER_WRITE\"]=2]=\"ACK_USER_WRITE\";OperationType[OperationType[\"LISTEN_COMPLETE\"]=3]=\"LISTEN_COMPLETE\";})(OperationType||(OperationType={}));function newOperationSourceUser(){return{fromUser:true,fromServer:false,queryId:null,tagged:false};}function newOperationSourceServer(){return{fromUser:false,fromServer:true,queryId:null,tagged:false};}function newOperationSourceServerTaggedQuery(queryId){return{fromUser:false,fromServer:true,queryId,tagged:true};}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class AckUserWrite{/**\r\n     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.\r\n     */constructor(/** @inheritDoc */path,/** @inheritDoc */affectedTree,/** @inheritDoc */revert){this.path=path;this.affectedTree=affectedTree;this.revert=revert;/** @inheritDoc */this.type=OperationType.ACK_USER_WRITE;/** @inheritDoc */this.source=newOperationSourceUser();}operationForChild(childName){if(!pathIsEmpty(this.path)){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(this.path)===childName,'operationForChild called for unrelated child.');return new AckUserWrite(pathPopFront(this.path),this.affectedTree,this.revert);}else if(this.affectedTree.value!=null){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.affectedTree.children.isEmpty(),'affectedTree should not have overlapping affected paths.');// All child locations are affected as well; just return same operation.\nreturn this;}else{const childTree=this.affectedTree.subtree(new Path(childName));return new AckUserWrite(newEmptyPath(),childTree,this.revert);}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class ListenComplete{constructor(source,path){this.source=source;this.path=path;/** @inheritDoc */this.type=OperationType.LISTEN_COMPLETE;}operationForChild(childName){if(pathIsEmpty(this.path)){return new ListenComplete(this.source,newEmptyPath());}else{return new ListenComplete(this.source,pathPopFront(this.path));}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class Overwrite{constructor(source,path,snap){this.source=source;this.path=path;this.snap=snap;/** @inheritDoc */this.type=OperationType.OVERWRITE;}operationForChild(childName){if(pathIsEmpty(this.path)){return new Overwrite(this.source,newEmptyPath(),this.snap.getImmediateChild(childName));}else{return new Overwrite(this.source,pathPopFront(this.path),this.snap);}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class Merge{constructor(/** @inheritDoc */source,/** @inheritDoc */path,/** @inheritDoc */children){this.source=source;this.path=path;this.children=children;/** @inheritDoc */this.type=OperationType.MERGE;}operationForChild(childName){if(pathIsEmpty(this.path)){const childTree=this.children.subtree(new Path(childName));if(childTree.isEmpty()){// This child is unaffected\nreturn null;}else if(childTree.value){// We have a snapshot for the child in question.  This becomes an overwrite of the child.\nreturn new Overwrite(this.source,newEmptyPath(),childTree.value);}else{// This is a merge at a deeper level\nreturn new Merge(this.source,newEmptyPath(),childTree);}}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(this.path)===childName,\"Can't get a merge for a child not on the path of the operation\");return new Merge(this.source,pathPopFront(this.path),this.children);}}toString(){return'Operation('+this.path+': '+this.source.toString()+' merge: '+this.children.toString()+')';}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully\r\n * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.\r\n * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks\r\n * whether a node potentially had children removed due to a filter.\r\n */class CacheNode{constructor(node_,fullyInitialized_,filtered_){this.node_=node_;this.fullyInitialized_=fullyInitialized_;this.filtered_=filtered_;}/**\r\n     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client\r\n     */isFullyInitialized(){return this.fullyInitialized_;}/**\r\n     * Returns whether this node is potentially missing children due to a filter applied to the node\r\n     */isFiltered(){return this.filtered_;}isCompleteForPath(path){if(pathIsEmpty(path)){return this.isFullyInitialized()&&!this.filtered_;}const childKey=pathGetFront(path);return this.isCompleteForChild(childKey);}isCompleteForChild(key){return this.isFullyInitialized()&&!this.filtered_||this.node_.hasChild(key);}getNode(){return this.node_;}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An EventGenerator is used to convert \"raw\" changes (Change) as computed by the\r\n * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()\r\n * for details.\r\n *\r\n */class EventGenerator{constructor(query_){this.query_=query_;this.index_=this.query_._queryParams.getIndex();}}/**\r\n * Given a set of raw changes (no moved events and prevName not specified yet), and a set of\r\n * EventRegistrations that should be notified of these changes, generate the actual events to be raised.\r\n *\r\n * Notes:\r\n *  - child_moved events will be synthesized at this time for any child_changed events that affect\r\n *    our index.\r\n *  - prevName will be calculated based on the index ordering.\r\n */function eventGeneratorGenerateEventsForChanges(eventGenerator,changes,eventCache,eventRegistrations){const events=[];const moves=[];changes.forEach(change=>{if(change.type===\"child_changed\"/* CHILD_CHANGED */&&eventGenerator.index_.indexedValueChanged(change.oldSnap,change.snapshotNode)){moves.push(changeChildMoved(change.childName,change.snapshotNode));}});eventGeneratorGenerateEventsForType(eventGenerator,events,\"child_removed\"/* CHILD_REMOVED */,changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,\"child_added\"/* CHILD_ADDED */,changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,\"child_moved\"/* CHILD_MOVED */,moves,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,\"child_changed\"/* CHILD_CHANGED */,changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,\"value\"/* VALUE */,changes,eventRegistrations,eventCache);return events;}/**\r\n * Given changes of a single change type, generate the corresponding events.\r\n */function eventGeneratorGenerateEventsForType(eventGenerator,events,eventType,changes,registrations,eventCache){const filteredChanges=changes.filter(change=>change.type===eventType);filteredChanges.sort((a,b)=>eventGeneratorCompareChanges(eventGenerator,a,b));filteredChanges.forEach(change=>{const materializedChange=eventGeneratorMaterializeSingleChange(eventGenerator,change,eventCache);registrations.forEach(registration=>{if(registration.respondsTo(change.type)){events.push(registration.createEvent(materializedChange,eventGenerator.query_));}});});}function eventGeneratorMaterializeSingleChange(eventGenerator,change,eventCache){if(change.type==='value'||change.type==='child_removed'){return change;}else{change.prevName=eventCache.getPredecessorChildName(change.childName,change.snapshotNode,eventGenerator.index_);return change;}}function eventGeneratorCompareChanges(eventGenerator,a,b){if(a.childName==null||b.childName==null){throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Should only compare child_ events.');}const aWrapped=new NamedNode(a.childName,a.snapshotNode);const bWrapped=new NamedNode(b.childName,b.snapshotNode);return eventGenerator.index_.compare(aWrapped,bWrapped);}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */function newViewCache(eventCache,serverCache){return{eventCache,serverCache};}function viewCacheUpdateEventSnap(viewCache,eventSnap,complete,filtered){return newViewCache(new CacheNode(eventSnap,complete,filtered),viewCache.serverCache);}function viewCacheUpdateServerSnap(viewCache,serverSnap,complete,filtered){return newViewCache(viewCache.eventCache,new CacheNode(serverSnap,complete,filtered));}function viewCacheGetCompleteEventSnap(viewCache){return viewCache.eventCache.isFullyInitialized()?viewCache.eventCache.getNode():null;}function viewCacheGetCompleteServerSnap(viewCache){return viewCache.serverCache.isFullyInitialized()?viewCache.serverCache.getNode():null;}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */let emptyChildrenSingleton;/**\r\n * Singleton empty children collection.\r\n *\r\n */const EmptyChildren=()=>{if(!emptyChildrenSingleton){emptyChildrenSingleton=new SortedMap(stringCompare);}return emptyChildrenSingleton;};/**\r\n * A tree with immutable elements.\r\n */class ImmutableTree{constructor(value,children=EmptyChildren()){this.value=value;this.children=children;}static fromObject(obj){let tree=new ImmutableTree(null);each(obj,(childPath,childSnap)=>{tree=tree.set(new Path(childPath),childSnap);});return tree;}/**\r\n     * True if the value is empty and there are no children\r\n     */isEmpty(){return this.value===null&&this.children.isEmpty();}/**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`\r\n     * objects on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param relativePath - The remainder of the path\r\n     * @param predicate - The predicate to satisfy to return a node\r\n     */findRootMostMatchingPathAndValue(relativePath,predicate){if(this.value!=null&&predicate(this.value)){return{path:newEmptyPath(),value:this.value};}else{if(pathIsEmpty(relativePath)){return null;}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child!==null){const childExistingPathAndValue=child.findRootMostMatchingPathAndValue(pathPopFront(relativePath),predicate);if(childExistingPathAndValue!=null){const fullPath=pathChild(new Path(front),childExistingPathAndValue.path);return{path:fullPath,value:childExistingPathAndValue.value};}else{return null;}}else{return null;}}}}/**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     */findRootMostValueAndPath(relativePath){return this.findRootMostMatchingPathAndValue(relativePath,()=>true);}/**\r\n     * @returns The subtree at the given path\r\n     */subtree(relativePath){if(pathIsEmpty(relativePath)){return this;}else{const front=pathGetFront(relativePath);const childTree=this.children.get(front);if(childTree!==null){return childTree.subtree(pathPopFront(relativePath));}else{return new ImmutableTree(null);}}}/**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param relativePath - Path to set value at.\r\n     * @param toSet - Value to set.\r\n     * @returns Resulting tree.\r\n     */set(relativePath,toSet){if(pathIsEmpty(relativePath)){return new ImmutableTree(toSet,this.children);}else{const front=pathGetFront(relativePath);const child=this.children.get(front)||new ImmutableTree(null);const newChild=child.set(pathPopFront(relativePath),toSet);const newChildren=this.children.insert(front,newChild);return new ImmutableTree(this.value,newChildren);}}/**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param relativePath - Path to value to remove.\r\n     * @returns Resulting tree.\r\n     */remove(relativePath){if(pathIsEmpty(relativePath)){if(this.children.isEmpty()){return new ImmutableTree(null);}else{return new ImmutableTree(null,this.children);}}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child){const newChild=child.remove(pathPopFront(relativePath));let newChildren;if(newChild.isEmpty()){newChildren=this.children.remove(front);}else{newChildren=this.children.insert(front,newChild);}if(this.value===null&&newChildren.isEmpty()){return new ImmutableTree(null);}else{return new ImmutableTree(this.value,newChildren);}}else{return this;}}}/**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param relativePath - Path to get value for.\r\n     * @returns Value at path, or null.\r\n     */get(relativePath){if(pathIsEmpty(relativePath)){return this.value;}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child){return child.get(pathPopFront(relativePath));}else{return null;}}}/**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param relativePath - Path to replace subtree for.\r\n     * @param newTree - New tree.\r\n     * @returns Resulting tree.\r\n     */setTree(relativePath,newTree){if(pathIsEmpty(relativePath)){return newTree;}else{const front=pathGetFront(relativePath);const child=this.children.get(front)||new ImmutableTree(null);const newChild=child.setTree(pathPopFront(relativePath),newTree);let newChildren;if(newChild.isEmpty()){newChildren=this.children.remove(front);}else{newChildren=this.children.insert(front,newChild);}return new ImmutableTree(this.value,newChildren);}}/**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     */fold(fn){return this.fold_(newEmptyPath(),fn);}/**\r\n     * Recursive helper for public-facing fold() method\r\n     */fold_(pathSoFar,fn){const accum={};this.children.inorderTraversal((childKey,childTree)=>{accum[childKey]=childTree.fold_(pathChild(pathSoFar,childKey),fn);});return fn(pathSoFar,this.value,accum);}/**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     */findOnPath(path,f){return this.findOnPath_(path,newEmptyPath(),f);}findOnPath_(pathToFollow,pathSoFar,f){const result=this.value?f(pathSoFar,this.value):false;if(result){return result;}else{if(pathIsEmpty(pathToFollow)){return null;}else{const front=pathGetFront(pathToFollow);const nextChild=this.children.get(front);if(nextChild){return nextChild.findOnPath_(pathPopFront(pathToFollow),pathChild(pathSoFar,front),f);}else{return null;}}}}foreachOnPath(path,f){return this.foreachOnPath_(path,newEmptyPath(),f);}foreachOnPath_(pathToFollow,currentRelativePath,f){if(pathIsEmpty(pathToFollow)){return this;}else{if(this.value){f(currentRelativePath,this.value);}const front=pathGetFront(pathToFollow);const nextChild=this.children.get(front);if(nextChild){return nextChild.foreachOnPath_(pathPopFront(pathToFollow),pathChild(currentRelativePath,front),f);}else{return new ImmutableTree(null);}}}/**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param f - A function to be called with the path from the root of the tree to\r\n     * a node, and the value at that node. Called in depth-first order.\r\n     */foreach(f){this.foreach_(newEmptyPath(),f);}foreach_(currentRelativePath,f){this.children.inorderTraversal((childName,childTree)=>{childTree.foreach_(pathChild(currentRelativePath,childName),f);});if(this.value){f(currentRelativePath,this.value);}}foreachChild(f){this.children.inorderTraversal((childName,childTree)=>{if(childTree.value){f(childName,childTree.value);}});}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\r\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\r\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\r\n * to reflect the write added.\r\n */class CompoundWrite{constructor(writeTree_){this.writeTree_=writeTree_;}static empty(){return new CompoundWrite(new ImmutableTree(null));}}function compoundWriteAddWrite(compoundWrite,path,node){if(pathIsEmpty(path)){return new CompoundWrite(new ImmutableTree(node));}else{const rootmost=compoundWrite.writeTree_.findRootMostValueAndPath(path);if(rootmost!=null){const rootMostPath=rootmost.path;let value=rootmost.value;const relativePath=newRelativePath(rootMostPath,path);value=value.updateChild(relativePath,node);return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath,value));}else{const subtree=new ImmutableTree(node);const newWriteTree=compoundWrite.writeTree_.setTree(path,subtree);return new CompoundWrite(newWriteTree);}}}function compoundWriteAddWrites(compoundWrite,path,updates){let newWrite=compoundWrite;each(updates,(childKey,node)=>{newWrite=compoundWriteAddWrite(newWrite,pathChild(path,childKey),node);});return newWrite;}/**\r\n * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\r\n * location, which must be removed by calling this method with that path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to remove.\r\n * @param path - The path at which a write and all deeper writes should be removed\r\n * @returns The new CompoundWrite with the removed path\r\n */function compoundWriteRemoveWrite(compoundWrite,path){if(pathIsEmpty(path)){return CompoundWrite.empty();}else{const newWriteTree=compoundWrite.writeTree_.setTree(path,new ImmutableTree(null));return new CompoundWrite(newWriteTree);}}/**\r\n * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\r\n * considered \"complete\".\r\n *\r\n * @param compoundWrite - The CompoundWrite to check.\r\n * @param path - The path to check for\r\n * @returns Whether there is a complete write at that path\r\n */function compoundWriteHasCompleteWrite(compoundWrite,path){return compoundWriteGetCompleteNode(compoundWrite,path)!=null;}/**\r\n * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\r\n * writes from deeper paths, but will return child nodes from a more shallow path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get the node from.\r\n * @param path - The path to get a complete write\r\n * @returns The node if complete at that path, or null otherwise.\r\n */function compoundWriteGetCompleteNode(compoundWrite,path){const rootmost=compoundWrite.writeTree_.findRootMostValueAndPath(path);if(rootmost!=null){return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path,path));}else{return null;}}/**\r\n * Returns all children that are guaranteed to be a complete overwrite.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get children from.\r\n * @returns A list of all complete children.\r\n */function compoundWriteGetCompleteChildren(compoundWrite){const children=[];const node=compoundWrite.writeTree_.value;if(node!=null){// If it's a leaf node, it has no children; so nothing to do.\nif(!node.isLeafNode()){node.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{children.push(new NamedNode(childName,childNode));});}}else{compoundWrite.writeTree_.children.inorderTraversal((childName,childTree)=>{if(childTree.value!=null){children.push(new NamedNode(childName,childTree.value));}});}return children;}function compoundWriteChildCompoundWrite(compoundWrite,path){if(pathIsEmpty(path)){return compoundWrite;}else{const shadowingNode=compoundWriteGetCompleteNode(compoundWrite,path);if(shadowingNode!=null){return new CompoundWrite(new ImmutableTree(shadowingNode));}else{return new CompoundWrite(compoundWrite.writeTree_.subtree(path));}}}/**\r\n * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\r\n * @returns Whether this CompoundWrite is empty\r\n */function compoundWriteIsEmpty(compoundWrite){return compoundWrite.writeTree_.isEmpty();}/**\r\n * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\r\n * node\r\n * @param node - The node to apply this CompoundWrite to\r\n * @returns The node with all writes applied\r\n */function compoundWriteApply(compoundWrite,node){return applySubtreeWrite(newEmptyPath(),compoundWrite.writeTree_,node);}function applySubtreeWrite(relativePath,writeTree,node){if(writeTree.value!=null){// Since there a write is always a leaf, we're done here\nreturn node.updateChild(relativePath,writeTree.value);}else{let priorityWrite=null;writeTree.children.inorderTraversal((childKey,childTree)=>{if(childKey==='.priority'){// Apply priorities at the end so we don't update priorities for either empty nodes or forget\n// to apply priorities to empty nodes that are later filled\n(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(childTree.value!==null,'Priority writes must always be leaf nodes');priorityWrite=childTree.value;}else{node=applySubtreeWrite(pathChild(relativePath,childKey),childTree,node);}});// If there was a priority write, we only apply it if the node is not empty\nif(!node.getChild(relativePath).isEmpty()&&priorityWrite!==null){node=node.updateChild(pathChild(relativePath,'.priority'),priorityWrite);}return node;}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n *\r\n */function writeTreeChildWrites(writeTree,path){return newWriteTreeRef(path,writeTree);}/**\r\n * Record a new overwrite from user code.\r\n *\r\n * @param visible - This is set to false by some transactions. It should be excluded from event caches\r\n */function writeTreeAddOverwrite(writeTree,path,snap,writeId,visible){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(writeId>writeTree.lastWriteId,'Stacking an older write on top of newer ones');if(visible===undefined){visible=true;}writeTree.allWrites.push({path,snap,writeId,visible});if(visible){writeTree.visibleWrites=compoundWriteAddWrite(writeTree.visibleWrites,path,snap);}writeTree.lastWriteId=writeId;}/**\r\n * Record a new merge from user code.\r\n */function writeTreeAddMerge(writeTree,path,changedChildren,writeId){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(writeId>writeTree.lastWriteId,'Stacking an older merge on top of newer ones');writeTree.allWrites.push({path,children:changedChildren,writeId,visible:true});writeTree.visibleWrites=compoundWriteAddWrites(writeTree.visibleWrites,path,changedChildren);writeTree.lastWriteId=writeId;}function writeTreeGetWrite(writeTree,writeId){for(let i=0;i<writeTree.allWrites.length;i++){const record=writeTree.allWrites[i];if(record.writeId===writeId){return record;}}return null;}/**\r\n * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n *\r\n * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n * events as a result).\r\n */function writeTreeRemoveWrite(writeTree,writeId){// Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n// out of order.\n//const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n//assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\nconst idx=writeTree.allWrites.findIndex(s=>{return s.writeId===writeId;});(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(idx>=0,'removeWrite called with nonexistent writeId.');const writeToRemove=writeTree.allWrites[idx];writeTree.allWrites.splice(idx,1);let removedWriteWasVisible=writeToRemove.visible;let removedWriteOverlapsWithOtherWrites=false;let i=writeTree.allWrites.length-1;while(removedWriteWasVisible&&i>=0){const currentWrite=writeTree.allWrites[i];if(currentWrite.visible){if(i>=idx&&writeTreeRecordContainsPath_(currentWrite,writeToRemove.path)){// The removed write was completely shadowed by a subsequent write.\nremovedWriteWasVisible=false;}else if(pathContains(writeToRemove.path,currentWrite.path)){// Either we're covering some writes or they're covering part of us (depending on which came first).\nremovedWriteOverlapsWithOtherWrites=true;}}i--;}if(!removedWriteWasVisible){return false;}else if(removedWriteOverlapsWithOtherWrites){// There's some shadowing going on. Just rebuild the visible writes from scratch.\nwriteTreeResetTree_(writeTree);return true;}else{// There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\nif(writeToRemove.snap){writeTree.visibleWrites=compoundWriteRemoveWrite(writeTree.visibleWrites,writeToRemove.path);}else{const children=writeToRemove.children;each(children,childName=>{writeTree.visibleWrites=compoundWriteRemoveWrite(writeTree.visibleWrites,pathChild(writeToRemove.path,childName));});}return true;}}function writeTreeRecordContainsPath_(writeRecord,path){if(writeRecord.snap){return pathContains(writeRecord.path,path);}else{for(const childName in writeRecord.children){if(writeRecord.children.hasOwnProperty(childName)&&pathContains(pathChild(writeRecord.path,childName),path)){return true;}}return false;}}/**\r\n * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n */function writeTreeResetTree_(writeTree){writeTree.visibleWrites=writeTreeLayerTree_(writeTree.allWrites,writeTreeDefaultFilter_,newEmptyPath());if(writeTree.allWrites.length>0){writeTree.lastWriteId=writeTree.allWrites[writeTree.allWrites.length-1].writeId;}else{writeTree.lastWriteId=-1;}}/**\r\n * The default filter used when constructing the tree. Keep everything that's visible.\r\n */function writeTreeDefaultFilter_(write){return write.visible;}/**\r\n * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n * event data at that path.\r\n */function writeTreeLayerTree_(writes,filter,treeRoot){let compoundWrite=CompoundWrite.empty();for(let i=0;i<writes.length;++i){const write=writes[i];// Theory, a later set will either:\n// a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n// b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\nif(filter(write)){const writePath=write.path;let relativePath;if(write.snap){if(pathContains(treeRoot,writePath)){relativePath=newRelativePath(treeRoot,writePath);compoundWrite=compoundWriteAddWrite(compoundWrite,relativePath,write.snap);}else if(pathContains(writePath,treeRoot)){relativePath=newRelativePath(writePath,treeRoot);compoundWrite=compoundWriteAddWrite(compoundWrite,newEmptyPath(),write.snap.getChild(relativePath));}else;}else if(write.children){if(pathContains(treeRoot,writePath)){relativePath=newRelativePath(treeRoot,writePath);compoundWrite=compoundWriteAddWrites(compoundWrite,relativePath,write.children);}else if(pathContains(writePath,treeRoot)){relativePath=newRelativePath(writePath,treeRoot);if(pathIsEmpty(relativePath)){compoundWrite=compoundWriteAddWrites(compoundWrite,newEmptyPath(),write.children);}else{const child=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(write.children,pathGetFront(relativePath));if(child){// There exists a child in this node that matches the root path\nconst deepNode=child.getChild(pathPopFront(relativePath));compoundWrite=compoundWriteAddWrite(compoundWrite,newEmptyPath(),deepNode);}}}else;}else{throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('WriteRecord should have .snap or .children');}}}return compoundWrite;}/**\r\n * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n * writes), attempt to calculate a complete snapshot for the given path\r\n *\r\n * @param writeIdsToExclude - An optional set to be excluded\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */function writeTreeCalcCompleteEventCache(writeTree,treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites){if(!writeIdsToExclude&&!includeHiddenWrites){const shadowingNode=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);if(shadowingNode!=null){return shadowingNode;}else{const subMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);if(compoundWriteIsEmpty(subMerge)){return completeServerCache;}else if(completeServerCache==null&&!compoundWriteHasCompleteWrite(subMerge,newEmptyPath())){// We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\nreturn null;}else{const layeredCache=completeServerCache||ChildrenNode.EMPTY_NODE;return compoundWriteApply(subMerge,layeredCache);}}}else{const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);if(!includeHiddenWrites&&compoundWriteIsEmpty(merge)){return completeServerCache;}else{// If the server cache is null, and we don't have a complete cache, we need to return null\nif(!includeHiddenWrites&&completeServerCache==null&&!compoundWriteHasCompleteWrite(merge,newEmptyPath())){return null;}else{const filter=function(write){return(write.visible||includeHiddenWrites)&&(!writeIdsToExclude||!~writeIdsToExclude.indexOf(write.writeId))&&(pathContains(write.path,treePath)||pathContains(treePath,write.path));};const mergeAtPath=writeTreeLayerTree_(writeTree.allWrites,filter,treePath);const layeredCache=completeServerCache||ChildrenNode.EMPTY_NODE;return compoundWriteApply(mergeAtPath,layeredCache);}}}}/**\r\n * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n * Used when creating new views, to pre-fill their complete event children snapshot.\r\n */function writeTreeCalcCompleteEventChildren(writeTree,treePath,completeServerChildren){let completeChildren=ChildrenNode.EMPTY_NODE;const topLevelSet=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);if(topLevelSet){if(!topLevelSet.isLeafNode()){// we're shadowing everything. Return the children.\ntopLevelSet.forEachChild(PRIORITY_INDEX,(childName,childSnap)=>{completeChildren=completeChildren.updateImmediateChild(childName,childSnap);});}return completeChildren;}else if(completeServerChildren){// Layer any children we have on top of this\n// We know we don't have a top-level set, so just enumerate existing children\nconst merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);completeServerChildren.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{const node=compoundWriteApply(compoundWriteChildCompoundWrite(merge,new Path(childName)),childNode);completeChildren=completeChildren.updateImmediateChild(childName,node);});// Add any complete children we have from the set\ncompoundWriteGetCompleteChildren(merge).forEach(namedNode=>{completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node);});return completeChildren;}else{// We don't have anything to layer on top of. Layer on any children we have\n// Note that we can return an empty snap if we have a defined delete\nconst merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);compoundWriteGetCompleteChildren(merge).forEach(namedNode=>{completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node);});return completeChildren;}}/**\r\n * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n * applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist\r\n */function writeTreeCalcEventCacheAfterServerOverwrite(writeTree,treePath,childPath,existingEventSnap,existingServerSnap){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(existingEventSnap||existingServerSnap,'Either existingEventSnap or existingServerSnap must exist');const path=pathChild(treePath,childPath);if(compoundWriteHasCompleteWrite(writeTree.visibleWrites,path)){// At this point we can probably guarantee that we're in case 2, meaning no events\n// May need to check visibility while doing the findRootMostValueAndPath call\nreturn null;}else{// No complete shadowing. We're either partially shadowing or not shadowing at all.\nconst childMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,path);if(compoundWriteIsEmpty(childMerge)){// We're not shadowing at all. Case 1\nreturn existingServerSnap.getChild(childPath);}else{// This could be more efficient if the serverNode + updates doesn't change the eventSnap\n// However this is tricky to find out, since user updates don't necessary change the server\n// snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n// adds nodes, but doesn't change any existing writes. It is therefore not enough to\n// only check if the updates change the serverNode.\n// Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\nreturn compoundWriteApply(childMerge,existingServerSnap.getChild(childPath));}}}/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */function writeTreeCalcCompleteChild(writeTree,treePath,childKey,existingServerSnap){const path=pathChild(treePath,childKey);const shadowingNode=compoundWriteGetCompleteNode(writeTree.visibleWrites,path);if(shadowingNode!=null){return shadowingNode;}else{if(existingServerSnap.isCompleteForChild(childKey)){const childMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,path);return compoundWriteApply(childMerge,existingServerSnap.getNode().getImmediateChild(childKey));}else{return null;}}}/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n */function writeTreeShadowingWrite(writeTree,path){return compoundWriteGetCompleteNode(writeTree.visibleWrites,path);}/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window.\r\n */function writeTreeCalcIndexedSlice(writeTree,treePath,completeServerData,startPost,count,reverse,index){let toIterate;const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);const shadowingNode=compoundWriteGetCompleteNode(merge,newEmptyPath());if(shadowingNode!=null){toIterate=shadowingNode;}else if(completeServerData!=null){toIterate=compoundWriteApply(merge,completeServerData);}else{// no children to iterate on\nreturn[];}toIterate=toIterate.withIndex(index);if(!toIterate.isEmpty()&&!toIterate.isLeafNode()){const nodes=[];const cmp=index.getCompare();const iter=reverse?toIterate.getReverseIteratorFrom(startPost,index):toIterate.getIteratorFrom(startPost,index);let next=iter.getNext();while(next&&nodes.length<count){if(cmp(next,startPost)!==0){nodes.push(next);}next=iter.getNext();}return nodes;}else{return[];}}function newWriteTree(){return{visibleWrites:CompoundWrite.empty(),allWrites:[],lastWriteId:-1};}/**\r\n * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n * can lead to a more expensive calculation.\r\n *\r\n * @param writeIdsToExclude - Optional writes to exclude.\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */function writeTreeRefCalcCompleteEventCache(writeTreeRef,completeServerCache,writeIdsToExclude,includeHiddenWrites){return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites);}/**\r\n * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n * mix of the given server data and write data.\r\n *\r\n */function writeTreeRefCalcCompleteEventChildren(writeTreeRef,completeServerChildren){return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerChildren);}/**\r\n * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n * if anything, needs to be applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events should be raised\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n *\r\n *\r\n */function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef,path,existingEventSnap,existingServerSnap){return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree,writeTreeRef.treePath,path,existingEventSnap,existingServerSnap);}/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n *\r\n */function writeTreeRefShadowingWrite(writeTreeRef,path){return writeTreeShadowingWrite(writeTreeRef.writeTree,pathChild(writeTreeRef.treePath,path));}/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window\r\n */function writeTreeRefCalcIndexedSlice(writeTreeRef,completeServerData,startPost,count,reverse,index){return writeTreeCalcIndexedSlice(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerData,startPost,count,reverse,index);}/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */function writeTreeRefCalcCompleteChild(writeTreeRef,childKey,existingServerCache){return writeTreeCalcCompleteChild(writeTreeRef.writeTree,writeTreeRef.treePath,childKey,existingServerCache);}/**\r\n * Return a WriteTreeRef for a child.\r\n */function writeTreeRefChild(writeTreeRef,childName){return newWriteTreeRef(pathChild(writeTreeRef.treePath,childName),writeTreeRef.writeTree);}function newWriteTreeRef(path,writeTree){return{treePath:path,writeTree};}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class ChildChangeAccumulator{constructor(){this.changeMap=new Map();}trackChildChange(change){const type=change.type;const childKey=change.childName;(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(type===\"child_added\"/* CHILD_ADDED */||type===\"child_changed\"/* CHILD_CHANGED */||type===\"child_removed\"/* CHILD_REMOVED */,'Only child changes supported for tracking');(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(childKey!=='.priority','Only non-priority child changes can be tracked.');const oldChange=this.changeMap.get(childKey);if(oldChange){const oldType=oldChange.type;if(type===\"child_added\"/* CHILD_ADDED */&&oldType===\"child_removed\"/* CHILD_REMOVED */){this.changeMap.set(childKey,changeChildChanged(childKey,change.snapshotNode,oldChange.snapshotNode));}else if(type===\"child_removed\"/* CHILD_REMOVED */&&oldType===\"child_added\"/* CHILD_ADDED */){this.changeMap.delete(childKey);}else if(type===\"child_removed\"/* CHILD_REMOVED */&&oldType===\"child_changed\"/* CHILD_CHANGED */){this.changeMap.set(childKey,changeChildRemoved(childKey,oldChange.oldSnap));}else if(type===\"child_changed\"/* CHILD_CHANGED */&&oldType===\"child_added\"/* CHILD_ADDED */){this.changeMap.set(childKey,changeChildAdded(childKey,change.snapshotNode));}else if(type===\"child_changed\"/* CHILD_CHANGED */&&oldType===\"child_changed\"/* CHILD_CHANGED */){this.changeMap.set(childKey,changeChildChanged(childKey,change.snapshotNode,oldChange.oldSnap));}else{throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Illegal combination of changes: '+change+' occurred after '+oldChange);}}else{this.changeMap.set(childKey,change);}}getChanges(){return Array.from(this.changeMap.values());}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An implementation of CompleteChildSource that never returns any additional children\r\n */ // eslint-disable-next-line @typescript-eslint/naming-convention\nclass NoCompleteChildSource_{getCompleteChild(childKey){return null;}getChildAfterChild(index,child,reverse){return null;}}/**\r\n * Singleton instance.\r\n */const NO_COMPLETE_CHILD_SOURCE=new NoCompleteChildSource_();/**\r\n * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or\r\n * old event caches available to calculate complete children.\r\n */class WriteTreeCompleteChildSource{constructor(writes_,viewCache_,optCompleteServerCache_=null){this.writes_=writes_;this.viewCache_=viewCache_;this.optCompleteServerCache_=optCompleteServerCache_;}getCompleteChild(childKey){const node=this.viewCache_.eventCache;if(node.isCompleteForChild(childKey)){return node.getNode().getImmediateChild(childKey);}else{const serverNode=this.optCompleteServerCache_!=null?new CacheNode(this.optCompleteServerCache_,true,false):this.viewCache_.serverCache;return writeTreeRefCalcCompleteChild(this.writes_,childKey,serverNode);}}getChildAfterChild(index,child,reverse){const completeServerData=this.optCompleteServerCache_!=null?this.optCompleteServerCache_:viewCacheGetCompleteServerSnap(this.viewCache_);const nodes=writeTreeRefCalcIndexedSlice(this.writes_,completeServerData,child,1,reverse,index);if(nodes.length===0){return null;}else{return nodes[0];}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */function newViewProcessor(filter){return{filter};}function viewProcessorAssertIndexed(viewProcessor,viewCache){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()),'Event snap not indexed');(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()),'Server snap not indexed');}function viewProcessorApplyOperation(viewProcessor,oldViewCache,operation,writesCache,completeCache){const accumulator=new ChildChangeAccumulator();let newViewCache,filterServerNode;if(operation.type===OperationType.OVERWRITE){const overwrite=operation;if(overwrite.source.fromUser){newViewCache=viewProcessorApplyUserOverwrite(viewProcessor,oldViewCache,overwrite.path,overwrite.snap,writesCache,completeCache,accumulator);}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(overwrite.source.fromServer,'Unknown source.');// We filter the node if it's a tagged update or the node has been previously filtered  and the\n// update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n// again\nfilterServerNode=overwrite.source.tagged||oldViewCache.serverCache.isFiltered()&&!pathIsEmpty(overwrite.path);newViewCache=viewProcessorApplyServerOverwrite(viewProcessor,oldViewCache,overwrite.path,overwrite.snap,writesCache,completeCache,filterServerNode,accumulator);}}else if(operation.type===OperationType.MERGE){const merge=operation;if(merge.source.fromUser){newViewCache=viewProcessorApplyUserMerge(viewProcessor,oldViewCache,merge.path,merge.children,writesCache,completeCache,accumulator);}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(merge.source.fromServer,'Unknown source.');// We filter the node if it's a tagged update or the node has been previously filtered\nfilterServerNode=merge.source.tagged||oldViewCache.serverCache.isFiltered();newViewCache=viewProcessorApplyServerMerge(viewProcessor,oldViewCache,merge.path,merge.children,writesCache,completeCache,filterServerNode,accumulator);}}else if(operation.type===OperationType.ACK_USER_WRITE){const ackUserWrite=operation;if(!ackUserWrite.revert){newViewCache=viewProcessorAckUserWrite(viewProcessor,oldViewCache,ackUserWrite.path,ackUserWrite.affectedTree,writesCache,completeCache,accumulator);}else{newViewCache=viewProcessorRevertUserWrite(viewProcessor,oldViewCache,ackUserWrite.path,writesCache,completeCache,accumulator);}}else if(operation.type===OperationType.LISTEN_COMPLETE){newViewCache=viewProcessorListenComplete(viewProcessor,oldViewCache,operation.path,writesCache,accumulator);}else{throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Unknown operation type: '+operation.type);}const changes=accumulator.getChanges();viewProcessorMaybeAddValueEvent(oldViewCache,newViewCache,changes);return{viewCache:newViewCache,changes};}function viewProcessorMaybeAddValueEvent(oldViewCache,newViewCache,accumulator){const eventSnap=newViewCache.eventCache;if(eventSnap.isFullyInitialized()){const isLeafOrEmpty=eventSnap.getNode().isLeafNode()||eventSnap.getNode().isEmpty();const oldCompleteSnap=viewCacheGetCompleteEventSnap(oldViewCache);if(accumulator.length>0||!oldViewCache.eventCache.isFullyInitialized()||isLeafOrEmpty&&!eventSnap.getNode().equals(oldCompleteSnap)||!eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())){accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));}}}function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,viewCache,changePath,writesCache,source,accumulator){const oldEventSnap=viewCache.eventCache;if(writeTreeRefShadowingWrite(writesCache,changePath)!=null){// we have a shadowing write, ignore changes\nreturn viewCache;}else{let newEventCache,serverNode;if(pathIsEmpty(changePath)){// TODO: figure out how this plays with \"sliding ack windows\"\n(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.serverCache.isFullyInitialized(),'If change path is empty, we must have complete server data');if(viewCache.serverCache.isFiltered()){// We need to special case this, because we need to only apply writes to complete children, or\n// we might end up raising events for incomplete children. If the server data is filtered deep\n// writes cannot be guaranteed to be complete\nconst serverCache=viewCacheGetCompleteServerSnap(viewCache);const completeChildren=serverCache instanceof ChildrenNode?serverCache:ChildrenNode.EMPTY_NODE;const completeEventChildren=writeTreeRefCalcCompleteEventChildren(writesCache,completeChildren);newEventCache=viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(),completeEventChildren,accumulator);}else{const completeNode=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache));newEventCache=viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(),completeNode,accumulator);}}else{const childKey=pathGetFront(changePath);if(childKey==='.priority'){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetLength(changePath)===1,\"Can't have a priority with additional path components\");const oldEventNode=oldEventSnap.getNode();serverNode=viewCache.serverCache.getNode();// we might have overwrites for this priority\nconst updatedPriority=writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache,changePath,oldEventNode,serverNode);if(updatedPriority!=null){newEventCache=viewProcessor.filter.updatePriority(oldEventNode,updatedPriority);}else{// priority didn't change, keep old node\nnewEventCache=oldEventSnap.getNode();}}else{const childChangePath=pathPopFront(changePath);// update child\nlet newEventChild;if(oldEventSnap.isCompleteForChild(childKey)){serverNode=viewCache.serverCache.getNode();const eventChildUpdate=writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache,changePath,oldEventSnap.getNode(),serverNode);if(eventChildUpdate!=null){newEventChild=oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath,eventChildUpdate);}else{// Nothing changed, just keep the old child\nnewEventChild=oldEventSnap.getNode().getImmediateChild(childKey);}}else{newEventChild=writeTreeRefCalcCompleteChild(writesCache,childKey,viewCache.serverCache);}if(newEventChild!=null){newEventCache=viewProcessor.filter.updateChild(oldEventSnap.getNode(),childKey,newEventChild,childChangePath,source,accumulator);}else{// no complete child available or no change\nnewEventCache=oldEventSnap.getNode();}}}return viewCacheUpdateEventSnap(viewCache,newEventCache,oldEventSnap.isFullyInitialized()||pathIsEmpty(changePath),viewProcessor.filter.filtersNodes());}}function viewProcessorApplyServerOverwrite(viewProcessor,oldViewCache,changePath,changedSnap,writesCache,completeCache,filterServerNode,accumulator){const oldServerSnap=oldViewCache.serverCache;let newServerCache;const serverFilter=filterServerNode?viewProcessor.filter:viewProcessor.filter.getIndexedFilter();if(pathIsEmpty(changePath)){newServerCache=serverFilter.updateFullNode(oldServerSnap.getNode(),changedSnap,null);}else if(serverFilter.filtersNodes()&&!oldServerSnap.isFiltered()){// we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\nconst newServerNode=oldServerSnap.getNode().updateChild(changePath,changedSnap);newServerCache=serverFilter.updateFullNode(oldServerSnap.getNode(),newServerNode,null);}else{const childKey=pathGetFront(changePath);if(!oldServerSnap.isCompleteForPath(changePath)&&pathGetLength(changePath)>1){// We don't update incomplete nodes with updates intended for other listeners\nreturn oldViewCache;}const childChangePath=pathPopFront(changePath);const childNode=oldServerSnap.getNode().getImmediateChild(childKey);const newChildNode=childNode.updateChild(childChangePath,changedSnap);if(childKey==='.priority'){newServerCache=serverFilter.updatePriority(oldServerSnap.getNode(),newChildNode);}else{newServerCache=serverFilter.updateChild(oldServerSnap.getNode(),childKey,newChildNode,childChangePath,NO_COMPLETE_CHILD_SOURCE,null);}}const newViewCache=viewCacheUpdateServerSnap(oldViewCache,newServerCache,oldServerSnap.isFullyInitialized()||pathIsEmpty(changePath),serverFilter.filtersNodes());const source=new WriteTreeCompleteChildSource(writesCache,newViewCache,completeCache);return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,newViewCache,changePath,writesCache,source,accumulator);}function viewProcessorApplyUserOverwrite(viewProcessor,oldViewCache,changePath,changedSnap,writesCache,completeCache,accumulator){const oldEventSnap=oldViewCache.eventCache;let newViewCache,newEventCache;const source=new WriteTreeCompleteChildSource(writesCache,oldViewCache,completeCache);if(pathIsEmpty(changePath)){newEventCache=viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(),changedSnap,accumulator);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventCache,true,viewProcessor.filter.filtersNodes());}else{const childKey=pathGetFront(changePath);if(childKey==='.priority'){newEventCache=viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(),changedSnap);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventCache,oldEventSnap.isFullyInitialized(),oldEventSnap.isFiltered());}else{const childChangePath=pathPopFront(changePath);const oldChild=oldEventSnap.getNode().getImmediateChild(childKey);let newChild;if(pathIsEmpty(childChangePath)){// Child overwrite, we can replace the child\nnewChild=changedSnap;}else{const childNode=source.getCompleteChild(childKey);if(childNode!=null){if(pathGetBack(childChangePath)==='.priority'&&childNode.getChild(pathParent(childChangePath)).isEmpty()){// This is a priority update on an empty node. If this node exists on the server, the\n// server will send down the priority in the update, so ignore for now\nnewChild=childNode;}else{newChild=childNode.updateChild(childChangePath,changedSnap);}}else{// There is no complete child node available\nnewChild=ChildrenNode.EMPTY_NODE;}}if(!oldChild.equals(newChild)){const newEventSnap=viewProcessor.filter.updateChild(oldEventSnap.getNode(),childKey,newChild,childChangePath,source,accumulator);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventSnap,oldEventSnap.isFullyInitialized(),viewProcessor.filter.filtersNodes());}else{newViewCache=oldViewCache;}}}return newViewCache;}function viewProcessorCacheHasChild(viewCache,childKey){return viewCache.eventCache.isCompleteForChild(childKey);}function viewProcessorApplyUserMerge(viewProcessor,viewCache,path,changedChildren,writesCache,serverCache,accumulator){// HACK: In the case of a limit query, there may be some changes that bump things out of the\n// window leaving room for new items.  It's important we process these changes first, so we\n// iterate the changes twice, first processing any that affect items currently in view.\n// TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n// and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n// not the other.\nlet curViewCache=viewCache;changedChildren.foreach((relativePath,childNode)=>{const writePath=pathChild(path,relativePath);if(viewProcessorCacheHasChild(viewCache,pathGetFront(writePath))){curViewCache=viewProcessorApplyUserOverwrite(viewProcessor,curViewCache,writePath,childNode,writesCache,serverCache,accumulator);}});changedChildren.foreach((relativePath,childNode)=>{const writePath=pathChild(path,relativePath);if(!viewProcessorCacheHasChild(viewCache,pathGetFront(writePath))){curViewCache=viewProcessorApplyUserOverwrite(viewProcessor,curViewCache,writePath,childNode,writesCache,serverCache,accumulator);}});return curViewCache;}function viewProcessorApplyMerge(viewProcessor,node,merge){merge.foreach((relativePath,childNode)=>{node=node.updateChild(relativePath,childNode);});return node;}function viewProcessorApplyServerMerge(viewProcessor,viewCache,path,changedChildren,writesCache,serverCache,filterServerNode,accumulator){// If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n// wait for the complete data update coming soon.\nif(viewCache.serverCache.getNode().isEmpty()&&!viewCache.serverCache.isFullyInitialized()){return viewCache;}// HACK: In the case of a limit query, there may be some changes that bump things out of the\n// window leaving room for new items.  It's important we process these changes first, so we\n// iterate the changes twice, first processing any that affect items currently in view.\n// TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n// and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n// not the other.\nlet curViewCache=viewCache;let viewMergeTree;if(pathIsEmpty(path)){viewMergeTree=changedChildren;}else{viewMergeTree=new ImmutableTree(null).setTree(path,changedChildren);}const serverNode=viewCache.serverCache.getNode();viewMergeTree.children.inorderTraversal((childKey,childTree)=>{if(serverNode.hasChild(childKey)){const serverChild=viewCache.serverCache.getNode().getImmediateChild(childKey);const newChild=viewProcessorApplyMerge(viewProcessor,serverChild,childTree);curViewCache=viewProcessorApplyServerOverwrite(viewProcessor,curViewCache,new Path(childKey),newChild,writesCache,serverCache,filterServerNode,accumulator);}});viewMergeTree.children.inorderTraversal((childKey,childMergeTree)=>{const isUnknownDeepMerge=!viewCache.serverCache.isCompleteForChild(childKey)&&childMergeTree.value===undefined;if(!serverNode.hasChild(childKey)&&!isUnknownDeepMerge){const serverChild=viewCache.serverCache.getNode().getImmediateChild(childKey);const newChild=viewProcessorApplyMerge(viewProcessor,serverChild,childMergeTree);curViewCache=viewProcessorApplyServerOverwrite(viewProcessor,curViewCache,new Path(childKey),newChild,writesCache,serverCache,filterServerNode,accumulator);}});return curViewCache;}function viewProcessorAckUserWrite(viewProcessor,viewCache,ackPath,affectedTree,writesCache,completeCache,accumulator){if(writeTreeRefShadowingWrite(writesCache,ackPath)!=null){return viewCache;}// Only filter server node if it is currently filtered\nconst filterServerNode=viewCache.serverCache.isFiltered();// Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n// now that it won't be shadowed.\nconst serverCache=viewCache.serverCache;if(affectedTree.value!=null){// This is an overwrite.\nif(pathIsEmpty(ackPath)&&serverCache.isFullyInitialized()||serverCache.isCompleteForPath(ackPath)){return viewProcessorApplyServerOverwrite(viewProcessor,viewCache,ackPath,serverCache.getNode().getChild(ackPath),writesCache,completeCache,filterServerNode,accumulator);}else if(pathIsEmpty(ackPath)){// This is a goofy edge case where we are acking data at this location but don't have full data.  We\n// should just re-apply whatever we have in our cache as a merge.\nlet changedChildren=new ImmutableTree(null);serverCache.getNode().forEachChild(KEY_INDEX,(name,node)=>{changedChildren=changedChildren.set(new Path(name),node);});return viewProcessorApplyServerMerge(viewProcessor,viewCache,ackPath,changedChildren,writesCache,completeCache,filterServerNode,accumulator);}else{return viewCache;}}else{// This is a merge.\nlet changedChildren=new ImmutableTree(null);affectedTree.foreach((mergePath,value)=>{const serverCachePath=pathChild(ackPath,mergePath);if(serverCache.isCompleteForPath(serverCachePath)){changedChildren=changedChildren.set(mergePath,serverCache.getNode().getChild(serverCachePath));}});return viewProcessorApplyServerMerge(viewProcessor,viewCache,ackPath,changedChildren,writesCache,completeCache,filterServerNode,accumulator);}}function viewProcessorListenComplete(viewProcessor,viewCache,path,writesCache,accumulator){const oldServerNode=viewCache.serverCache;const newViewCache=viewCacheUpdateServerSnap(viewCache,oldServerNode.getNode(),oldServerNode.isFullyInitialized()||pathIsEmpty(path),oldServerNode.isFiltered());return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,newViewCache,path,writesCache,NO_COMPLETE_CHILD_SOURCE,accumulator);}function viewProcessorRevertUserWrite(viewProcessor,viewCache,path,writesCache,completeServerCache,accumulator){let complete;if(writeTreeRefShadowingWrite(writesCache,path)!=null){return viewCache;}else{const source=new WriteTreeCompleteChildSource(writesCache,viewCache,completeServerCache);const oldEventCache=viewCache.eventCache.getNode();let newEventCache;if(pathIsEmpty(path)||pathGetFront(path)==='.priority'){let newNode;if(viewCache.serverCache.isFullyInitialized()){newNode=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache));}else{const serverChildren=viewCache.serverCache.getNode();(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(serverChildren instanceof ChildrenNode,'serverChildren would be complete if leaf node');newNode=writeTreeRefCalcCompleteEventChildren(writesCache,serverChildren);}newNode=newNode;newEventCache=viewProcessor.filter.updateFullNode(oldEventCache,newNode,accumulator);}else{const childKey=pathGetFront(path);let newChild=writeTreeRefCalcCompleteChild(writesCache,childKey,viewCache.serverCache);if(newChild==null&&viewCache.serverCache.isCompleteForChild(childKey)){newChild=oldEventCache.getImmediateChild(childKey);}if(newChild!=null){newEventCache=viewProcessor.filter.updateChild(oldEventCache,childKey,newChild,pathPopFront(path),source,accumulator);}else if(viewCache.eventCache.getNode().hasChild(childKey)){// No complete child available, delete the existing one, if any\nnewEventCache=viewProcessor.filter.updateChild(oldEventCache,childKey,ChildrenNode.EMPTY_NODE,pathPopFront(path),source,accumulator);}else{newEventCache=oldEventCache;}if(newEventCache.isEmpty()&&viewCache.serverCache.isFullyInitialized()){// We might have reverted all child writes. Maybe the old event was a leaf node\ncomplete=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache));if(complete.isLeafNode()){newEventCache=viewProcessor.filter.updateFullNode(newEventCache,complete,accumulator);}}}complete=viewCache.serverCache.isFullyInitialized()||writeTreeRefShadowingWrite(writesCache,newEmptyPath())!=null;return viewCacheUpdateEventSnap(viewCache,newEventCache,complete,viewProcessor.filter.filtersNodes());}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A view represents a specific location and query that has 1 or more event registrations.\r\n *\r\n * It does several things:\r\n *  - Maintains the list of event registrations for this location/query.\r\n *  - Maintains a cache of the data visible for this location/query.\r\n *  - Applies new operations (via applyOperation), updates the cache, and based on the event\r\n *    registrations returns the set of events to be raised.\r\n */class View{constructor(query_,initialViewCache){this.query_=query_;this.eventRegistrations_=[];const params=this.query_._queryParams;const indexFilter=new IndexedFilter(params.getIndex());const filter=queryParamsGetNodeFilter(params);this.processor_=newViewProcessor(filter);const initialServerCache=initialViewCache.serverCache;const initialEventCache=initialViewCache.eventCache;// Don't filter server node with other filter than index, wait for tagged listen\nconst serverSnap=indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE,initialServerCache.getNode(),null);const eventSnap=filter.updateFullNode(ChildrenNode.EMPTY_NODE,initialEventCache.getNode(),null);const newServerCache=new CacheNode(serverSnap,initialServerCache.isFullyInitialized(),indexFilter.filtersNodes());const newEventCache=new CacheNode(eventSnap,initialEventCache.isFullyInitialized(),filter.filtersNodes());this.viewCache_=newViewCache(newEventCache,newServerCache);this.eventGenerator_=new EventGenerator(this.query_);}get query(){return this.query_;}}function viewGetServerCache(view){return view.viewCache_.serverCache.getNode();}function viewGetCompleteNode(view){return viewCacheGetCompleteEventSnap(view.viewCache_);}function viewGetCompleteServerCache(view,path){const cache=viewCacheGetCompleteServerSnap(view.viewCache_);if(cache){// If this isn't a \"loadsAllData\" view, then cache isn't actually a complete cache and\n// we need to see if it contains the child we're interested in.\nif(view.query._queryParams.loadsAllData()||!pathIsEmpty(path)&&!cache.getImmediateChild(pathGetFront(path)).isEmpty()){return cache.getChild(path);}}return null;}function viewIsEmpty(view){return view.eventRegistrations_.length===0;}function viewAddEventRegistration(view,eventRegistration){view.eventRegistrations_.push(eventRegistration);}/**\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns Cancel events, if cancelError was provided.\r\n */function viewRemoveEventRegistration(view,eventRegistration,cancelError){const cancelEvents=[];if(cancelError){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventRegistration==null,'A cancel should cancel all event registrations.');const path=view.query._path;view.eventRegistrations_.forEach(registration=>{const maybeEvent=registration.createCancelEvent(cancelError,path);if(maybeEvent){cancelEvents.push(maybeEvent);}});}if(eventRegistration){let remaining=[];for(let i=0;i<view.eventRegistrations_.length;++i){const existing=view.eventRegistrations_[i];if(!existing.matches(eventRegistration)){remaining.push(existing);}else if(eventRegistration.hasAnyCallback()){// We're removing just this one\nremaining=remaining.concat(view.eventRegistrations_.slice(i+1));break;}}view.eventRegistrations_=remaining;}else{view.eventRegistrations_=[];}return cancelEvents;}/**\r\n * Applies the given Operation, updates our cache, and returns the appropriate events.\r\n */function viewApplyOperation(view,operation,writesCache,completeServerCache){if(operation.type===OperationType.MERGE&&operation.source.queryId!==null){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCacheGetCompleteServerSnap(view.viewCache_),'We should always have a full cache before handling merges');(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCacheGetCompleteEventSnap(view.viewCache_),'Missing event cache, even though we have a server cache');}const oldViewCache=view.viewCache_;const result=viewProcessorApplyOperation(view.processor_,oldViewCache,operation,writesCache,completeServerCache);viewProcessorAssertIndexed(view.processor_,result.viewCache);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(result.viewCache.serverCache.isFullyInitialized()||!oldViewCache.serverCache.isFullyInitialized(),'Once a server snap is complete, it should never go back');view.viewCache_=result.viewCache;return viewGenerateEventsForChanges_(view,result.changes,result.viewCache.eventCache.getNode(),null);}function viewGetInitialEvents(view,registration){const eventSnap=view.viewCache_.eventCache;const initialChanges=[];if(!eventSnap.getNode().isLeafNode()){const eventNode=eventSnap.getNode();eventNode.forEachChild(PRIORITY_INDEX,(key,childNode)=>{initialChanges.push(changeChildAdded(key,childNode));});}if(eventSnap.isFullyInitialized()){initialChanges.push(changeValue(eventSnap.getNode()));}return viewGenerateEventsForChanges_(view,initialChanges,eventSnap.getNode(),registration);}function viewGenerateEventsForChanges_(view,changes,eventCache,eventRegistration){const registrations=eventRegistration?[eventRegistration]:view.eventRegistrations_;return eventGeneratorGenerateEventsForChanges(view.eventGenerator_,changes,eventCache,registrations);}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */let referenceConstructor$1;/**\r\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\r\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\r\n * and user writes (set, transaction, update).\r\n *\r\n * It's responsible for:\r\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\r\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\r\n *    applyUserOverwrite, etc.)\r\n */class SyncPoint{constructor(){/**\r\n         * The Views being tracked at this location in the tree, stored as a map where the key is a\r\n         * queryId and the value is the View for that query.\r\n         *\r\n         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\r\n         */this.views=new Map();}}function syncPointSetReferenceConstructor(val){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!referenceConstructor$1,'__referenceConstructor has already been defined');referenceConstructor$1=val;}function syncPointGetReferenceConstructor(){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(referenceConstructor$1,'Reference.ts has not been loaded');return referenceConstructor$1;}function syncPointIsEmpty(syncPoint){return syncPoint.views.size===0;}function syncPointApplyOperation(syncPoint,operation,writesCache,optCompleteServerCache){const queryId=operation.source.queryId;if(queryId!==null){const view=syncPoint.views.get(queryId);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(view!=null,'SyncTree gave us an op for an invalid query.');return viewApplyOperation(view,operation,writesCache,optCompleteServerCache);}else{let events=[];for(const view of syncPoint.views.values()){events=events.concat(viewApplyOperation(view,operation,writesCache,optCompleteServerCache));}return events;}}/**\r\n * Get a view for the specified query.\r\n *\r\n * @param query - The query to return a view for\r\n * @param writesCache\r\n * @param serverCache\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */function syncPointGetView(syncPoint,query,writesCache,serverCache,serverCacheComplete){const queryId=query._queryIdentifier;const view=syncPoint.views.get(queryId);if(!view){// TODO: make writesCache take flag for complete server node\nlet eventCache=writeTreeRefCalcCompleteEventCache(writesCache,serverCacheComplete?serverCache:null);let eventCacheComplete=false;if(eventCache){eventCacheComplete=true;}else if(serverCache instanceof ChildrenNode){eventCache=writeTreeRefCalcCompleteEventChildren(writesCache,serverCache);eventCacheComplete=false;}else{eventCache=ChildrenNode.EMPTY_NODE;eventCacheComplete=false;}const viewCache=newViewCache(new CacheNode(eventCache,eventCacheComplete,false),new CacheNode(serverCache,serverCacheComplete,false));return new View(query,viewCache);}return view;}/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @param query\r\n * @param eventRegistration\r\n * @param writesCache\r\n * @param serverCache - Complete server cache, if we have it.\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */function syncPointAddEventRegistration(syncPoint,query,eventRegistration,writesCache,serverCache,serverCacheComplete){const view=syncPointGetView(syncPoint,query,writesCache,serverCache,serverCacheComplete);if(!syncPoint.views.has(query._queryIdentifier)){syncPoint.views.set(query._queryIdentifier,view);}// This is guaranteed to exist now, we just created anything that was missing\nviewAddEventRegistration(view,eventRegistration);return viewGetInitialEvents(view,eventRegistration);}/**\r\n * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\r\n *\r\n * If query is the default query, we'll check all views for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\r\n *\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns removed queries and any cancel events\r\n */function syncPointRemoveEventRegistration(syncPoint,query,eventRegistration,cancelError){const queryId=query._queryIdentifier;const removed=[];let cancelEvents=[];const hadCompleteView=syncPointHasCompleteView(syncPoint);if(queryId==='default'){// When you do ref.off(...), we search all views for the registration to remove.\nfor(const[viewQueryId,view]of syncPoint.views.entries()){cancelEvents=cancelEvents.concat(viewRemoveEventRegistration(view,eventRegistration,cancelError));if(viewIsEmpty(view)){syncPoint.views.delete(viewQueryId);// We'll deal with complete views later.\nif(!view.query._queryParams.loadsAllData()){removed.push(view.query);}}}}else{// remove the callback from the specific view.\nconst view=syncPoint.views.get(queryId);if(view){cancelEvents=cancelEvents.concat(viewRemoveEventRegistration(view,eventRegistration,cancelError));if(viewIsEmpty(view)){syncPoint.views.delete(queryId);// We'll deal with complete views later.\nif(!view.query._queryParams.loadsAllData()){removed.push(view.query);}}}}if(hadCompleteView&&!syncPointHasCompleteView(syncPoint)){// We removed our last complete view.\nremoved.push(new(syncPointGetReferenceConstructor())(query._repo,query._path));}return{removed,events:cancelEvents};}function syncPointGetQueryViews(syncPoint){const result=[];for(const view of syncPoint.views.values()){if(!view.query._queryParams.loadsAllData()){result.push(view);}}return result;}/**\r\n * @param path - The path to the desired complete snapshot\r\n * @returns A complete cache, if it exists\r\n */function syncPointGetCompleteServerCache(syncPoint,path){let serverCache=null;for(const view of syncPoint.views.values()){serverCache=serverCache||viewGetCompleteServerCache(view,path);}return serverCache;}function syncPointViewForQuery(syncPoint,query){const params=query._queryParams;if(params.loadsAllData()){return syncPointGetCompleteView(syncPoint);}else{const queryId=query._queryIdentifier;return syncPoint.views.get(queryId);}}function syncPointViewExistsForQuery(syncPoint,query){return syncPointViewForQuery(syncPoint,query)!=null;}function syncPointHasCompleteView(syncPoint){return syncPointGetCompleteView(syncPoint)!=null;}function syncPointGetCompleteView(syncPoint){for(const view of syncPoint.views.values()){if(view.query._queryParams.loadsAllData()){return view;}}return null;}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */let referenceConstructor;function syncTreeSetReferenceConstructor(val){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!referenceConstructor,'__referenceConstructor has already been defined');referenceConstructor=val;}function syncTreeGetReferenceConstructor(){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(referenceConstructor,'Reference.ts has not been loaded');return referenceConstructor;}/**\r\n * Static tracker for next query tag.\r\n */let syncTreeNextQueryTag_=1;/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n */class SyncTree{/**\r\n     * @param listenProvider_ - Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */constructor(listenProvider_){this.listenProvider_=listenProvider_;/**\r\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n         */this.syncPointTree_=new ImmutableTree(null);/**\r\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n         */this.pendingWriteTree_=newWriteTree();this.tagToQueryMap=new Map();this.queryToTagMap=new Map();}}/**\r\n * Apply the data changes for a user-generated set() or transaction() call.\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeApplyUserOverwrite(syncTree,path,newData,writeId,visible){// Record pending write.\nwriteTreeAddOverwrite(syncTree.pendingWriteTree_,path,newData,writeId,visible);if(!visible){return[];}else{return syncTreeApplyOperationToSyncPoints_(syncTree,new Overwrite(newOperationSourceUser(),path,newData));}}/**\r\n * Apply the data from a user-generated update() call\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeApplyUserMerge(syncTree,path,changedChildren,writeId){// Record pending merge.\nwriteTreeAddMerge(syncTree.pendingWriteTree_,path,changedChildren,writeId);const changeTree=ImmutableTree.fromObject(changedChildren);return syncTreeApplyOperationToSyncPoints_(syncTree,new Merge(newOperationSourceUser(),path,changeTree));}/**\r\n * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n *\r\n * @param revert - True if the given write failed and needs to be reverted\r\n * @returns Events to raise.\r\n */function syncTreeAckUserWrite(syncTree,writeId,revert=false){const write=writeTreeGetWrite(syncTree.pendingWriteTree_,writeId);const needToReevaluate=writeTreeRemoveWrite(syncTree.pendingWriteTree_,writeId);if(!needToReevaluate){return[];}else{let affectedTree=new ImmutableTree(null);if(write.snap!=null){// overwrite\naffectedTree=affectedTree.set(newEmptyPath(),true);}else{each(write.children,pathString=>{affectedTree=affectedTree.set(new Path(pathString),true);});}return syncTreeApplyOperationToSyncPoints_(syncTree,new AckUserWrite(write.path,affectedTree,revert));}}/**\r\n * Apply new server data for the specified path..\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeApplyServerOverwrite(syncTree,path,newData){return syncTreeApplyOperationToSyncPoints_(syncTree,new Overwrite(newOperationSourceServer(),path,newData));}/**\r\n * Apply new server data to be merged in at the specified path.\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeApplyServerMerge(syncTree,path,changedChildren){const changeTree=ImmutableTree.fromObject(changedChildren);return syncTreeApplyOperationToSyncPoints_(syncTree,new Merge(newOperationSourceServer(),path,changeTree));}/**\r\n * Apply a listen complete for a query\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeApplyListenComplete(syncTree,path){return syncTreeApplyOperationToSyncPoints_(syncTree,new ListenComplete(newOperationSourceServer(),path));}/**\r\n * Apply a listen complete for a tagged query\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeApplyTaggedListenComplete(syncTree,path,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const op=new ListenComplete(newOperationSourceServerTaggedQuery(queryId),relativePath);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op);}else{// We've already removed the query. No big deal, ignore the update\nreturn[];}}/**\r\n * Remove event callback(s).\r\n *\r\n * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n *\r\n * @param eventRegistration - If null, all callbacks are removed.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns Cancel events, if cancelError was provided.\r\n */function syncTreeRemoveEventRegistration(syncTree,query,eventRegistration,cancelError){// Find the syncPoint first. Then deal with whether or not it has matching listeners\nconst path=query._path;const maybeSyncPoint=syncTree.syncPointTree_.get(path);let cancelEvents=[];// A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n// other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n// not loadsAllData().\nif(maybeSyncPoint&&(query._queryIdentifier==='default'||syncPointViewExistsForQuery(maybeSyncPoint,query))){const removedAndEvents=syncPointRemoveEventRegistration(maybeSyncPoint,query,eventRegistration,cancelError);if(syncPointIsEmpty(maybeSyncPoint)){syncTree.syncPointTree_=syncTree.syncPointTree_.remove(path);}const removed=removedAndEvents.removed;cancelEvents=removedAndEvents.events;// We may have just removed one of many listeners and can short-circuit this whole process\n// We may also not have removed a default listener, in which case all of the descendant listeners should already be\n// properly set up.\n//\n// Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n// queryId === 'default'\nconst removingDefault=-1!==removed.findIndex(query=>{return query._queryParams.loadsAllData();});const covered=syncTree.syncPointTree_.findOnPath(path,(relativePath,parentSyncPoint)=>syncPointHasCompleteView(parentSyncPoint));if(removingDefault&&!covered){const subtree=syncTree.syncPointTree_.subtree(path);// There are potentially child listeners. Determine what if any listens we need to send before executing the\n// removal\nif(!subtree.isEmpty()){// We need to fold over our subtree and collect the listeners to send\nconst newViews=syncTreeCollectDistinctViewsForSubTree_(subtree);// Ok, we've collected all the listens we need. Set them up.\nfor(let i=0;i<newViews.length;++i){const view=newViews[i],newQuery=view.query;const listener=syncTreeCreateListenerForView_(syncTree,view);syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery),syncTreeTagForQuery_(syncTree,newQuery),listener.hashFn,listener.onComplete);}}}// If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n// The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n// Also, note that if we have a cancelError, it's already been removed at the provider level.\nif(!covered&&removed.length>0&&!cancelError){// If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n// default. Otherwise, we need to iterate through and cancel each individual query\nif(removingDefault){// We don't tag default listeners\nconst defaultTag=null;syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query),defaultTag);}else{removed.forEach(queryToRemove=>{const tagToRemove=syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove),tagToRemove);});}}// Now, clear all of the tags we're tracking for the removed listens\nsyncTreeRemoveTags_(syncTree,removed);}return cancelEvents;}/**\r\n * Apply new server data for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeApplyTaggedQueryOverwrite(syncTree,path,snap,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey!=null){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const op=new Overwrite(newOperationSourceServerTaggedQuery(queryId),relativePath,snap);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op);}else{// Query must have been removed already\nreturn[];}}/**\r\n * Apply server data to be merged in for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeApplyTaggedQueryMerge(syncTree,path,changedChildren,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const changeTree=ImmutableTree.fromObject(changedChildren);const op=new Merge(newOperationSourceServerTaggedQuery(queryId),relativePath,changeTree);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op);}else{// We've already removed the query. No big deal, ignore the update\nreturn[];}}/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @returns Events to raise.\r\n */function syncTreeAddEventRegistration(syncTree,query,eventRegistration){const path=query._path;let serverCache=null;let foundAncestorDefaultView=false;// Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n// Consider optimizing this once there's a better understanding of what actual behavior will be.\nsyncTree.syncPointTree_.foreachOnPath(path,(pathToSyncPoint,sp)=>{const relativePath=newRelativePath(pathToSyncPoint,path);serverCache=serverCache||syncPointGetCompleteServerCache(sp,relativePath);foundAncestorDefaultView=foundAncestorDefaultView||syncPointHasCompleteView(sp);});let syncPoint=syncTree.syncPointTree_.get(path);if(!syncPoint){syncPoint=new SyncPoint();syncTree.syncPointTree_=syncTree.syncPointTree_.set(path,syncPoint);}else{foundAncestorDefaultView=foundAncestorDefaultView||syncPointHasCompleteView(syncPoint);serverCache=serverCache||syncPointGetCompleteServerCache(syncPoint,newEmptyPath());}let serverCacheComplete;if(serverCache!=null){serverCacheComplete=true;}else{serverCacheComplete=false;serverCache=ChildrenNode.EMPTY_NODE;const subtree=syncTree.syncPointTree_.subtree(path);subtree.foreachChild((childName,childSyncPoint)=>{const completeCache=syncPointGetCompleteServerCache(childSyncPoint,newEmptyPath());if(completeCache){serverCache=serverCache.updateImmediateChild(childName,completeCache);}});}const viewAlreadyExists=syncPointViewExistsForQuery(syncPoint,query);if(!viewAlreadyExists&&!query._queryParams.loadsAllData()){// We need to track a tag for this query\nconst queryKey=syncTreeMakeQueryKey_(query);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!syncTree.queryToTagMap.has(queryKey),'View does not exist, but we have a tag');const tag=syncTreeGetNextQueryTag_();syncTree.queryToTagMap.set(queryKey,tag);syncTree.tagToQueryMap.set(tag,queryKey);}const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,path);let events=syncPointAddEventRegistration(syncPoint,query,eventRegistration,writesCache,serverCache,serverCacheComplete);if(!viewAlreadyExists&&!foundAncestorDefaultView){const view=syncPointViewForQuery(syncPoint,query);events=events.concat(syncTreeSetupListener_(syncTree,query,view));}return events;}/**\r\n * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n *\r\n * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n *\r\n * @param path - The path to the data we want\r\n * @param writeIdsToExclude - A specific set to be excluded\r\n */function syncTreeCalcCompleteEventCache(syncTree,path,writeIdsToExclude){const includeHiddenSets=true;const writeTree=syncTree.pendingWriteTree_;const serverCache=syncTree.syncPointTree_.findOnPath(path,(pathSoFar,syncPoint)=>{const relativePath=newRelativePath(pathSoFar,path);const serverCache=syncPointGetCompleteServerCache(syncPoint,relativePath);if(serverCache){return serverCache;}});return writeTreeCalcCompleteEventCache(writeTree,path,serverCache,writeIdsToExclude,includeHiddenSets);}function syncTreeGetServerValue(syncTree,query){const path=query._path;let serverCache=null;// Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n// Consider optimizing this once there's a better understanding of what actual behavior will be.\nsyncTree.syncPointTree_.foreachOnPath(path,(pathToSyncPoint,sp)=>{const relativePath=newRelativePath(pathToSyncPoint,path);serverCache=serverCache||syncPointGetCompleteServerCache(sp,relativePath);});let syncPoint=syncTree.syncPointTree_.get(path);if(!syncPoint){syncPoint=new SyncPoint();syncTree.syncPointTree_=syncTree.syncPointTree_.set(path,syncPoint);}else{serverCache=serverCache||syncPointGetCompleteServerCache(syncPoint,newEmptyPath());}const serverCacheComplete=serverCache!=null;const serverCacheNode=serverCacheComplete?new CacheNode(serverCache,true,false):null;const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,query._path);const view=syncPointGetView(syncPoint,query,writesCache,serverCacheComplete?serverCacheNode.getNode():ChildrenNode.EMPTY_NODE,serverCacheComplete);return viewGetCompleteNode(view);}/**\r\n * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\r\n *\r\n * NOTES:\r\n * - Descendant SyncPoints will be visited first (since we raise events depth-first).\r\n *\r\n * - We call applyOperation() on each SyncPoint passing three things:\r\n *   1. A version of the Operation that has been made relative to the SyncPoint location.\r\n *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\r\n *   3. A snapshot Node with cached server data, if we have it.\r\n *\r\n * - We concatenate all of the events returned by each SyncPoint and return the result.\r\n */function syncTreeApplyOperationToSyncPoints_(syncTree,operation){return syncTreeApplyOperationHelper_(operation,syncTree.syncPointTree_,/*serverCache=*/null,writeTreeChildWrites(syncTree.pendingWriteTree_,newEmptyPath()));}/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */function syncTreeApplyOperationHelper_(operation,syncPointTree,serverCache,writesCache){if(pathIsEmpty(operation.path)){return syncTreeApplyOperationDescendantsHelper_(operation,syncPointTree,serverCache,writesCache);}else{const syncPoint=syncPointTree.get(newEmptyPath());// If we don't have cached server data, see if we can get it from this SyncPoint.\nif(serverCache==null&&syncPoint!=null){serverCache=syncPointGetCompleteServerCache(syncPoint,newEmptyPath());}let events=[];const childName=pathGetFront(operation.path);const childOperation=operation.operationForChild(childName);const childTree=syncPointTree.children.get(childName);if(childTree&&childOperation){const childServerCache=serverCache?serverCache.getImmediateChild(childName):null;const childWritesCache=writeTreeRefChild(writesCache,childName);events=events.concat(syncTreeApplyOperationHelper_(childOperation,childTree,childServerCache,childWritesCache));}if(syncPoint){events=events.concat(syncPointApplyOperation(syncPoint,operation,writesCache,serverCache));}return events;}}/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */function syncTreeApplyOperationDescendantsHelper_(operation,syncPointTree,serverCache,writesCache){const syncPoint=syncPointTree.get(newEmptyPath());// If we don't have cached server data, see if we can get it from this SyncPoint.\nif(serverCache==null&&syncPoint!=null){serverCache=syncPointGetCompleteServerCache(syncPoint,newEmptyPath());}let events=[];syncPointTree.children.inorderTraversal((childName,childTree)=>{const childServerCache=serverCache?serverCache.getImmediateChild(childName):null;const childWritesCache=writeTreeRefChild(writesCache,childName);const childOperation=operation.operationForChild(childName);if(childOperation){events=events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation,childTree,childServerCache,childWritesCache));}});if(syncPoint){events=events.concat(syncPointApplyOperation(syncPoint,operation,writesCache,serverCache));}return events;}function syncTreeCreateListenerForView_(syncTree,view){const query=view.query;const tag=syncTreeTagForQuery_(syncTree,query);return{hashFn:()=>{const cache=viewGetServerCache(view)||ChildrenNode.EMPTY_NODE;return cache.hash();},onComplete:status=>{if(status==='ok'){if(tag){return syncTreeApplyTaggedListenComplete(syncTree,query._path,tag);}else{return syncTreeApplyListenComplete(syncTree,query._path);}}else{// If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n// Note that this may need to be scoped to just this listener if we change permissions on filtered children\nconst error=errorForServerCode(status,query);return syncTreeRemoveEventRegistration(syncTree,query,/*eventRegistration*/null,error);}}};}/**\r\n * Return the tag associated with the given query.\r\n */function syncTreeTagForQuery_(syncTree,query){const queryKey=syncTreeMakeQueryKey_(query);return syncTree.queryToTagMap.get(queryKey);}/**\r\n * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\r\n */function syncTreeMakeQueryKey_(query){return query._path.toString()+'$'+query._queryIdentifier;}/**\r\n * Return the query associated with the given tag, if we have one\r\n */function syncTreeQueryKeyForTag_(syncTree,tag){return syncTree.tagToQueryMap.get(tag);}/**\r\n * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\r\n */function syncTreeParseQueryKey_(queryKey){const splitIndex=queryKey.indexOf('$');(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(splitIndex!==-1&&splitIndex<queryKey.length-1,'Bad queryKey.');return{queryId:queryKey.substr(splitIndex+1),path:new Path(queryKey.substr(0,splitIndex))};}/**\r\n * A helper method to apply tagged operations\r\n */function syncTreeApplyTaggedOperation_(syncTree,queryPath,operation){const syncPoint=syncTree.syncPointTree_.get(queryPath);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(syncPoint,\"Missing sync point for query tag that we're tracking\");const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,queryPath);return syncPointApplyOperation(syncPoint,operation,writesCache,null);}/**\r\n * This collapses multiple unfiltered views into a single view, since we only need a single\r\n * listener for them.\r\n */function syncTreeCollectDistinctViewsForSubTree_(subtree){return subtree.fold((relativePath,maybeChildSyncPoint,childMap)=>{if(maybeChildSyncPoint&&syncPointHasCompleteView(maybeChildSyncPoint)){const completeView=syncPointGetCompleteView(maybeChildSyncPoint);return[completeView];}else{// No complete view here, flatten any deeper listens into an array\nlet views=[];if(maybeChildSyncPoint){views=syncPointGetQueryViews(maybeChildSyncPoint);}each(childMap,(_key,childViews)=>{views=views.concat(childViews);});return views;}});}/**\r\n * Normalizes a query to a query we send the server for listening\r\n *\r\n * @returns The normalized query\r\n */function syncTreeQueryForListening_(query){if(query._queryParams.loadsAllData()&&!query._queryParams.isDefault()){// We treat queries that load all data as default queries\n// Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n// from Query\nreturn new(syncTreeGetReferenceConstructor())(query._repo,query._path);}else{return query;}}function syncTreeRemoveTags_(syncTree,queries){for(let j=0;j<queries.length;++j){const removedQuery=queries[j];if(!removedQuery._queryParams.loadsAllData()){// We should have a tag for this\nconst removedQueryKey=syncTreeMakeQueryKey_(removedQuery);const removedQueryTag=syncTree.queryToTagMap.get(removedQueryKey);syncTree.queryToTagMap.delete(removedQueryKey);syncTree.tagToQueryMap.delete(removedQueryTag);}}}/**\r\n * Static accessor for query tags.\r\n */function syncTreeGetNextQueryTag_(){return syncTreeNextQueryTag_++;}/**\r\n * For a given new listen, manage the de-duplication of outstanding subscriptions.\r\n *\r\n * @returns This method can return events to support synchronous data sources\r\n */function syncTreeSetupListener_(syncTree,query,view){const path=query._path;const tag=syncTreeTagForQuery_(syncTree,query);const listener=syncTreeCreateListenerForView_(syncTree,view);const events=syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query),tag,listener.hashFn,listener.onComplete);const subtree=syncTree.syncPointTree_.subtree(path);// The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n// may need to shadow other listens as well.\nif(tag){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!syncPointHasCompleteView(subtree.value),\"If we're adding a query, it shouldn't be shadowed\");}else{// Shadow everything at or below this location, this is a default listener.\nconst queriesToStop=subtree.fold((relativePath,maybeChildSyncPoint,childMap)=>{if(!pathIsEmpty(relativePath)&&maybeChildSyncPoint&&syncPointHasCompleteView(maybeChildSyncPoint)){return[syncPointGetCompleteView(maybeChildSyncPoint).query];}else{// No default listener here, flatten any deeper queries into an array\nlet queries=[];if(maybeChildSyncPoint){queries=queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view=>view.query));}each(childMap,(_key,childQueries)=>{queries=queries.concat(childQueries);});return queries;}});for(let i=0;i<queriesToStop.length;++i){const queryToStop=queriesToStop[i];syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop),syncTreeTagForQuery_(syncTree,queryToStop));}}return events;}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */class ExistingValueProvider{constructor(node_){this.node_=node_;}getImmediateChild(childName){const child=this.node_.getImmediateChild(childName);return new ExistingValueProvider(child);}node(){return this.node_;}}class DeferredValueProvider{constructor(syncTree,path){this.syncTree_=syncTree;this.path_=path;}getImmediateChild(childName){const childPath=pathChild(this.path_,childName);return new DeferredValueProvider(this.syncTree_,childPath);}node(){return syncTreeCalcCompleteEventCache(this.syncTree_,this.path_);}}/**\r\n * Generate placeholders for deferred values.\r\n */const generateWithValues=function(values){values=values||{};values['timestamp']=values['timestamp']||new Date().getTime();return values;};/**\r\n * Value to use when firing local events. When writing server values, fire\r\n * local events with an approximate value, otherwise return value as-is.\r\n */const resolveDeferredLeafValue=function(value,existingVal,serverValues){if(!value||typeof value!=='object'){return value;}(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)('.sv'in value,'Unexpected leaf node or priority contents');if(typeof value['.sv']==='string'){return resolveScalarDeferredValue(value['.sv'],existingVal,serverValues);}else if(typeof value['.sv']==='object'){return resolveComplexDeferredValue(value['.sv'],existingVal);}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false,'Unexpected server value: '+JSON.stringify(value,null,2));}};const resolveScalarDeferredValue=function(op,existing,serverValues){switch(op){case'timestamp':return serverValues['timestamp'];default:(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false,'Unexpected server value: '+op);}};const resolveComplexDeferredValue=function(op,existing,unused){if(!op.hasOwnProperty('increment')){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false,'Unexpected server value: '+JSON.stringify(op,null,2));}const delta=op['increment'];if(typeof delta!=='number'){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false,'Unexpected increment value: '+delta);}const existingNode=existing.node();(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(existingNode!==null&&typeof existingNode!=='undefined','Expected ChildrenNode.EMPTY_NODE for nulls');// Incrementing a non-number sets the value to the incremented amount\nif(!existingNode.isLeafNode()){return delta;}const leaf=existingNode;const existingVal=leaf.getValue();if(typeof existingVal!=='number'){return delta;}// No need to do over/underflow arithmetic here because JS only handles floats under the covers\nreturn existingVal+delta;};/**\r\n * Recursively replace all deferred values and priorities in the tree with the\r\n * specified generated replacement values.\r\n * @param path - path to which write is relative\r\n * @param node - new data written at path\r\n * @param syncTree - current data\r\n */const resolveDeferredValueTree=function(path,node,syncTree,serverValues){return resolveDeferredValue(node,new DeferredValueProvider(syncTree,path),serverValues);};/**\r\n * Recursively replace all deferred values and priorities in the node with the\r\n * specified generated replacement values.  If there are no server values in the node,\r\n * it'll be returned as-is.\r\n */const resolveDeferredValueSnapshot=function(node,existing,serverValues){return resolveDeferredValue(node,new ExistingValueProvider(existing),serverValues);};function resolveDeferredValue(node,existingVal,serverValues){const rawPri=node.getPriority().val();const priority=resolveDeferredLeafValue(rawPri,existingVal.getImmediateChild('.priority'),serverValues);let newNode;if(node.isLeafNode()){const leafNode=node;const value=resolveDeferredLeafValue(leafNode.getValue(),existingVal,serverValues);if(value!==leafNode.getValue()||priority!==leafNode.getPriority().val()){return new LeafNode(value,nodeFromJSON(priority));}else{return node;}}else{const childrenNode=node;newNode=childrenNode;if(priority!==childrenNode.getPriority().val()){newNode=newNode.updatePriority(new LeafNode(priority));}childrenNode.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{const newChildNode=resolveDeferredValue(childNode,existingVal.getImmediateChild(childName),serverValues);if(newChildNode!==childNode){newNode=newNode.updateImmediateChild(childName,newChildNode);}});return newNode;}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */class Tree{/**\r\n     * @param name - Optional name of the node.\r\n     * @param parent - Optional parent node.\r\n     * @param node - Optional node to wrap.\r\n     */constructor(name='',parent=null,node={children:{},childCount:0}){this.name=name;this.parent=parent;this.node=node;}}/**\r\n * Returns a sub-Tree for the given path.\r\n *\r\n * @param pathObj - Path to look up.\r\n * @returns Tree for path.\r\n */function treeSubTree(tree,pathObj){// TODO: Require pathObj to be Path?\nlet path=pathObj instanceof Path?pathObj:new Path(pathObj);let child=tree,next=pathGetFront(path);while(next!==null){const childNode=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(child.node.children,next)||{children:{},childCount:0};child=new Tree(next,child,childNode);path=pathPopFront(path);next=pathGetFront(path);}return child;}/**\r\n * Returns the data associated with this tree node.\r\n *\r\n * @returns The data or null if no data exists.\r\n */function treeGetValue(tree){return tree.node.value;}/**\r\n * Sets data to this tree node.\r\n *\r\n * @param value - Value to set.\r\n */function treeSetValue(tree,value){tree.node.value=value;treeUpdateParents(tree);}/**\r\n * @returns Whether the tree has any children.\r\n */function treeHasChildren(tree){return tree.node.childCount>0;}/**\r\n * @returns Whethe rthe tree is empty (no value or children).\r\n */function treeIsEmpty(tree){return treeGetValue(tree)===undefined&&!treeHasChildren(tree);}/**\r\n * Calls action for each child of this tree node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */function treeForEachChild(tree,action){each(tree.node.children,(child,childTree)=>{action(new Tree(child,tree,childTree));});}/**\r\n * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n *\r\n * @param action - Action to be called for each child.\r\n * @param includeSelf - Whether to call action on this node as well. Defaults to\r\n *   false.\r\n * @param childrenFirst - Whether to call action on children before calling it on\r\n *   parent.\r\n */function treeForEachDescendant(tree,action,includeSelf,childrenFirst){if(includeSelf&&!childrenFirst){action(tree);}treeForEachChild(tree,child=>{treeForEachDescendant(child,action,true,childrenFirst);});if(includeSelf&&childrenFirst){action(tree);}}/**\r\n * Calls action on each ancestor node.\r\n *\r\n * @param action - Action to be called on each parent; return\r\n *   true to abort.\r\n * @param includeSelf - Whether to call action on this node as well.\r\n * @returns true if the action callback returned true.\r\n */function treeForEachAncestor(tree,action,includeSelf){let node=includeSelf?tree:tree.parent;while(node!==null){if(action(node)){return true;}node=node.parent;}return false;}/**\r\n * @returns The path of this tree node, as a Path.\r\n */function treeGetPath(tree){return new Path(tree.parent===null?tree.name:treeGetPath(tree.parent)+'/'+tree.name);}/**\r\n * Adds or removes this child from its parent based on whether it's empty or not.\r\n */function treeUpdateParents(tree){if(tree.parent!==null){treeUpdateChild(tree.parent,tree.name,tree);}}/**\r\n * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n *\r\n * @param childName - The name of the child to update.\r\n * @param child - The child to update.\r\n */function treeUpdateChild(tree,childName,child){const childEmpty=treeIsEmpty(child);const childExists=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(tree.node.children,childName);if(childEmpty&&childExists){delete tree.node.children[childName];tree.node.childCount--;treeUpdateParents(tree);}else if(!childEmpty&&!childExists){tree.node.children[childName]=child.node;tree.node.childCount++;treeUpdateParents(tree);}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * True for invalid Firebase keys\r\n */const INVALID_KEY_REGEX_=/[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n */const INVALID_PATH_REGEX_=/[\\[\\].#$\\u0000-\\u001F\\u007F]/;/**\r\n * Maximum number of characters to allow in leaf value\r\n */const MAX_LEAF_SIZE_=10*1024*1024;const isValidKey=function(key){return typeof key==='string'&&key.length!==0&&!INVALID_KEY_REGEX_.test(key);};const isValidPathString=function(pathString){return typeof pathString==='string'&&pathString.length!==0&&!INVALID_PATH_REGEX_.test(pathString);};const isValidRootPathString=function(pathString){if(pathString){// Allow '/.info/' at the beginning.\npathString=pathString.replace(/^\\/*\\.info(\\/|$)/,'/');}return isValidPathString(pathString);};const isValidPriority=function(priority){return priority===null||typeof priority==='string'||typeof priority==='number'&&!isInvalidJSONNumber(priority)||priority&&typeof priority==='object'&&// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(priority,'.sv');};/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n */const validateFirebaseDataArg=function(fnName,value,path,optional){if(optional&&value===undefined){return;}validateFirebaseData((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName,'value'),value,path);};/**\r\n * Validate a data object client-side before sending to server.\r\n */const validateFirebaseData=function(errorPrefix,data,path_){const path=path_ instanceof Path?new ValidationPath(path_,errorPrefix):path_;if(data===undefined){throw new Error(errorPrefix+'contains undefined '+validationPathToErrorString(path));}if(typeof data==='function'){throw new Error(errorPrefix+'contains a function '+validationPathToErrorString(path)+' with contents = '+data.toString());}if(isInvalidJSONNumber(data)){throw new Error(errorPrefix+'contains '+data.toString()+' '+validationPathToErrorString(path));}// Check max leaf size, but try to avoid the utf8 conversion if we can.\nif(typeof data==='string'&&data.length>MAX_LEAF_SIZE_/3&&(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(data)>MAX_LEAF_SIZE_){throw new Error(errorPrefix+'contains a string greater than '+MAX_LEAF_SIZE_+' utf8 bytes '+validationPathToErrorString(path)+\" ('\"+data.substring(0,50)+\"...')\");}// TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n// to save extra walking of large objects.\nif(data&&typeof data==='object'){let hasDotValue=false;let hasActualChild=false;each(data,(key,value)=>{if(key==='.value'){hasDotValue=true;}else if(key!=='.priority'&&key!=='.sv'){hasActualChild=true;if(!isValidKey(key)){throw new Error(errorPrefix+' contains an invalid key ('+key+') '+validationPathToErrorString(path)+'.  Keys must be non-empty strings '+'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');}}validationPathPush(path,key);validateFirebaseData(errorPrefix,value,path);validationPathPop(path);});if(hasDotValue&&hasActualChild){throw new Error(errorPrefix+' contains \".value\" child '+validationPathToErrorString(path)+' in addition to actual children.');}}};/**\r\n * Pre-validate paths passed in the firebase function.\r\n */const validateFirebaseMergePaths=function(errorPrefix,mergePaths){let i,curPath;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];const keys=pathSlice(curPath);for(let j=0;j<keys.length;j++){if(keys[j]==='.priority'&&j===keys.length-1);else if(!isValidKey(keys[j])){throw new Error(errorPrefix+'contains an invalid key ('+keys[j]+') in path '+curPath.toString()+'. Keys must be non-empty strings '+'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');}}}// Check that update keys are not descendants of each other.\n// We rely on the property that sorting guarantees that ancestors come\n// right before descendants.\nmergePaths.sort(pathCompare);let prevPath=null;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];if(prevPath!==null&&pathContains(prevPath,curPath)){throw new Error(errorPrefix+'contains a path '+prevPath.toString()+' that is ancestor of another path '+curPath.toString());}prevPath=curPath;}};/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n */const validateFirebaseMergeDataArg=function(fnName,data,path,optional){if(optional&&data===undefined){return;}const errorPrefix$1=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName,'values');if(!(data&&typeof data==='object')||Array.isArray(data)){throw new Error(errorPrefix$1+' must be an object containing the children to replace.');}const mergePaths=[];each(data,(key,value)=>{const curPath=new Path(key);validateFirebaseData(errorPrefix$1,value,pathChild(path,curPath));if(pathGetBack(curPath)==='.priority'){if(!isValidPriority(value)){throw new Error(errorPrefix$1+\"contains an invalid value for '\"+curPath.toString()+\"', which must be a valid \"+'Firebase priority (a string, finite number, server value, or null).');}}mergePaths.push(curPath);});validateFirebaseMergePaths(errorPrefix$1,mergePaths);};const validatePriority=function(fnName,priority,optional){if(optional&&priority===undefined){return;}if(isInvalidJSONNumber(priority)){throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName,'priority')+'is '+priority.toString()+', but must be a valid Firebase priority (a string, finite number, '+'server value, or null).');}// Special case to allow importing data with a .sv.\nif(!isValidPriority(priority)){throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName,'priority')+'must be a valid Firebase priority '+'(a string, finite number, server value, or null).');}};const validateKey=function(fnName,argumentName,key,optional){if(optional&&key===undefined){return;}if(!isValidKey(key)){throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName,argumentName)+'was an invalid key = \"'+key+'\".  Firebase keys must be non-empty strings and '+'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');}};/**\r\n * @internal\r\n */const validatePathString=function(fnName,argumentName,pathString,optional){if(optional&&pathString===undefined){return;}if(!isValidPathString(pathString)){throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName,argumentName)+'was an invalid path = \"'+pathString+'\". Paths must be non-empty strings and '+'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');}};const validateRootPathString=function(fnName,argumentName,pathString,optional){if(pathString){// Allow '/.info/' at the beginning.\npathString=pathString.replace(/^\\/*\\.info(\\/|$)/,'/');}validatePathString(fnName,argumentName,pathString,optional);};/**\r\n * @internal\r\n */const validateWritablePath=function(fnName,path){if(pathGetFront(path)==='.info'){throw new Error(fnName+\" failed = Can't modify data under /.info/\");}};const validateUrl=function(fnName,parsedUrl){// TODO = Validate server better.\nconst pathString=parsedUrl.path.toString();if(!(typeof parsedUrl.repoInfo.host==='string')||parsedUrl.repoInfo.host.length===0||!isValidKey(parsedUrl.repoInfo.namespace)&&parsedUrl.repoInfo.host.split(':')[0]!=='localhost'||pathString.length!==0&&!isValidRootPathString(pathString)){throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName,'url')+'must be a valid firebase URL and '+'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');}};/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The event queue serves a few purposes:\r\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\r\n *    events being queued.\r\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\r\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\r\n *    left off, ensuring that the events are still raised synchronously and in order.\r\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\r\n *    events are raised synchronously.\r\n *\r\n * NOTE: This can all go away if/when we move to async events.\r\n *\r\n */class EventQueue{constructor(){this.eventLists_=[];/**\r\n         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\r\n         */this.recursionDepth_=0;}}/**\r\n * @param eventDataList - The new events to queue.\r\n */function eventQueueQueueEvents(eventQueue,eventDataList){// We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\nlet currList=null;for(let i=0;i<eventDataList.length;i++){const data=eventDataList[i];const path=data.getPath();if(currList!==null&&!pathEquals(path,currList.path)){eventQueue.eventLists_.push(currList);currList=null;}if(currList===null){currList={events:[],path};}currList.events.push(data);}if(currList){eventQueue.eventLists_.push(currList);}}/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones)\r\n * for the specified path.\r\n *\r\n * It is assumed that the new events are all for the specified path.\r\n *\r\n * @param path - The path to raise events for.\r\n * @param eventDataList - The new events to raise.\r\n */function eventQueueRaiseEventsAtPath(eventQueue,path,eventDataList){eventQueueQueueEvents(eventQueue,eventDataList);eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,eventPath=>pathEquals(eventPath,path));}/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones) for\r\n * locations related to the specified change path (i.e. all ancestors and descendants).\r\n *\r\n * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\r\n *\r\n * @param changedPath - The path to raise events for.\r\n * @param eventDataList - The events to raise\r\n */function eventQueueRaiseEventsForChangedPath(eventQueue,changedPath,eventDataList){eventQueueQueueEvents(eventQueue,eventDataList);eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,eventPath=>pathContains(eventPath,changedPath)||pathContains(changedPath,eventPath));}function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,predicate){eventQueue.recursionDepth_++;let sentAll=true;for(let i=0;i<eventQueue.eventLists_.length;i++){const eventList=eventQueue.eventLists_[i];if(eventList){const eventPath=eventList.path;if(predicate(eventPath)){eventListRaise(eventQueue.eventLists_[i]);eventQueue.eventLists_[i]=null;}else{sentAll=false;}}}if(sentAll){eventQueue.eventLists_=[];}eventQueue.recursionDepth_--;}/**\r\n * Iterates through the list and raises each event\r\n */function eventListRaise(eventList){for(let i=0;i<eventList.events.length;i++){const eventData=eventList.events[i];if(eventData!==null){eventList.events[i]=null;const eventFn=eventData.getEventRunner();if(logger){log('event: '+eventData.toString());}exceptionGuard(eventFn);}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const INTERRUPT_REASON='repo_interrupt';/**\r\n * If a transaction does not succeed after 25 retries, we abort it. Among other\r\n * things this ensure that if there's ever a bug causing a mismatch between\r\n * client / server hashes for some data, we won't retry indefinitely.\r\n */const MAX_TRANSACTION_RETRIES=25;/**\r\n * A connection to a single data repository.\r\n */class Repo{constructor(repoInfo_,forceRestClient_,authTokenProvider_,appCheckProvider_){this.repoInfo_=repoInfo_;this.forceRestClient_=forceRestClient_;this.authTokenProvider_=authTokenProvider_;this.appCheckProvider_=appCheckProvider_;this.dataUpdateCount=0;this.statsListener_=null;this.eventQueue_=new EventQueue();this.nextWriteId_=1;this.interceptServerDataCallback_=null;/** A list of data pieces and paths to be set when this client disconnects. */this.onDisconnect_=newSparseSnapshotTree();/** Stores queues of outstanding transactions for Firebase locations. */this.transactionQueueTree_=new Tree();// TODO: This should be @private but it's used by test_access.js and internal.js\nthis.persistentConnection_=null;// This key is intentionally not updated if RepoInfo is later changed or replaced\nthis.key=this.repoInfo_.toURLString();}/**\r\n     * @returns The URL corresponding to the root of this Firebase.\r\n     */toString(){return(this.repoInfo_.secure?'https://':'http://')+this.repoInfo_.host;}}function repoStart(repo,appId,authOverride){repo.stats_=statsManagerGetCollection(repo.repoInfo_);if(repo.forceRestClient_||beingCrawled()){repo.server_=new ReadonlyRestClient(repo.repoInfo_,(pathString,data,isMerge,tag)=>{repoOnDataUpdate(repo,pathString,data,isMerge,tag);},repo.authTokenProvider_,repo.appCheckProvider_);// Minor hack: Fire onConnect immediately, since there's no actual connection.\nsetTimeout(()=>repoOnConnectStatus(repo,/* connectStatus= */true),0);}else{// Validate authOverride\nif(typeof authOverride!=='undefined'&&authOverride!==null){if(typeof authOverride!=='object'){throw new Error('Only objects are supported for option databaseAuthVariableOverride');}try{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(authOverride);}catch(e){throw new Error('Invalid authOverride provided: '+e);}}repo.persistentConnection_=new PersistentConnection(repo.repoInfo_,appId,(pathString,data,isMerge,tag)=>{repoOnDataUpdate(repo,pathString,data,isMerge,tag);},connectStatus=>{repoOnConnectStatus(repo,connectStatus);},updates=>{repoOnServerInfoUpdate(repo,updates);},repo.authTokenProvider_,repo.appCheckProvider_,authOverride);repo.server_=repo.persistentConnection_;}repo.authTokenProvider_.addTokenChangeListener(token=>{repo.server_.refreshAuthToken(token);});repo.appCheckProvider_.addTokenChangeListener(result=>{repo.server_.refreshAppCheckToken(result.token);});// In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n// we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\nrepo.statsReporter_=statsManagerGetOrCreateReporter(repo.repoInfo_,()=>new StatsReporter(repo.stats_,repo.server_));// Used for .info.\nrepo.infoData_=new SnapshotHolder();repo.infoSyncTree_=new SyncTree({startListening:(query,tag,currentHashFn,onComplete)=>{let infoEvents=[];const node=repo.infoData_.getNode(query._path);// This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n// on initial data...\nif(!node.isEmpty()){infoEvents=syncTreeApplyServerOverwrite(repo.infoSyncTree_,query._path,node);setTimeout(()=>{onComplete('ok');},0);}return infoEvents;},stopListening:()=>{}});repoUpdateInfo(repo,'connected',false);repo.serverSyncTree_=new SyncTree({startListening:(query,tag,currentHashFn,onComplete)=>{repo.server_.listen(query,currentHashFn,tag,(status,data)=>{const events=onComplete(status,data);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,query._path,events);});// No synchronous events for network-backed sync trees\nreturn[];},stopListening:(query,tag)=>{repo.server_.unlisten(query,tag);}});}/**\r\n * @returns The time in milliseconds, taking the server offset into account if we have one.\r\n */function repoServerTime(repo){const offsetNode=repo.infoData_.getNode(new Path('.info/serverTimeOffset'));const offset=offsetNode.val()||0;return new Date().getTime()+offset;}/**\r\n * Generate ServerValues using some variables from the repo object.\r\n */function repoGenerateServerValues(repo){return generateWithValues({timestamp:repoServerTime(repo)});}/**\r\n * Called by realtime when we get new messages from the server.\r\n */function repoOnDataUpdate(repo,pathString,data,isMerge,tag){// For testing.\nrepo.dataUpdateCount++;const path=new Path(pathString);data=repo.interceptServerDataCallback_?repo.interceptServerDataCallback_(pathString,data):data;let events=[];if(tag){if(isMerge){const taggedChildren=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(data,raw=>nodeFromJSON(raw));events=syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_,path,taggedChildren,tag);}else{const taggedSnap=nodeFromJSON(data);events=syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_,path,taggedSnap,tag);}}else if(isMerge){const changedChildren=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(data,raw=>nodeFromJSON(raw));events=syncTreeApplyServerMerge(repo.serverSyncTree_,path,changedChildren);}else{const snap=nodeFromJSON(data);events=syncTreeApplyServerOverwrite(repo.serverSyncTree_,path,snap);}let affectedPath=path;if(events.length>0){// Since we have a listener outstanding for each transaction, receiving any events\n// is a proxy for some change having occurred.\naffectedPath=repoRerunTransactions(repo,path);}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,events);}function repoOnConnectStatus(repo,connectStatus){repoUpdateInfo(repo,'connected',connectStatus);if(connectStatus===false){repoRunOnDisconnectEvents(repo);}}function repoOnServerInfoUpdate(repo,updates){each(updates,(key,value)=>{repoUpdateInfo(repo,key,value);});}function repoUpdateInfo(repo,pathString,value){const path=new Path('/.info/'+pathString);const newNode=nodeFromJSON(value);repo.infoData_.updateSnapshot(path,newNode);const events=syncTreeApplyServerOverwrite(repo.infoSyncTree_,path,newNode);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);}function repoGetNextWriteId(repo){return repo.nextWriteId_++;}/**\r\n * The purpose of `getValue` is to return the latest known value\r\n * satisfying `query`.\r\n *\r\n * This method will first check for in-memory cached values\r\n * belonging to active listeners. If they are found, such values\r\n * are considered to be the most up-to-date.\r\n *\r\n * If the client is not connected, this method will try to\r\n * establish a connection and request the value for `query`. If\r\n * the client is not able to retrieve the query result, it reports\r\n * an error.\r\n *\r\n * @param query - The query to surface a value for.\r\n */function repoGetValue(repo,query){// Only active queries are cached. There is no persisted cache.\nconst cached=syncTreeGetServerValue(repo.serverSyncTree_,query);if(cached!=null){return Promise.resolve(cached);}return repo.server_.get(query).then(payload=>{const node=nodeFromJSON(payload).withIndex(query._queryParams.getIndex());const events=syncTreeApplyServerOverwrite(repo.serverSyncTree_,query._path,node);eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,events);return Promise.resolve(node);},err=>{repoLog(repo,'get for query '+(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(query)+' failed: '+err);return Promise.reject(new Error(err));});}function repoSetWithPriority(repo,path,newVal,newPriority,onComplete){repoLog(repo,'set',{path:path.toString(),value:newVal,priority:newPriority});// TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n// (b) store unresolved paths on JSON parse\nconst serverValues=repoGenerateServerValues(repo);const newNodeUnresolved=nodeFromJSON(newVal,newPriority);const existing=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path);const newNode=resolveDeferredValueSnapshot(newNodeUnresolved,existing,serverValues);const writeId=repoGetNextWriteId(repo);const events=syncTreeApplyUserOverwrite(repo.serverSyncTree_,path,newNode,writeId,true);eventQueueQueueEvents(repo.eventQueue_,events);repo.server_.put(path.toString(),newNodeUnresolved.val(/*export=*/true),(status,errorReason)=>{const success=status==='ok';if(!success){warn('set at '+path+' failed: '+status);}const clearEvents=syncTreeAckUserWrite(repo.serverSyncTree_,writeId,!success);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,clearEvents);repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});const affectedPath=repoAbortTransactions(repo,path);repoRerunTransactions(repo,affectedPath);// We queued the events above, so just flush the queue here\neventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,[]);}function repoUpdate(repo,path,childrenToMerge,onComplete){repoLog(repo,'update',{path:path.toString(),value:childrenToMerge});// Start with our existing data and merge each child into it.\nlet empty=true;const serverValues=repoGenerateServerValues(repo);const changedChildren={};each(childrenToMerge,(changedKey,changedValue)=>{empty=false;changedChildren[changedKey]=resolveDeferredValueTree(pathChild(path,changedKey),nodeFromJSON(changedValue),repo.serverSyncTree_,serverValues);});if(!empty){const writeId=repoGetNextWriteId(repo);const events=syncTreeApplyUserMerge(repo.serverSyncTree_,path,changedChildren,writeId);eventQueueQueueEvents(repo.eventQueue_,events);repo.server_.merge(path.toString(),childrenToMerge,(status,errorReason)=>{const success=status==='ok';if(!success){warn('update at '+path+' failed: '+status);}const clearEvents=syncTreeAckUserWrite(repo.serverSyncTree_,writeId,!success);const affectedPath=clearEvents.length>0?repoRerunTransactions(repo,path):path;eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,clearEvents);repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});each(childrenToMerge,changedPath=>{const affectedPath=repoAbortTransactions(repo,pathChild(path,changedPath));repoRerunTransactions(repo,affectedPath);});// We queued the events above, so just flush the queue here\neventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,[]);}else{log(\"update() called with empty data.  Don't do anything.\");repoCallOnCompleteCallback(repo,onComplete,'ok',undefined);}}/**\r\n * Applies all of the changes stored up in the onDisconnect_ tree.\r\n */function repoRunOnDisconnectEvents(repo){repoLog(repo,'onDisconnectEvents');const serverValues=repoGenerateServerValues(repo);const resolvedOnDisconnectTree=newSparseSnapshotTree();sparseSnapshotTreeForEachTree(repo.onDisconnect_,newEmptyPath(),(path,node)=>{const resolved=resolveDeferredValueTree(path,node,repo.serverSyncTree_,serverValues);sparseSnapshotTreeRemember(resolvedOnDisconnectTree,path,resolved);});let events=[];sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree,newEmptyPath(),(path,snap)=>{events=events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_,path,snap));const affectedPath=repoAbortTransactions(repo,path);repoRerunTransactions(repo,affectedPath);});repo.onDisconnect_=newSparseSnapshotTree();eventQueueRaiseEventsForChangedPath(repo.eventQueue_,newEmptyPath(),events);}function repoOnDisconnectCancel(repo,path,onComplete){repo.server_.onDisconnectCancel(path.toString(),(status,errorReason)=>{if(status==='ok'){sparseSnapshotTreeForget(repo.onDisconnect_,path);}repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});}function repoOnDisconnectSet(repo,path,value,onComplete){const newNode=nodeFromJSON(value);repo.server_.onDisconnectPut(path.toString(),newNode.val(/*export=*/true),(status,errorReason)=>{if(status==='ok'){sparseSnapshotTreeRemember(repo.onDisconnect_,path,newNode);}repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});}function repoOnDisconnectSetWithPriority(repo,path,value,priority,onComplete){const newNode=nodeFromJSON(value,priority);repo.server_.onDisconnectPut(path.toString(),newNode.val(/*export=*/true),(status,errorReason)=>{if(status==='ok'){sparseSnapshotTreeRemember(repo.onDisconnect_,path,newNode);}repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});}function repoOnDisconnectUpdate(repo,path,childrenToMerge,onComplete){if((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(childrenToMerge)){log(\"onDisconnect().update() called with empty data.  Don't do anything.\");repoCallOnCompleteCallback(repo,onComplete,'ok',undefined);return;}repo.server_.onDisconnectMerge(path.toString(),childrenToMerge,(status,errorReason)=>{if(status==='ok'){each(childrenToMerge,(childName,childNode)=>{const newChildNode=nodeFromJSON(childNode);sparseSnapshotTreeRemember(repo.onDisconnect_,pathChild(path,childName),newChildNode);});}repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});}function repoAddEventCallbackForQuery(repo,query,eventRegistration){let events;if(pathGetFront(query._path)==='.info'){events=syncTreeAddEventRegistration(repo.infoSyncTree_,query,eventRegistration);}else{events=syncTreeAddEventRegistration(repo.serverSyncTree_,query,eventRegistration);}eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,events);}function repoRemoveEventCallbackForQuery(repo,query,eventRegistration){// These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n// a little bit by handling the return values anyways.\nlet events;if(pathGetFront(query._path)==='.info'){events=syncTreeRemoveEventRegistration(repo.infoSyncTree_,query,eventRegistration);}else{events=syncTreeRemoveEventRegistration(repo.serverSyncTree_,query,eventRegistration);}eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,events);}function repoInterrupt(repo){if(repo.persistentConnection_){repo.persistentConnection_.interrupt(INTERRUPT_REASON);}}function repoResume(repo){if(repo.persistentConnection_){repo.persistentConnection_.resume(INTERRUPT_REASON);}}function repoLog(repo,...varArgs){let prefix='';if(repo.persistentConnection_){prefix=repo.persistentConnection_.id+':';}log(prefix,...varArgs);}function repoCallOnCompleteCallback(repo,callback,status,errorReason){if(callback){exceptionGuard(()=>{if(status==='ok'){callback(null);}else{const code=(status||'error').toUpperCase();let message=code;if(errorReason){message+=': '+errorReason;}const error=new Error(message);// eslint-disable-next-line @typescript-eslint/no-explicit-any\nerror.code=code;callback(error);}});}}/**\r\n * Creates a new transaction, adds it to the transactions we're tracking, and\r\n * sends it to the server if possible.\r\n *\r\n * @param path - Path at which to do transaction.\r\n * @param transactionUpdate - Update callback.\r\n * @param onComplete - Completion callback.\r\n * @param unwatcher - Function that will be called when the transaction no longer\r\n * need data updates for `path`.\r\n * @param applyLocally - Whether or not to make intermediate results visible\r\n */function repoStartTransaction(repo,path,transactionUpdate,onComplete,unwatcher,applyLocally){repoLog(repo,'transaction on '+path);// Initialize transaction.\nconst transaction={path,update:transactionUpdate,onComplete,// One of TransactionStatus enums.\nstatus:null,// Used when combining transactions at different locations to figure out\n// which one goes first.\norder:LUIDGenerator(),// Whether to raise local events for this transaction.\napplyLocally,// Count of how many times we've retried the transaction.\nretryCount:0,// Function to call to clean up our .on() listener.\nunwatcher,// Stores why a transaction was aborted.\nabortReason:null,currentWriteId:null,currentInputSnapshot:null,currentOutputSnapshotRaw:null,currentOutputSnapshotResolved:null};// Run transaction initially.\nconst currentState=repoGetLatestState(repo,path,undefined);transaction.currentInputSnapshot=currentState;const newVal=transaction.update(currentState.val());if(newVal===undefined){// Abort transaction.\ntransaction.unwatcher();transaction.currentOutputSnapshotRaw=null;transaction.currentOutputSnapshotResolved=null;if(transaction.onComplete){transaction.onComplete(null,false,transaction.currentInputSnapshot);}}else{validateFirebaseData('transaction failed: Data returned ',newVal,transaction.path);// Mark as run and add to our queue.\ntransaction.status=0/* RUN */;const queueNode=treeSubTree(repo.transactionQueueTree_,path);const nodeQueue=treeGetValue(queueNode)||[];nodeQueue.push(transaction);treeSetValue(queueNode,nodeQueue);// Update visibleData and raise events\n// Note: We intentionally raise events after updating all of our\n// transaction state, since the user could start new transactions from the\n// event callbacks.\nlet priorityForNode;if(typeof newVal==='object'&&newVal!==null&&(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(newVal,'.priority')){// eslint-disable-next-line @typescript-eslint/no-explicit-any\npriorityForNode=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(newVal,'.priority');(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(isValidPriority(priorityForNode),'Invalid priority returned by transaction. '+'Priority must be a valid string, finite number, server value, or null.');}else{const currentNode=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path)||ChildrenNode.EMPTY_NODE;priorityForNode=currentNode.getPriority().val();}const serverValues=repoGenerateServerValues(repo);const newNodeUnresolved=nodeFromJSON(newVal,priorityForNode);const newNode=resolveDeferredValueSnapshot(newNodeUnresolved,currentState,serverValues);transaction.currentOutputSnapshotRaw=newNodeUnresolved;transaction.currentOutputSnapshotResolved=newNode;transaction.currentWriteId=repoGetNextWriteId(repo);const events=syncTreeApplyUserOverwrite(repo.serverSyncTree_,path,newNode,transaction.currentWriteId,transaction.applyLocally);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);repoSendReadyTransactions(repo,repo.transactionQueueTree_);}}/**\r\n * @param excludeSets - A specific set to exclude\r\n */function repoGetLatestState(repo,path,excludeSets){return syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path,excludeSets)||ChildrenNode.EMPTY_NODE;}/**\r\n * Sends any already-run transactions that aren't waiting for outstanding\r\n * transactions to complete.\r\n *\r\n * Externally it's called with no arguments, but it calls itself recursively\r\n * with a particular transactionQueueTree node to recurse through the tree.\r\n *\r\n * @param node - transactionQueueTree node to start at.\r\n */function repoSendReadyTransactions(repo,node=repo.transactionQueueTree_){// Before recursing, make sure any completed transactions are removed.\nif(!node){repoPruneCompletedTransactionsBelowNode(repo,node);}if(treeGetValue(node)){const queue=repoBuildTransactionQueue(repo,node);(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queue.length>0,'Sending zero length transaction queue');const allRun=queue.every(transaction=>transaction.status===0/* RUN */);// If they're all run (and not sent), we can send them.  Else, we must wait.\nif(allRun){repoSendTransactionQueue(repo,treeGetPath(node),queue);}}else if(treeHasChildren(node)){treeForEachChild(node,childNode=>{repoSendReadyTransactions(repo,childNode);});}}/**\r\n * Given a list of run transactions, send them to the server and then handle\r\n * the result (success or failure).\r\n *\r\n * @param path - The location of the queue.\r\n * @param queue - Queue of transactions under the specified location.\r\n */function repoSendTransactionQueue(repo,path,queue){// Mark transactions as sent and increment retry count!\nconst setsToIgnore=queue.map(txn=>{return txn.currentWriteId;});const latestState=repoGetLatestState(repo,path,setsToIgnore);let snapToSend=latestState;const latestHash=latestState.hash();for(let i=0;i<queue.length;i++){const txn=queue[i];(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(txn.status===0/* RUN */,'tryToSendTransactionQueue_: items in queue should all be run.');txn.status=1/* SENT */;txn.retryCount++;const relativePath=newRelativePath(path,txn.path);// If we've gotten to this point, the output snapshot must be defined.\nsnapToSend=snapToSend.updateChild(relativePath/** @type {!Node} */,txn.currentOutputSnapshotRaw);}const dataToSend=snapToSend.val(true);const pathToSend=path;// Send the put.\nrepo.server_.put(pathToSend.toString(),dataToSend,status=>{repoLog(repo,'transaction put response',{path:pathToSend.toString(),status});let events=[];if(status==='ok'){// Queue up the callbacks and fire them after cleaning up all of our\n// transaction state, since the callback could trigger more\n// transactions or sets.\nconst callbacks=[];for(let i=0;i<queue.length;i++){queue[i].status=2/* COMPLETED */;events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,queue[i].currentWriteId));if(queue[i].onComplete){// We never unset the output snapshot, and given that this\n// transaction is complete, it should be set\ncallbacks.push(()=>queue[i].onComplete(null,true,queue[i].currentOutputSnapshotResolved));}queue[i].unwatcher();}// Now remove the completed transactions.\nrepoPruneCompletedTransactionsBelowNode(repo,treeSubTree(repo.transactionQueueTree_,path));// There may be pending transactions that we can now send.\nrepoSendReadyTransactions(repo,repo.transactionQueueTree_);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);// Finally, trigger onComplete callbacks.\nfor(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}}else{// transactions are no longer sent.  Update their status appropriately.\nif(status==='datastale'){for(let i=0;i<queue.length;i++){if(queue[i].status===3/* SENT_NEEDS_ABORT */){queue[i].status=4/* NEEDS_ABORT */;}else{queue[i].status=0/* RUN */;}}}else{warn('transaction at '+pathToSend.toString()+' failed: '+status);for(let i=0;i<queue.length;i++){queue[i].status=4/* NEEDS_ABORT */;queue[i].abortReason=status;}}repoRerunTransactions(repo,path);}},latestHash);}/**\r\n * Finds all transactions dependent on the data at changedPath and reruns them.\r\n *\r\n * Should be called any time cached data changes.\r\n *\r\n * Return the highest path that was affected by rerunning transactions. This\r\n * is the path at which events need to be raised for.\r\n *\r\n * @param changedPath - The path in mergedData that changed.\r\n * @returns The rootmost path that was affected by rerunning transactions.\r\n */function repoRerunTransactions(repo,changedPath){const rootMostTransactionNode=repoGetAncestorTransactionNode(repo,changedPath);const path=treeGetPath(rootMostTransactionNode);const queue=repoBuildTransactionQueue(repo,rootMostTransactionNode);repoRerunTransactionQueue(repo,queue,path);return path;}/**\r\n * Does all the work of rerunning transactions (as well as cleans up aborted\r\n * transactions and whatnot).\r\n *\r\n * @param queue - The queue of transactions to run.\r\n * @param path - The path the queue is for.\r\n */function repoRerunTransactionQueue(repo,queue,path){if(queue.length===0){return;// Nothing to do!\n}// Queue up the callbacks and fire them after cleaning up all of our\n// transaction state, since the callback could trigger more transactions or\n// sets.\nconst callbacks=[];let events=[];// Ignore all of the sets we're going to re-run.\nconst txnsToRerun=queue.filter(q=>{return q.status===0/* RUN */;});const setsToIgnore=txnsToRerun.map(q=>{return q.currentWriteId;});for(let i=0;i<queue.length;i++){const transaction=queue[i];const relativePath=newRelativePath(path,transaction.path);let abortTransaction=false,abortReason;(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(relativePath!==null,'rerunTransactionsUnderNode_: relativePath should not be null.');if(transaction.status===4/* NEEDS_ABORT */){abortTransaction=true;abortReason=transaction.abortReason;events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true));}else if(transaction.status===0/* RUN */){if(transaction.retryCount>=MAX_TRANSACTION_RETRIES){abortTransaction=true;abortReason='maxretry';events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true));}else{// This code reruns a transaction\nconst currentNode=repoGetLatestState(repo,transaction.path,setsToIgnore);transaction.currentInputSnapshot=currentNode;const newData=queue[i].update(currentNode.val());if(newData!==undefined){validateFirebaseData('transaction failed: Data returned ',newData,transaction.path);let newDataNode=nodeFromJSON(newData);const hasExplicitPriority=typeof newData==='object'&&newData!=null&&(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(newData,'.priority');if(!hasExplicitPriority){// Keep the old priority if there wasn't a priority explicitly specified.\nnewDataNode=newDataNode.updatePriority(currentNode.getPriority());}const oldWriteId=transaction.currentWriteId;const serverValues=repoGenerateServerValues(repo);const newNodeResolved=resolveDeferredValueSnapshot(newDataNode,currentNode,serverValues);transaction.currentOutputSnapshotRaw=newDataNode;transaction.currentOutputSnapshotResolved=newNodeResolved;transaction.currentWriteId=repoGetNextWriteId(repo);// Mutates setsToIgnore in place\nsetsToIgnore.splice(setsToIgnore.indexOf(oldWriteId),1);events=events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_,transaction.path,newNodeResolved,transaction.currentWriteId,transaction.applyLocally));events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,oldWriteId,true));}else{abortTransaction=true;abortReason='nodata';events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true));}}}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);events=[];if(abortTransaction){// Abort.\nqueue[i].status=2/* COMPLETED */;// Removing a listener can trigger pruning which can muck with\n// mergedData/visibleData (as it prunes data). So defer the unwatcher\n// until we're done.\n(function(unwatcher){setTimeout(unwatcher,Math.floor(0));})(queue[i].unwatcher);if(queue[i].onComplete){if(abortReason==='nodata'){callbacks.push(()=>queue[i].onComplete(null,false,queue[i].currentInputSnapshot));}else{callbacks.push(()=>queue[i].onComplete(new Error(abortReason),false,null));}}}}// Clean up completed transactions.\nrepoPruneCompletedTransactionsBelowNode(repo,repo.transactionQueueTree_);// Now fire callbacks, now that we're in a good, known state.\nfor(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}// Try to send the transaction result to the server.\nrepoSendReadyTransactions(repo,repo.transactionQueueTree_);}/**\r\n * Returns the rootmost ancestor node of the specified path that has a pending\r\n * transaction on it, or just returns the node for the given path if there are\r\n * no pending transactions on any ancestor.\r\n *\r\n * @param path - The location to start at.\r\n * @returns The rootmost node with a transaction.\r\n */function repoGetAncestorTransactionNode(repo,path){let front;// Start at the root and walk deeper into the tree towards path until we\n// find a node with pending transactions.\nlet transactionNode=repo.transactionQueueTree_;front=pathGetFront(path);while(front!==null&&treeGetValue(transactionNode)===undefined){transactionNode=treeSubTree(transactionNode,front);path=pathPopFront(path);front=pathGetFront(path);}return transactionNode;}/**\r\n * Builds the queue of all transactions at or below the specified\r\n * transactionNode.\r\n *\r\n * @param transactionNode\r\n * @returns The generated queue.\r\n */function repoBuildTransactionQueue(repo,transactionNode){// Walk any child transaction queues and aggregate them into a single queue.\nconst transactionQueue=[];repoAggregateTransactionQueuesForNode(repo,transactionNode,transactionQueue);// Sort them by the order the transactions were created.\ntransactionQueue.sort((a,b)=>a.order-b.order);return transactionQueue;}function repoAggregateTransactionQueuesForNode(repo,node,queue){const nodeQueue=treeGetValue(node);if(nodeQueue){for(let i=0;i<nodeQueue.length;i++){queue.push(nodeQueue[i]);}}treeForEachChild(node,child=>{repoAggregateTransactionQueuesForNode(repo,child,queue);});}/**\r\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\r\n */function repoPruneCompletedTransactionsBelowNode(repo,node){const queue=treeGetValue(node);if(queue){let to=0;for(let from=0;from<queue.length;from++){if(queue[from].status!==2/* COMPLETED */){queue[to]=queue[from];to++;}}queue.length=to;treeSetValue(node,queue.length>0?queue:undefined);}treeForEachChild(node,childNode=>{repoPruneCompletedTransactionsBelowNode(repo,childNode);});}/**\r\n * Aborts all transactions on ancestors or descendants of the specified path.\r\n * Called when doing a set() or update() since we consider them incompatible\r\n * with transactions.\r\n *\r\n * @param path - Path for which we want to abort related transactions.\r\n */function repoAbortTransactions(repo,path){const affectedPath=treeGetPath(repoGetAncestorTransactionNode(repo,path));const transactionNode=treeSubTree(repo.transactionQueueTree_,path);treeForEachAncestor(transactionNode,node=>{repoAbortTransactionsOnNode(repo,node);});repoAbortTransactionsOnNode(repo,transactionNode);treeForEachDescendant(transactionNode,node=>{repoAbortTransactionsOnNode(repo,node);});return affectedPath;}/**\r\n * Abort transactions stored in this transaction queue node.\r\n *\r\n * @param node - Node to abort transactions for.\r\n */function repoAbortTransactionsOnNode(repo,node){const queue=treeGetValue(node);if(queue){// Queue up the callbacks and fire them after cleaning up all of our\n// transaction state, since the callback could trigger more transactions\n// or sets.\nconst callbacks=[];// Go through queue.  Any already-sent transactions must be marked for\n// abort, while the unsent ones can be immediately aborted and removed.\nlet events=[];let lastSent=-1;for(let i=0;i<queue.length;i++){if(queue[i].status===3/* SENT_NEEDS_ABORT */);else if(queue[i].status===1/* SENT */){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(lastSent===i-1,'All SENT items should be at beginning of queue.');lastSent=i;// Mark transaction for abort when it comes back.\nqueue[i].status=3/* SENT_NEEDS_ABORT */;queue[i].abortReason='set';}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queue[i].status===0/* RUN */,'Unexpected transaction status in abort');// We can abort it immediately.\nqueue[i].unwatcher();events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,queue[i].currentWriteId,true));if(queue[i].onComplete){callbacks.push(queue[i].onComplete.bind(null,new Error('set'),false,null));}}}if(lastSent===-1){// We're not waiting for any sent transactions.  We can clear the queue.\ntreeSetValue(node,undefined);}else{// Remove the transactions we aborted.\nqueue.length=lastSent+1;}// Now fire the callbacks.\neventQueueRaiseEventsForChangedPath(repo.eventQueue_,treeGetPath(node),events);for(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */function decodePath(pathString){let pathStringDecoded='';const pieces=pathString.split('/');for(let i=0;i<pieces.length;i++){if(pieces[i].length>0){let piece=pieces[i];try{piece=decodeURIComponent(piece.replace(/\\+/g,' '));}catch(e){}pathStringDecoded+='/'+piece;}}return pathStringDecoded;}/**\r\n * @returns key value hash\r\n */function decodeQuery(queryString){const results={};if(queryString.charAt(0)==='?'){queryString=queryString.substring(1);}for(const segment of queryString.split('&')){if(segment.length===0){continue;}const kv=segment.split('=');if(kv.length===2){results[decodeURIComponent(kv[0])]=decodeURIComponent(kv[1]);}else{warn(`Invalid query segment '${segment}' in query '${queryString}'`);}}return results;}const parseRepoInfo=function(dataURL,nodeAdmin){const parsedUrl=parseDatabaseURL(dataURL),namespace=parsedUrl.namespace;if(parsedUrl.domain==='firebase.com'){fatal(parsedUrl.host+' is no longer supported. '+'Please use <YOUR FIREBASE>.firebaseio.com instead');}// Catch common error of uninitialized namespace value.\nif((!namespace||namespace==='undefined')&&parsedUrl.domain!=='localhost'){fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');}if(!parsedUrl.secure){warnIfPageIsSecure();}const webSocketOnly=parsedUrl.scheme==='ws'||parsedUrl.scheme==='wss';return{repoInfo:new RepoInfo(parsedUrl.host,parsedUrl.secure,namespace,nodeAdmin,webSocketOnly,/*persistenceKey=*/'',/*includeNamespaceInQueryParams=*/namespace!==parsedUrl.subdomain),path:new Path(parsedUrl.pathString)};};const parseDatabaseURL=function(dataURL){// Default to empty strings in the event of a malformed string.\nlet host='',domain='',subdomain='',pathString='',namespace='';// Always default to SSL, unless otherwise specified.\nlet secure=true,scheme='https',port=443;// Don't do any validation here. The caller is responsible for validating the result of parsing.\nif(typeof dataURL==='string'){// Parse scheme.\nlet colonInd=dataURL.indexOf('//');if(colonInd>=0){scheme=dataURL.substring(0,colonInd-1);dataURL=dataURL.substring(colonInd+2);}// Parse host, path, and query string.\nlet slashInd=dataURL.indexOf('/');if(slashInd===-1){slashInd=dataURL.length;}let questionMarkInd=dataURL.indexOf('?');if(questionMarkInd===-1){questionMarkInd=dataURL.length;}host=dataURL.substring(0,Math.min(slashInd,questionMarkInd));if(slashInd<questionMarkInd){// For pathString, questionMarkInd will always come after slashInd\npathString=decodePath(dataURL.substring(slashInd,questionMarkInd));}const queryParams=decodeQuery(dataURL.substring(Math.min(dataURL.length,questionMarkInd)));// If we have a port, use scheme for determining if it's secure.\ncolonInd=host.indexOf(':');if(colonInd>=0){secure=scheme==='https'||scheme==='wss';port=parseInt(host.substring(colonInd+1),10);}else{colonInd=host.length;}const hostWithoutPort=host.slice(0,colonInd);if(hostWithoutPort.toLowerCase()==='localhost'){domain='localhost';}else if(hostWithoutPort.split('.').length<=2){domain=hostWithoutPort;}else{// Interpret the subdomain of a 3 or more component URL as the namespace name.\nconst dotInd=host.indexOf('.');subdomain=host.substring(0,dotInd).toLowerCase();domain=host.substring(dotInd+1);// Normalize namespaces to lowercase to share storage / connection.\nnamespace=subdomain;}// Always treat the value of the `ns` as the namespace name if it is present.\nif('ns'in queryParams){namespace=queryParams['ns'];}}return{host,port,domain,subdomain,secure,scheme,pathString,namespace};};/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Encapsulates the data needed to raise an event\r\n */class DataEvent{/**\r\n     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed\r\n     * @param eventRegistration - The function to call to with the event data. User provided\r\n     * @param snapshot - The data backing the event\r\n     * @param prevName - Optional, the name of the previous child for child_* events.\r\n     */constructor(eventType,eventRegistration,snapshot,prevName){this.eventType=eventType;this.eventRegistration=eventRegistration;this.snapshot=snapshot;this.prevName=prevName;}getPath(){const ref=this.snapshot.ref;if(this.eventType==='value'){return ref._path;}else{return ref.parent._path;}}getEventType(){return this.eventType;}getEventRunner(){return this.eventRegistration.getEventRunner(this);}toString(){return this.getPath().toString()+':'+this.eventType+':'+(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(this.snapshot.exportVal());}}class CancelEvent{constructor(eventRegistration,error,path){this.eventRegistration=eventRegistration;this.error=error;this.path=path;}getPath(){return this.path;}getEventType(){return'cancel';}getEventRunner(){return this.eventRegistration.getEventRunner(this);}toString(){return this.path.toString()+':cancel';}}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A wrapper class that converts events from the database@exp SDK to the legacy\r\n * Database SDK. Events are not converted directly as event registration relies\r\n * on reference comparison of the original user callback (see `matches()`) and\r\n * relies on equality of the legacy SDK's `context` object.\r\n */class CallbackContext{constructor(snapshotCallback,cancelCallback){this.snapshotCallback=snapshotCallback;this.cancelCallback=cancelCallback;}onValue(expDataSnapshot,previousChildName){this.snapshotCallback.call(null,expDataSnapshot,previousChildName);}onCancel(error){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.hasCancelCallback,'Raising a cancel event on a listener with no cancel callback');return this.cancelCallback.call(null,error);}get hasCancelCallback(){return!!this.cancelCallback;}matches(other){return this.snapshotCallback===other.snapshotCallback||this.snapshotCallback.userCallback!==undefined&&this.snapshotCallback.userCallback===other.snapshotCallback.userCallback&&this.snapshotCallback.context===other.snapshotCallback.context;}}/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The `onDisconnect` class allows you to write or clear data when your client\r\n * disconnects from the Database server. These updates occur whether your\r\n * client disconnects cleanly or not, so you can rely on them to clean up data\r\n * even if a connection is dropped or a client crashes.\r\n *\r\n * The `onDisconnect` class is most commonly used to manage presence in\r\n * applications where it is useful to detect how many clients are connected and\r\n * when other clients disconnect. See\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information.\r\n *\r\n * To avoid problems when a connection is dropped before the requests can be\r\n * transferred to the Database server, these functions should be called before\r\n * writing any data.\r\n *\r\n * Note that `onDisconnect` operations are only triggered once. If you want an\r\n * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n * the `onDisconnect` operations each time you reconnect.\r\n */class OnDisconnect{/** @hideconstructor */constructor(_repo,_path){this._repo=_repo;this._path=_path;}/**\r\n     * Cancels all previously queued `onDisconnect()` set or update events for this\r\n     * location and all children.\r\n     *\r\n     * If a write has been queued for this location via a `set()` or `update()` at a\r\n     * parent location, the write at this location will be canceled, though writes\r\n     * to sibling locations will still occur.\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */cancel(){const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoOnDisconnectCancel(this._repo,this._path,deferred.wrapCallback(()=>{}));return deferred.promise;}/**\r\n     * Ensures the data at this location is deleted when the client is disconnected\r\n     * (due to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */remove(){validateWritablePath('OnDisconnect.remove',this._path);const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoOnDisconnectSet(this._repo,this._path,null,deferred.wrapCallback(()=>{}));return deferred.promise;}/**\r\n     * Ensures the data at this location is set to the specified value when the\r\n     * client is disconnected (due to closing the browser, navigating to a new page,\r\n     * or network issues).\r\n     *\r\n     * `set()` is especially useful for implementing \"presence\" systems, where a\r\n     * value should be changed or cleared when a user disconnects so that they\r\n     * appear \"offline\" to other users. See\r\n     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n     * for more information.\r\n     *\r\n     * Note that `onDisconnect` operations are only triggered once. If you want an\r\n     * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n     * the `onDisconnect` operations each time.\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */set(value){validateWritablePath('OnDisconnect.set',this._path);validateFirebaseDataArg('OnDisconnect.set',value,this._path,false);const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoOnDisconnectSet(this._repo,this._path,value,deferred.wrapCallback(()=>{}));return deferred.promise;}/**\r\n     * Ensures the data at this location is set to the specified value and priority\r\n     * when the client is disconnected (due to closing the browser, navigating to a\r\n     * new page, or network issues).\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @param priority - The priority to be written (string, number, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */setWithPriority(value,priority){validateWritablePath('OnDisconnect.setWithPriority',this._path);validateFirebaseDataArg('OnDisconnect.setWithPriority',value,this._path,false);validatePriority('OnDisconnect.setWithPriority',priority,false);const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoOnDisconnectSetWithPriority(this._repo,this._path,value,priority,deferred.wrapCallback(()=>{}));return deferred.promise;}/**\r\n     * Writes multiple values at this location when the client is disconnected (due\r\n     * to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * The `values` argument contains multiple property-value pairs that will be\r\n     * written to the Database together. Each child property can either be a simple\r\n     * property (for example, \"name\") or a relative path (for example, \"name/first\")\r\n     * from the current location to the data to update.\r\n     *\r\n     * As opposed to the `set()` method, `update()` can be use to selectively update\r\n     * only the referenced properties at the current location (instead of replacing\r\n     * all the child properties at the current location).\r\n     *\r\n     * @param values - Object containing multiple values.\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */update(values){validateWritablePath('OnDisconnect.update',this._path);validateFirebaseMergeDataArg('OnDisconnect.update',values,this._path,false);const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoOnDisconnectUpdate(this._repo,this._path,values,deferred.wrapCallback(()=>{}));return deferred.promise;}}/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */class QueryImpl{/**\r\n     * @hideconstructor\r\n     */constructor(_repo,_path,_queryParams,_orderByCalled){this._repo=_repo;this._path=_path;this._queryParams=_queryParams;this._orderByCalled=_orderByCalled;}get key(){if(pathIsEmpty(this._path)){return null;}else{return pathGetBack(this._path);}}get ref(){return new ReferenceImpl(this._repo,this._path);}get _queryIdentifier(){const obj=queryParamsGetQueryObject(this._queryParams);const id=ObjectToUniqueKey(obj);return id==='{}'?'default':id;}/**\r\n     * An object representation of the query parameters used by this Query.\r\n     */get _queryObject(){return queryParamsGetQueryObject(this._queryParams);}isEqual(other){other=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(other);if(!(other instanceof QueryImpl)){return false;}const sameRepo=this._repo===other._repo;const samePath=pathEquals(this._path,other._path);const sameQueryIdentifier=this._queryIdentifier===other._queryIdentifier;return sameRepo&&samePath&&sameQueryIdentifier;}toJSON(){return this.toString();}toString(){return this._repo.toString()+pathToUrlEncodedString(this._path);}}/**\r\n * Validates that no other order by call has been made\r\n */function validateNoPreviousOrderByCall(query,fnName){if(query._orderByCalled===true){throw new Error(fnName+\": You can't combine multiple orderBy calls.\");}}/**\r\n * Validates start/end values for queries.\r\n */function validateQueryEndpoints(params){let startNode=null;let endNode=null;if(params.hasStart()){startNode=params.getIndexStartValue();}if(params.hasEnd()){endNode=params.getIndexEndValue();}if(params.getIndex()===KEY_INDEX){const tooManyArgsError='Query: When ordering by key, you may only pass one argument to '+'startAt(), endAt(), or equalTo().';const wrongArgTypeError='Query: When ordering by key, the argument passed to startAt(), startAfter(), '+'endAt(), endBefore(), or equalTo() must be a string.';if(params.hasStart()){const startName=params.getIndexStartName();if(startName!==MIN_NAME){throw new Error(tooManyArgsError);}else if(typeof startNode!=='string'){throw new Error(wrongArgTypeError);}}if(params.hasEnd()){const endName=params.getIndexEndName();if(endName!==MAX_NAME){throw new Error(tooManyArgsError);}else if(typeof endNode!=='string'){throw new Error(wrongArgTypeError);}}}else if(params.getIndex()===PRIORITY_INDEX){if(startNode!=null&&!isValidPriority(startNode)||endNode!=null&&!isValidPriority(endNode)){throw new Error('Query: When ordering by priority, the first argument passed to startAt(), '+'startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value '+'(null, a number, or a string).');}}else{(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(params.getIndex()instanceof PathIndex||params.getIndex()===VALUE_INDEX,'unknown index type.');if(startNode!=null&&typeof startNode==='object'||endNode!=null&&typeof endNode==='object'){throw new Error('Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or '+'equalTo() cannot be an object.');}}}/**\r\n * Validates that limit* has been called with the correct combination of parameters\r\n */function validateLimit(params){if(params.hasStart()&&params.hasEnd()&&params.hasLimit()&&!params.hasAnchoredLimit()){throw new Error(\"Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use \"+'limitToFirst() or limitToLast() instead.');}}/**\r\n * @internal\r\n */class ReferenceImpl extends QueryImpl{/** @hideconstructor */constructor(repo,path){super(repo,path,new QueryParams(),false);}get parent(){const parentPath=pathParent(this._path);return parentPath===null?null:new ReferenceImpl(this._repo,parentPath);}get root(){let ref=this;while(ref.parent!==null){ref=ref.parent;}return ref;}}/**\r\n * A `DataSnapshot` contains data from a Database location.\r\n *\r\n * Any time you read data from the Database, you receive the data as a\r\n * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach\r\n * with `on()` or `once()`. You can extract the contents of the snapshot as a\r\n * JavaScript object by calling the `val()` method. Alternatively, you can\r\n * traverse into the snapshot by calling `child()` to return child snapshots\r\n * (which you could then call `val()` on).\r\n *\r\n * A `DataSnapshot` is an efficiently generated, immutable copy of the data at\r\n * a Database location. It cannot be modified and will never change (to modify\r\n * data, you always call the `set()` method on a `Reference` directly).\r\n */class DataSnapshot{/**\r\n     * @param _node - A SnapshotNode to wrap.\r\n     * @param ref - The location this snapshot came from.\r\n     * @param _index - The iteration order for this snapshot\r\n     * @hideconstructor\r\n     */constructor(_node,/**\r\n     * The location of this DataSnapshot.\r\n     */ref,_index){this._node=_node;this.ref=ref;this._index=_index;}/**\r\n     * Gets the priority value of the data in this `DataSnapshot`.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}\r\n     * ).\r\n     */get priority(){// typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\nreturn this._node.getPriority().val();}/**\r\n     * The key (last part of the path) of the location of this `DataSnapshot`.\r\n     *\r\n     * The last token in a Database location is considered its key. For example,\r\n     * \"ada\" is the key for the /users/ada/ node. Accessing the key on any\r\n     * `DataSnapshot` will return the key for the location that generated it.\r\n     * However, accessing the key on the root URL of a Database will return\r\n     * `null`.\r\n     */get key(){return this.ref.key;}/** Returns the number of child properties of this `DataSnapshot`. */get size(){return this._node.numChildren();}/**\r\n     * Gets another `DataSnapshot` for the location at the specified relative path.\r\n     *\r\n     * Passing a relative path to the `child()` method of a DataSnapshot returns\r\n     * another `DataSnapshot` for the location at the specified relative path. The\r\n     * relative path can either be a simple child name (for example, \"ada\") or a\r\n     * deeper, slash-separated path (for example, \"ada/name/first\"). If the child\r\n     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`\r\n     * whose value is `null`) is returned.\r\n     *\r\n     * @param path - A relative path to the location of child data.\r\n     */child(path){const childPath=new Path(path);const childRef=child(this.ref,path);return new DataSnapshot(this._node.getChild(childPath),childRef,PRIORITY_INDEX);}/**\r\n     * Returns true if this `DataSnapshot` contains any data. It is slightly more\r\n     * efficient than using `snapshot.val() !== null`.\r\n     */exists(){return!this._node.isEmpty();}/**\r\n     * Exports the entire contents of the DataSnapshot as a JavaScript object.\r\n     *\r\n     * The `exportVal()` method is similar to `val()`, except priority information\r\n     * is included (if available), making it suitable for backing up your data.\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nexportVal(){return this._node.val(true);}/**\r\n     * Enumerates the top-level children in the `DataSnapshot`.\r\n     *\r\n     * Because of the way JavaScript objects work, the ordering of data in the\r\n     * JavaScript object returned by `val()` is not guaranteed to match the\r\n     * ordering on the server nor the ordering of `onChildAdded()` events. That is\r\n     * where `forEach()` comes in handy. It guarantees the children of a\r\n     * `DataSnapshot` will be iterated in their query order.\r\n     *\r\n     * If no explicit `orderBy*()` method is used, results are returned\r\n     * ordered by key (unless priorities are used, in which case, results are\r\n     * returned by priority).\r\n     *\r\n     * @param action - A function that will be called for each child DataSnapshot.\r\n     * The callback can return true to cancel further enumeration.\r\n     * @returns true if enumeration was canceled due to your callback returning\r\n     * true.\r\n     */forEach(action){if(this._node.isLeafNode()){return false;}const childrenNode=this._node;// Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\nreturn!!childrenNode.forEachChild(this._index,(key,node)=>{return action(new DataSnapshot(node,child(this.ref,key),PRIORITY_INDEX));});}/**\r\n     * Returns true if the specified child path has (non-null) data.\r\n     *\r\n     * @param path - A relative path to the location of a potential child.\r\n     * @returns `true` if data exists at the specified child path; else\r\n     *  `false`.\r\n     */hasChild(path){const childPath=new Path(path);return!this._node.getChild(childPath).isEmpty();}/**\r\n     * Returns whether or not the `DataSnapshot` has any non-`null` child\r\n     * properties.\r\n     *\r\n     * You can use `hasChildren()` to determine if a `DataSnapshot` has any\r\n     * children. If it does, you can enumerate them using `forEach()`. If it\r\n     * doesn't, then either this snapshot contains a primitive value (which can be\r\n     * retrieved with `val()`) or it is empty (in which case, `val()` will return\r\n     * `null`).\r\n     *\r\n     * @returns true if this snapshot has any children; else false.\r\n     */hasChildren(){if(this._node.isLeafNode()){return false;}else{return!this._node.isEmpty();}}/**\r\n     * Returns a JSON-serializable representation of this object.\r\n     */toJSON(){return this.exportVal();}/**\r\n     * Extracts a JavaScript value from a `DataSnapshot`.\r\n     *\r\n     * Depending on the data in a `DataSnapshot`, the `val()` method may return a\r\n     * scalar type (string, number, or boolean), an array, or an object. It may\r\n     * also return null, indicating that the `DataSnapshot` is empty (contains no\r\n     * data).\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nval(){return this._node.val();}}/**\r\n *\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided path. If no path is provided, the `Reference`\r\n * will point to the root of the Database.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param path - Optional path representing the location the returned\r\n *   `Reference` will point. If not provided, the returned `Reference` will\r\n *   point to the root of the Database.\r\n * @returns If a path is provided, a `Reference`\r\n *   pointing to the provided path. Otherwise, a `Reference` pointing to the\r\n *   root of the Database.\r\n */function ref(db,path){db=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);db._checkNotDeleted('ref');return path!==undefined?child(db._root,path):db._root;}/**\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided Firebase URL.\r\n *\r\n * An exception is thrown if the URL is not a valid Firebase Database URL or it\r\n * has a different domain than the current `Database` instance.\r\n *\r\n * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored\r\n * and are not applied to the returned `Reference`.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param url - The Firebase URL at which the returned `Reference` will\r\n *   point.\r\n * @returns A `Reference` pointing to the provided\r\n *   Firebase URL.\r\n */function refFromURL(db,url){db=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);db._checkNotDeleted('refFromURL');const parsedURL=parseRepoInfo(url,db._repo.repoInfo_.nodeAdmin);validateUrl('refFromURL',parsedURL);const repoInfo=parsedURL.repoInfo;if(!db._repo.repoInfo_.isCustomHost()&&repoInfo.host!==db._repo.repoInfo_.host){fatal('refFromURL'+': Host name does not match the current database: '+'(found '+repoInfo.host+' but expected '+db._repo.repoInfo_.host+')');}return ref(db,parsedURL.path.toString());}/**\r\n * Gets a `Reference` for the location at the specified relative path.\r\n *\r\n * The relative path can either be a simple child name (for example, \"ada\") or\r\n * a deeper slash-separated path (for example, \"ada/name/first\").\r\n *\r\n * @param parent - The parent location.\r\n * @param path - A relative path from this location to the desired child\r\n *   location.\r\n * @returns The specified child location.\r\n */function child(parent,path){parent=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(parent);if(pathGetFront(parent._path)===null){validateRootPathString('child','path',path,false);}else{validatePathString('child','path',path,false);}return new ReferenceImpl(parent._repo,pathChild(parent._path,path));}/**\r\n * Returns an `OnDisconnect` object - see\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information on how to use it.\r\n *\r\n * @param ref - The reference to add OnDisconnect triggers for.\r\n */function onDisconnect(ref){ref=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);return new OnDisconnect(ref._repo,ref._path);}/**\r\n * Generates a new child location using a unique key and returns its\r\n * `Reference`.\r\n *\r\n * This is the most common pattern for adding data to a collection of items.\r\n *\r\n * If you provide a value to `push()`, the value is written to the\r\n * generated location. If you don't pass a value, nothing is written to the\r\n * database and the child remains empty (but you can use the `Reference`\r\n * elsewhere).\r\n *\r\n * The unique keys generated by `push()` are ordered by the current time, so the\r\n * resulting list of items is chronologically sorted. The keys are also\r\n * designed to be unguessable (they contain 72 random bits of entropy).\r\n *\r\n * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}\r\n * </br>See {@link ttps://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}\r\n *\r\n * @param parent - The parent location.\r\n * @param value - Optional value to be written at the generated location.\r\n * @returns Combined `Promise` and `Reference`; resolves when write is complete,\r\n * but can be used immediately as the `Reference` to the child location.\r\n */function push(parent,value){parent=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(parent);validateWritablePath('push',parent._path);validateFirebaseDataArg('push',value,parent._path,true);const now=repoServerTime(parent._repo);const name=nextPushId(now);// push() returns a ThennableReference whose promise is fulfilled with a\n// regular Reference. We use child() to create handles to two different\n// references. The first is turned into a ThennableReference below by adding\n// then() and catch() methods and is used as the return value of push(). The\n// second remains a regular Reference and is used as the fulfilled value of\n// the first ThennableReference.\nconst thennablePushRef=child(parent,name);const pushRef=child(parent,name);let promise;if(value!=null){promise=set(pushRef,value).then(()=>pushRef);}else{promise=Promise.resolve(pushRef);}thennablePushRef.then=promise.then.bind(promise);thennablePushRef.catch=promise.then.bind(promise,undefined);return thennablePushRef;}/**\r\n * Removes the data at this Database location.\r\n *\r\n * Any data at child locations will also be deleted.\r\n *\r\n * The effect of the remove will be visible immediately and the corresponding\r\n * event 'value' will be triggered. Synchronization of the remove to the\r\n * Firebase servers will also be started, and the returned Promise will resolve\r\n * when complete. If provided, the onComplete callback will be called\r\n * asynchronously after synchronization has finished.\r\n *\r\n * @param ref - The location to remove.\r\n * @returns Resolves when remove on server is complete.\r\n */function remove(ref){validateWritablePath('remove',ref._path);return set(ref,null);}/**\r\n * Writes data to this Database location.\r\n *\r\n * This will overwrite any data at this location and all child locations.\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events (\"value\", \"child_added\", etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * Passing `null` for the new value is equivalent to calling `remove()`; namely,\r\n * all data at this location and all child locations will be deleted.\r\n *\r\n * `set()` will remove any priority stored at this location, so if priority is\r\n * meant to be preserved, you need to use `setWithPriority()` instead.\r\n *\r\n * Note that modifying data with `set()` will cancel any pending transactions\r\n * at that location, so extreme care should be taken if mixing `set()` and\r\n * `transaction()` to modify the same data.\r\n *\r\n * A single `set()` will generate a single \"value\" event at the location where\r\n * the `set()` was performed.\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @returns Resolves when write to server is complete.\r\n */function set(ref,value){ref=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);validateWritablePath('set',ref._path);validateFirebaseDataArg('set',value,ref._path,false);const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoSetWithPriority(ref._repo,ref._path,value,/*priority=*/null,deferred.wrapCallback(()=>{}));return deferred.promise;}/**\r\n * Sets a priority for the data at this Database location.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */function setPriority(ref,priority){ref=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);validateWritablePath('setPriority',ref._path);validatePriority('setPriority',priority,false);const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoSetWithPriority(ref._repo,pathChild(ref._path,'.priority'),priority,null,deferred.wrapCallback(()=>{}));return deferred.promise;}/**\r\n * Writes data the Database location. Like `set()` but also specifies the\r\n * priority for that data.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */function setWithPriority(ref,value,priority){validateWritablePath('setWithPriority',ref._path);validateFirebaseDataArg('setWithPriority',value,ref._path,false);validatePriority('setWithPriority',priority,false);if(ref.key==='.length'||ref.key==='.keys'){throw'setWithPriority failed: '+ref.key+' is a read-only object.';}const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoSetWithPriority(ref._repo,ref._path,value,priority,deferred.wrapCallback(()=>{}));return deferred.promise;}/**\r\n * Writes multiple values to the Database at once.\r\n *\r\n * The `values` argument contains multiple property-value pairs that will be\r\n * written to the Database together. Each child property can either be a simple\r\n * property (for example, \"name\") or a relative path (for example,\r\n * \"name/first\") from the current location to the data to update.\r\n *\r\n * As opposed to the `set()` method, `update()` can be use to selectively update\r\n * only the referenced properties at the current location (instead of replacing\r\n * all the child properties at the current location).\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events ('value', 'child_added', etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * A single `update()` will generate a single \"value\" event at the location\r\n * where the `update()` was performed, regardless of how many children were\r\n * modified.\r\n *\r\n * Note that modifying data with `update()` will cancel any pending\r\n * transactions at that location, so extreme care should be taken if mixing\r\n * `update()` and `transaction()` to modify the same data.\r\n *\r\n * Passing `null` to `update()` will remove the data at this location.\r\n *\r\n * See\r\n * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.\r\n *\r\n * @param ref - The location to write to.\r\n * @param values - Object containing multiple values.\r\n * @returns Resolves when update on server is complete.\r\n */function update(ref,values){validateFirebaseMergeDataArg('update',values,ref._path,false);const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();repoUpdate(ref._repo,ref._path,values,deferred.wrapCallback(()=>{}));return deferred.promise;}/**\r\n * Gets the most up-to-date result for this query.\r\n *\r\n * @param query - The query to run.\r\n * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is\r\n * available, or rejects if the client is unable to return a value (e.g., if the\r\n * server is unreachable and there is nothing cached).\r\n */function get(query){query=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(query);return repoGetValue(query._repo,query).then(node=>{return new DataSnapshot(node,new ReferenceImpl(query._repo,query._path),query._queryParams.getIndex());});}/**\r\n * Represents registration for 'value' events.\r\n */class ValueEventRegistration{constructor(callbackContext){this.callbackContext=callbackContext;}respondsTo(eventType){return eventType==='value';}createEvent(change,query){const index=query._queryParams.getIndex();return new DataEvent('value',this,new DataSnapshot(change.snapshotNode,new ReferenceImpl(query._repo,query._path),index));}getEventRunner(eventData){if(eventData.getEventType()==='cancel'){return()=>this.callbackContext.onCancel(eventData.error);}else{return()=>this.callbackContext.onValue(eventData.snapshot,null);}}createCancelEvent(error,path){if(this.callbackContext.hasCancelCallback){return new CancelEvent(this,error,path);}else{return null;}}matches(other){if(!(other instanceof ValueEventRegistration)){return false;}else if(!other.callbackContext||!this.callbackContext){// If no callback specified, we consider it to match any callback.\nreturn true;}else{return other.callbackContext.matches(this.callbackContext);}}hasAnyCallback(){return this.callbackContext!==null;}}/**\r\n * Represents the registration of a child_x event.\r\n */class ChildEventRegistration{constructor(eventType,callbackContext){this.eventType=eventType;this.callbackContext=callbackContext;}respondsTo(eventType){let eventToCheck=eventType==='children_added'?'child_added':eventType;eventToCheck=eventToCheck==='children_removed'?'child_removed':eventToCheck;return this.eventType===eventToCheck;}createCancelEvent(error,path){if(this.callbackContext.hasCancelCallback){return new CancelEvent(this,error,path);}else{return null;}}createEvent(change,query){(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(change.childName!=null,'Child events should have a childName.');const childRef=child(new ReferenceImpl(query._repo,query._path),change.childName);const index=query._queryParams.getIndex();return new DataEvent(change.type,this,new DataSnapshot(change.snapshotNode,childRef,index),change.prevName);}getEventRunner(eventData){if(eventData.getEventType()==='cancel'){return()=>this.callbackContext.onCancel(eventData.error);}else{return()=>this.callbackContext.onValue(eventData.snapshot,eventData.prevName);}}matches(other){if(other instanceof ChildEventRegistration){return this.eventType===other.eventType&&(!this.callbackContext||!other.callbackContext||this.callbackContext.matches(other.callbackContext));}return false;}hasAnyCallback(){return!!this.callbackContext;}}function addEventListener(query,eventType,callback,cancelCallbackOrListenOptions,options){let cancelCallback;if(typeof cancelCallbackOrListenOptions==='object'){cancelCallback=undefined;options=cancelCallbackOrListenOptions;}if(typeof cancelCallbackOrListenOptions==='function'){cancelCallback=cancelCallbackOrListenOptions;}if(options&&options.onlyOnce){const userCallback=callback;const onceCallback=(dataSnapshot,previousChildName)=>{repoRemoveEventCallbackForQuery(query._repo,query,container);userCallback(dataSnapshot,previousChildName);};onceCallback.userCallback=callback.userCallback;onceCallback.context=callback.context;callback=onceCallback;}const callbackContext=new CallbackContext(callback,cancelCallback||undefined);const container=eventType==='value'?new ValueEventRegistration(callbackContext):new ChildEventRegistration(eventType,callbackContext);repoAddEventCallbackForQuery(query._repo,query,container);return()=>repoRemoveEventCallbackForQuery(query._repo,query,container);}function onValue(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'value',callback,cancelCallbackOrListenOptions,options);}function onChildAdded(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'child_added',callback,cancelCallbackOrListenOptions,options);}function onChildChanged(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'child_changed',callback,cancelCallbackOrListenOptions,options);}function onChildMoved(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'child_moved',callback,cancelCallbackOrListenOptions,options);}function onChildRemoved(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'child_removed',callback,cancelCallbackOrListenOptions,options);}/**\r\n * Detaches a callback previously attached with `on()`.\r\n *\r\n * Detach a callback previously attached with `on()`. Note that if `on()` was\r\n * called multiple times with the same eventType and callback, the callback\r\n * will be called multiple times for each event, and `off()` must be called\r\n * multiple times to remove the callback. Calling `off()` on a parent listener\r\n * will not automatically remove listeners registered on child nodes, `off()`\r\n * must also be called on any child listeners to remove the callback.\r\n *\r\n * If a callback is not specified, all callbacks for the specified eventType\r\n * will be removed. Similarly, if no eventType is specified, all callbacks\r\n * for the `Reference` will be removed.\r\n *\r\n * Individual listeners can also be removed by invoking their unsubscribe\r\n * callbacks.\r\n *\r\n * @param query - The query that the listener was registered with.\r\n * @param eventType - One of the following strings: \"value\", \"child_added\",\r\n * \"child_changed\", \"child_removed\", or \"child_moved.\" If omitted, all callbacks\r\n * for the `Reference` will be removed.\r\n * @param callback - The callback function that was passed to `on()` or\r\n * `undefined` to remove all callbacks.\r\n */function off(query,eventType,callback){let container=null;const expCallback=callback?new CallbackContext(callback):null;if(eventType==='value'){container=new ValueEventRegistration(expCallback);}else if(eventType){container=new ChildEventRegistration(eventType,expCallback);}repoRemoveEventCallbackForQuery(query._repo,query,container);}/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Database query. `QueryConstraint`s are created by invoking {@link endAt},\r\n * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link\r\n * limitToFirst}, {@link limitToLast}, {@link orderByChild},\r\n * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,\r\n * {@link orderByValue}  or {@link equalTo} and\r\n * can then be passed to {@link query} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */class QueryConstraint{}class QueryEndAtConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('endAt',this._value,query._path,true);const newParams=queryParamsEndAt(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasEnd()){throw new Error('endAt: Starting point was already set (by another call to endAt, '+'endBefore or equalTo).');}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled);}}/**\r\n * Creates a `QueryConstraint` with the specified ending point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name less than or equal\r\n * to the specified key.\r\n *\r\n * You can read more about `endAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to end at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end at, among the children with the previously\r\n * specified priority. This argument is only allowed if ordering by child,\r\n * value, or priority.\r\n */function endAt(value,key){validateKey('endAt','key',key,true);return new QueryEndAtConstraint(value,key);}class QueryEndBeforeConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('endBefore',this._value,query._path,false);const newParams=queryParamsEndBefore(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasEnd()){throw new Error('endBefore: Starting point was already set (by another call to endAt, '+'endBefore or equalTo).');}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled);}}/**\r\n * Creates a `QueryConstraint` with the specified ending point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is exclusive. If only a value is provided, children\r\n * with a value less than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value lesss than or equal\r\n * to the specified value and a a key name less than the specified key.\r\n *\r\n * @param value - The value to end before. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end before, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */function endBefore(value,key){validateKey('endBefore','key',key,true);return new QueryEndBeforeConstraint(value,key);}class QueryStartAtConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('startAt',this._value,query._path,true);const newParams=queryParamsStartAt(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasStart()){throw new Error('startAt: Starting point was already set (by another call to startAt, '+'startBefore or equalTo).');}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled);}}/**\r\n * Creates a `QueryConstraint` with the specified starting point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name greater than or\r\n * equal to the specified key.\r\n *\r\n * You can read more about `startAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to start at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */function startAt(value=null,key){validateKey('startAt','key',key,true);return new QueryStartAtConstraint(value,key);}class QueryStartAfterConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('startAfter',this._value,query._path,false);const newParams=queryParamsStartAfter(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasStart()){throw new Error('startAfter: Starting point was already set (by another call to startAt, '+'startAfter, or equalTo).');}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled);}}/**\r\n * Creates a `QueryConstraint` with the specified starting point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is exclusive. If only a value is provided, children\r\n * with a value greater than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value greater than or equal\r\n * to the specified value and a a key name greater than the specified key.\r\n *\r\n * @param value - The value to start after. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start after. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */function startAfter(value,key){validateKey('startAfter','key',key,true);return new QueryStartAfterConstraint(value,key);}class QueryLimitToFirstConstraint extends QueryConstraint{constructor(_limit){super();this._limit=_limit;}_apply(query){if(query._queryParams.hasLimit()){throw new Error('limitToFirst: Limit was already set (by another call to limitToFirst '+'or limitToLast).');}return new QueryImpl(query._repo,query._path,queryParamsLimitToFirst(query._queryParams,this._limit),query._orderByCalled);}}/**\r\n * Creates a new `QueryConstraint` that if limited to the first specific number\r\n * of children.\r\n *\r\n * The `limitToFirst()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the first 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToFirst()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */function limitToFirst(limit){if(typeof limit!=='number'||Math.floor(limit)!==limit||limit<=0){throw new Error('limitToFirst: First argument must be a positive integer.');}return new QueryLimitToFirstConstraint(limit);}class QueryLimitToLastConstraint extends QueryConstraint{constructor(_limit){super();this._limit=_limit;}_apply(query){if(query._queryParams.hasLimit()){throw new Error('limitToLast: Limit was already set (by another call to limitToFirst '+'or limitToLast).');}return new QueryImpl(query._repo,query._path,queryParamsLimitToLast(query._queryParams,this._limit),query._orderByCalled);}}/**\r\n * Creates a new `QueryConstraint` that is limited to return only the last\r\n * specified number of children.\r\n *\r\n * The `limitToLast()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the last 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToLast()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */function limitToLast(limit){if(typeof limit!=='number'||Math.floor(limit)!==limit||limit<=0){throw new Error('limitToLast: First argument must be a positive integer.');}return new QueryLimitToLastConstraint(limit);}class QueryOrderByChildConstraint extends QueryConstraint{constructor(_path){super();this._path=_path;}_apply(query){validateNoPreviousOrderByCall(query,'orderByChild');const parsedPath=new Path(this._path);if(pathIsEmpty(parsedPath)){throw new Error('orderByChild: cannot pass in empty path. Use orderByValue() instead.');}const index=new PathIndex(parsedPath);const newParams=queryParamsOrderBy(query._queryParams,index);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,/*orderByCalled=*/true);}}/**\r\n * Creates a new `QueryConstraint` that orders by the specified child key.\r\n *\r\n * Queries can only order by one key at a time. Calling `orderByChild()`\r\n * multiple times on the same query is an error.\r\n *\r\n * Firebase queries allow you to order your data by any child key on the fly.\r\n * However, if you know in advance what your indexes will be, you can define\r\n * them via the .indexOn rule in your Security Rules for better performance. See\r\n * the{@link https://firebase.google.com/docs/database/security/indexing-data}\r\n * rule for more information.\r\n *\r\n * You can read more about `orderByChild()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n *\r\n * @param path - The path to order by.\r\n */function orderByChild(path){if(path==='$key'){throw new Error('orderByChild: \"$key\" is invalid.  Use orderByKey() instead.');}else if(path==='$priority'){throw new Error('orderByChild: \"$priority\" is invalid.  Use orderByPriority() instead.');}else if(path==='$value'){throw new Error('orderByChild: \"$value\" is invalid.  Use orderByValue() instead.');}validatePathString('orderByChild','path',path,false);return new QueryOrderByChildConstraint(path);}class QueryOrderByKeyConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,'orderByKey');const newParams=queryParamsOrderBy(query._queryParams,KEY_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,/*orderByCalled=*/true);}}/**\r\n * Creates a new `QueryConstraint` that orders by the key.\r\n *\r\n * Sorts the results of a query by their (ascending) key values.\r\n *\r\n * You can read more about `orderByKey()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */function orderByKey(){return new QueryOrderByKeyConstraint();}class QueryOrderByPriorityConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,'orderByPriority');const newParams=queryParamsOrderBy(query._queryParams,PRIORITY_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,/*orderByCalled=*/true);}}/**\r\n * Creates a new `QueryConstraint` that orders by priority.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}\r\n * for alternatives to priority.\r\n */function orderByPriority(){return new QueryOrderByPriorityConstraint();}class QueryOrderByValueConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,'orderByValue');const newParams=queryParamsOrderBy(query._queryParams,VALUE_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,/*orderByCalled=*/true);}}/**\r\n * Creates a new `QueryConstraint` that orders by value.\r\n *\r\n * If the children of a query are all scalar values (string, number, or\r\n * boolean), you can order the results by their (ascending) values.\r\n *\r\n * You can read more about `orderByValue()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */function orderByValue(){return new QueryOrderByValueConstraint();}class QueryEqualToValueConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('equalTo',this._value,query._path,false);if(query._queryParams.hasStart()){throw new Error('equalTo: Starting point was already set (by another call to startAt/startAfter or '+'equalTo).');}if(query._queryParams.hasEnd()){throw new Error('equalTo: Ending point was already set (by another call to endAt/endBefore or '+'equalTo).');}return new QueryEndAtConstraint(this._value,this._key)._apply(new QueryStartAtConstraint(this._value,this._key)._apply(query));}}/**\r\n * Creates a `QueryConstraint` that includes children that match the specified\r\n * value.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The optional key argument can be used to further limit the range of the\r\n * query. If it is specified, then children that have exactly the specified\r\n * value must also have exactly the specified key as their key name. This can be\r\n * used to filter result sets with many matches for the same value.\r\n *\r\n * You can read more about `equalTo()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to match for. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */function equalTo(value,key){validateKey('equalTo','key',key,true);return new QueryEqualToValueConstraint(value,key);}/**\r\n * Creates a new immutable instance of `Query` that is extended to also include\r\n * additional query constraints.\r\n *\r\n * @param query - The Query instance to use as a base for the new constraints.\r\n * @param queryConstraints - The list of `QueryConstraint`s to apply.\r\n * @throws if any of the provided query constraints cannot be combined with the\r\n * existing or new constraints.\r\n */function query(query,...queryConstraints){let queryImpl=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(query);for(const constraint of queryConstraints){queryImpl=constraint._apply(queryImpl);}return queryImpl;}/**\r\n * Define reference constructor in various modules\r\n *\r\n * We are doing this here to avoid several circular\r\n * dependency issues\r\n */syncPointSetReferenceConstructor(ReferenceImpl);syncTreeSetReferenceConstructor(ReferenceImpl);/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This variable is also defined in the firebase Node.js Admin SDK. Before\r\n * modifying this definition, consult the definition in:\r\n *\r\n * https://github.com/firebase/firebase-admin-node\r\n *\r\n * and make sure the two are consistent.\r\n */const FIREBASE_DATABASE_EMULATOR_HOST_VAR='FIREBASE_DATABASE_EMULATOR_HOST';/**\r\n * Creates and caches `Repo` instances.\r\n */const repos={};/**\r\n * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).\r\n */let useRestClient=false;/**\r\n * Update an existing `Repo` in place to point to a new host/port.\r\n */function repoManagerApplyEmulatorSettings(repo,host,port,tokenProvider){repo.repoInfo_=new RepoInfo(`${host}:${port}`,/* secure= */false,repo.repoInfo_.namespace,repo.repoInfo_.webSocketOnly,repo.repoInfo_.nodeAdmin,repo.repoInfo_.persistenceKey,repo.repoInfo_.includeNamespaceInQueryParams);if(tokenProvider){repo.authTokenProvider_=tokenProvider;}}/**\r\n * This function should only ever be called to CREATE a new database instance.\r\n * @internal\r\n */function repoManagerDatabaseFromApp(app,authProvider,appCheckProvider,url,nodeAdmin){let dbUrl=url||app.options.databaseURL;if(dbUrl===undefined){if(!app.options.projectId){fatal(\"Can't determine Firebase Database URL. Be sure to include \"+' a Project ID when calling firebase.initializeApp().');}log('Using default host for project ',app.options.projectId);dbUrl=`${app.options.projectId}-default-rtdb.firebaseio.com`;}let parsedUrl=parseRepoInfo(dbUrl,nodeAdmin);let repoInfo=parsedUrl.repoInfo;let isEmulator;let dbEmulatorHost=undefined;if(typeof process!=='undefined'){dbEmulatorHost=process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];}if(dbEmulatorHost){isEmulator=true;dbUrl=`http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;parsedUrl=parseRepoInfo(dbUrl,nodeAdmin);repoInfo=parsedUrl.repoInfo;}else{isEmulator=!parsedUrl.repoInfo.secure;}const authTokenProvider=nodeAdmin&&isEmulator?new EmulatorTokenProvider(EmulatorTokenProvider.OWNER):new FirebaseAuthTokenProvider(app.name,app.options,authProvider);validateUrl('Invalid Firebase Database URL',parsedUrl);if(!pathIsEmpty(parsedUrl.path)){fatal('Database URL must point to the root of a Firebase Database '+'(not including a child path).');}const repo=repoManagerCreateRepo(repoInfo,app,authTokenProvider,new AppCheckTokenProvider(app.name,appCheckProvider));return new Database(repo,app);}/**\r\n * Remove the repo and make sure it is disconnected.\r\n *\r\n */function repoManagerDeleteRepo(repo,appName){const appRepos=repos[appName];// This should never happen...\nif(!appRepos||appRepos[repo.key]!==repo){fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);}repoInterrupt(repo);delete appRepos[repo.key];}/**\r\n * Ensures a repo doesn't already exist and then creates one using the\r\n * provided app.\r\n *\r\n * @param repoInfo - The metadata about the Repo\r\n * @returns The Repo object for the specified server / repoName.\r\n */function repoManagerCreateRepo(repoInfo,app,authTokenProvider,appCheckProvider){let appRepos=repos[app.name];if(!appRepos){appRepos={};repos[app.name]=appRepos;}let repo=appRepos[repoInfo.toURLString()];if(repo){fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');}repo=new Repo(repoInfo,useRestClient,authTokenProvider,appCheckProvider);appRepos[repoInfo.toURLString()]=repo;return repo;}/**\r\n * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\r\n */function repoManagerForceRestClient(forceRestClient){useRestClient=forceRestClient;}/**\r\n * Class representing a Firebase Realtime Database.\r\n */class Database{/** @hideconstructor */constructor(_repoInternal,/** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */app){this._repoInternal=_repoInternal;this.app=app;/** Represents a `Database` instance. */this['type']='database';/** Track if the instance has been used (root or repo accessed) */this._instanceStarted=false;}get _repo(){if(!this._instanceStarted){repoStart(this._repoInternal,this.app.options.appId,this.app.options['databaseAuthVariableOverride']);this._instanceStarted=true;}return this._repoInternal;}get _root(){if(!this._rootInternal){this._rootInternal=new ReferenceImpl(this._repo,newEmptyPath());}return this._rootInternal;}_delete(){if(this._rootInternal!==null){repoManagerDeleteRepo(this._repo,this.app.name);this._repoInternal=null;this._rootInternal=null;}return Promise.resolve();}_checkNotDeleted(apiName){if(this._rootInternal===null){fatal('Cannot call '+apiName+' on a deleted database.');}}}/**\r\n * Returns the instance of the Realtime Database SDK that is associated\r\n * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with\r\n * with default settings if no instance exists or if the existing instance uses\r\n * a custom database URL.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime\r\n * Database instance is associated with.\r\n * @param url - The URL of the Realtime Database instance to connect to. If not\r\n * provided, the SDK connects to the default instance of the Firebase App.\r\n * @returns The `Database` instance of the provided app.\r\n */function getDatabase(app=(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(),url){return (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app,'database').getImmediate({identifier:url});}/**\r\n * Modify the provided instance to communicate with the Realtime Database\r\n * emulator.\r\n *\r\n * <p>Note: This method must be called before performing any other operation.\r\n *\r\n * @param db - The instance to modify.\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 8080)\r\n * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules\r\n */function connectDatabaseEmulator(db,host,port,options={}){db=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);db._checkNotDeleted('useEmulator');if(db._instanceStarted){fatal('Cannot call useEmulator() after instance has already been initialized.');}const repo=db._repoInternal;let tokenProvider=undefined;if(repo.repoInfo_.nodeAdmin){if(options.mockUserToken){fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the \"firebase\" package instead of \"firebase-admin\".');}tokenProvider=new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);}else if(options.mockUserToken){const token=typeof options.mockUserToken==='string'?options.mockUserToken:(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.createMockUserToken)(options.mockUserToken,db.app.options.projectId);tokenProvider=new EmulatorTokenProvider(token);}// Modify the repo to apply emulator settings\nrepoManagerApplyEmulatorSettings(repo,host,port,tokenProvider);}/**\r\n * Disconnects from the server (all Database operations will be completed\r\n * offline).\r\n *\r\n * The client automatically maintains a persistent connection to the Database\r\n * server, which will remain active indefinitely and reconnect when\r\n * disconnected. However, the `goOffline()` and `goOnline()` methods may be used\r\n * to control the client connection in cases where a persistent connection is\r\n * undesirable.\r\n *\r\n * While offline, the client will no longer receive data updates from the\r\n * Database. However, all Database operations performed locally will continue to\r\n * immediately fire events, allowing your application to continue behaving\r\n * normally. Additionally, each operation performed locally will automatically\r\n * be queued and retried upon reconnection to the Database server.\r\n *\r\n * To reconnect to the Database and begin receiving remote events, see\r\n * `goOnline()`.\r\n *\r\n * @param db - The instance to disconnect.\r\n */function goOffline(db){db=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);db._checkNotDeleted('goOffline');repoInterrupt(db._repo);}/**\r\n * Reconnects to the server and synchronizes the offline Database state\r\n * with the server state.\r\n *\r\n * This method should be used after disabling the active connection with\r\n * `goOffline()`. Once reconnected, the client will transmit the proper data\r\n * and fire the appropriate events so that your client \"catches up\"\r\n * automatically.\r\n *\r\n * @param db - The instance to reconnect.\r\n */function goOnline(db){db=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);db._checkNotDeleted('goOnline');repoResume(db._repo);}function enableLogging(logger,persistent){enableLogging$1(logger,persistent);}/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */function registerDatabase(variant){setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('database',(container,{instanceIdentifier:url})=>{const app=container.getProvider('app').getImmediate();const authProvider=container.getProvider('auth-internal');const appCheckProvider=container.getProvider('app-check-internal');return repoManagerDatabaseFromApp(app,authProvider,appCheckProvider,url);},\"PUBLIC\"/* PUBLIC */).setMultipleInstances(true));(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name,version,variant);// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name,version,'esm2017');}/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */const SERVER_TIMESTAMP={'.sv':'timestamp'};/**\r\n * Returns a placeholder value for auto-populating the current timestamp (time\r\n * since the Unix epoch, in milliseconds) as determined by the Firebase\r\n * servers.\r\n */function serverTimestamp(){return SERVER_TIMESTAMP;}/**\r\n * Returns a placeholder value that can be used to atomically increment the\r\n * current database value by the provided delta.\r\n *\r\n * @param delta - the amount to modify the current value atomically.\r\n * @returns A placeholder value for modifying data atomically server-side.\r\n */function increment(delta){return{'.sv':{'increment':delta}};}/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A type for the resolve value of {@link runTransaction}.\r\n */class TransactionResult{/** @hideconstructor */constructor(/** Whether the transaction was successfully committed. */committed,/** The resulting data snapshot. */snapshot){this.committed=committed;this.snapshot=snapshot;}/** Returns a JSON-serializable representation of this object. */toJSON(){return{committed:this.committed,snapshot:this.snapshot.toJSON()};}}/**\r\n * Atomically modifies the data at this location.\r\n *\r\n * Atomically modify the data at this location. Unlike a normal `set()`, which\r\n * just overwrites the data regardless of its previous value, `runTransaction()` is\r\n * used to modify the existing value to a new value, ensuring there are no\r\n * conflicts with other clients writing to the same location at the same time.\r\n *\r\n * To accomplish this, you pass `runTransaction()` an update function which is\r\n * used to transform the current value into a new value. If another client\r\n * writes to the location before your new value is successfully written, your\r\n * update function will be called again with the new current value, and the\r\n * write will be retried. This will happen repeatedly until your write succeeds\r\n * without conflict or you abort the transaction by not returning a value from\r\n * your update function.\r\n *\r\n * Note: Modifying data with `set()` will cancel any pending transactions at\r\n * that location, so extreme care should be taken if mixing `set()` and\r\n * `runTransaction()` to update the same data.\r\n *\r\n * Note: When using transactions with Security and Firebase Rules in place, be\r\n * aware that a client needs `.read` access in addition to `.write` access in\r\n * order to perform a transaction. This is because the client-side nature of\r\n * transactions requires the client to read the data in order to transactionally\r\n * update it.\r\n *\r\n * @param ref - The location to atomically modify.\r\n * @param transactionUpdate - A developer-supplied function which will be passed\r\n * the current data stored at this location (as a JavaScript object). The\r\n * function should return the new value it would like written (as a JavaScript\r\n * object). If `undefined` is returned (i.e. you return with no arguments) the\r\n * transaction will be aborted and the data at this location will not be\r\n * modified.\r\n * @param options - An options object to configure transactions.\r\n * @returns A `Promise` that can optionally be used instead of the `onComplete`\r\n * callback to handle success and failure.\r\n */function runTransaction(ref,// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntransactionUpdate,options){var _a;ref=(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);validateWritablePath('Reference.transaction',ref._path);if(ref.key==='.length'||ref.key==='.keys'){throw'Reference.transaction failed: '+ref.key+' is a read-only object.';}const applyLocally=(_a=options===null||options===void 0?void 0:options.applyLocally)!==null&&_a!==void 0?_a:true;const deferred=new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();const promiseComplete=(error,committed,node)=>{let dataSnapshot=null;if(error){deferred.reject(error);}else{dataSnapshot=new DataSnapshot(node,new ReferenceImpl(ref._repo,ref._path),PRIORITY_INDEX);deferred.resolve(new TransactionResult(committed,dataSnapshot));}};// Add a watch to make sure we get server updates.\nconst unwatcher=onValue(ref,()=>{});repoStartTransaction(ref._repo,ref._path,transactionUpdate,promiseComplete,unwatcher,applyLocally);return deferred.promise;}/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */PersistentConnection;// eslint-disable-next-line @typescript-eslint/no-explicit-any\nPersistentConnection.prototype.simpleListen=function(pathString,onComplete){this.sendRequest('q',{p:pathString},onComplete);};// eslint-disable-next-line @typescript-eslint/no-explicit-any\nPersistentConnection.prototype.echo=function(data,onEcho){this.sendRequest('echo',{d:data},onEcho);};// RealTimeConnection properties that we use in tests.\nConnection;/**\r\n * @internal\r\n */const hijackHash=function(newHash){const oldPut=PersistentConnection.prototype.put;PersistentConnection.prototype.put=function(pathString,data,onComplete,hash){if(hash!==undefined){hash=newHash();}oldPut.call(this,pathString,data,onComplete,hash);};return function(){PersistentConnection.prototype.put=oldPut;};};RepoInfo;/**\r\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\r\n * @internal\r\n */const forceRestClient=function(forceRestClient){repoManagerForceRestClient(forceRestClient);};/**\r\n * Firebase Realtime Database\r\n *\r\n * @packageDocumentation\r\n */registerDatabase();\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/@firebase/database/dist/index.esm2017.js?");

/***/ }),

/***/ "./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LogLevel\": () => (/* binding */ LogLevel),\n/* harmony export */   \"Logger\": () => (/* binding */ Logger),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ setLogLevel),\n/* harmony export */   \"setUserLogHandler\": () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * A container for all of the Logger instances\r\n */\nconst instances = [];\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n  LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n  LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n  LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n  LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\n\nconst levelStringToEnum = {\n  'debug': LogLevel.DEBUG,\n  'verbose': LogLevel.VERBOSE,\n  'info': LogLevel.INFO,\n  'warn': LogLevel.WARN,\n  'error': LogLevel.ERROR,\n  'silent': LogLevel.SILENT\n};\n/**\r\n * The default log level\r\n */\n\nconst defaultLogLevel = LogLevel.INFO;\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */\n\nconst ConsoleMethod = {\n  [LogLevel.DEBUG]: 'log',\n  [LogLevel.VERBOSE]: 'log',\n  [LogLevel.INFO]: 'info',\n  [LogLevel.WARN]: 'warn',\n  [LogLevel.ERROR]: 'error'\n};\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */\n\nconst defaultLogHandler = (instance, logType, ...args) => {\n  if (logType < instance.logLevel) {\n    return;\n  }\n\n  const now = new Date().toISOString();\n  const method = ConsoleMethod[logType];\n\n  if (method) {\n    console[method](`[${now}]  ${instance.name}:`, ...args);\n  } else {\n    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n  }\n};\n\nclass Logger {\n  /**\r\n   * Gives you an instance of a Logger to capture messages according to\r\n   * Firebase's logging scheme.\r\n   *\r\n   * @param name The name that the logs will be associated with\r\n   */\n  constructor(name) {\n    this.name = name;\n    /**\r\n     * The log level of the given Logger instance.\r\n     */\n\n    this._logLevel = defaultLogLevel;\n    /**\r\n     * The main (internal) log handler for the Logger instance.\r\n     * Can be set to a new function in internal package code but not by user.\r\n     */\n\n    this._logHandler = defaultLogHandler;\n    /**\r\n     * The optional, additional, user-defined log handler for the Logger instance.\r\n     */\n\n    this._userLogHandler = null;\n    /**\r\n     * Capture the current instance for later use\r\n     */\n\n    instances.push(this);\n  }\n\n  get logLevel() {\n    return this._logLevel;\n  }\n\n  set logLevel(val) {\n    if (!(val in LogLevel)) {\n      throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n    }\n\n    this._logLevel = val;\n  } // Workaround for setter/getter having to be the same type.\n\n\n  setLogLevel(val) {\n    this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n  }\n\n  get logHandler() {\n    return this._logHandler;\n  }\n\n  set logHandler(val) {\n    if (typeof val !== 'function') {\n      throw new TypeError('Value assigned to `logHandler` must be a function');\n    }\n\n    this._logHandler = val;\n  }\n\n  get userLogHandler() {\n    return this._userLogHandler;\n  }\n\n  set userLogHandler(val) {\n    this._userLogHandler = val;\n  }\n  /**\r\n   * The functions below are all based on the `console` interface\r\n   */\n\n\n  debug(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n\n    this._logHandler(this, LogLevel.DEBUG, ...args);\n  }\n\n  log(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n\n    this._logHandler(this, LogLevel.VERBOSE, ...args);\n  }\n\n  info(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n\n    this._logHandler(this, LogLevel.INFO, ...args);\n  }\n\n  warn(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n\n    this._logHandler(this, LogLevel.WARN, ...args);\n  }\n\n  error(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n\n    this._logHandler(this, LogLevel.ERROR, ...args);\n  }\n\n}\n\nfunction setLogLevel(level) {\n  instances.forEach(inst => {\n    inst.setLogLevel(level);\n  });\n}\n\nfunction setUserLogHandler(logCallback, options) {\n  for (const instance of instances) {\n    let customLogLevel = null;\n\n    if (options && options.level) {\n      customLogLevel = levelStringToEnum[options.level];\n    }\n\n    if (logCallback === null) {\n      instance.userLogHandler = null;\n    } else {\n      instance.userLogHandler = (instance, level, ...args) => {\n        const message = args.map(arg => {\n          if (arg == null) {\n            return null;\n          } else if (typeof arg === 'string') {\n            return arg;\n          } else if (typeof arg === 'number' || typeof arg === 'boolean') {\n            return arg.toString();\n          } else if (arg instanceof Error) {\n            return arg.message;\n          } else {\n            try {\n              return JSON.stringify(arg);\n            } catch (ignored) {\n              return null;\n            }\n          }\n        }).filter(arg => arg).join(' ');\n\n        if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n          logCallback({\n            level: LogLevel[level].toLowerCase(),\n            message,\n            args,\n            type: instance.name\n          });\n        }\n      };\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/@firebase/logger/dist/esm/index.esm2017.js?");

/***/ }),

/***/ "./node_modules/@firebase/util/dist/index.esm2017.js":
/*!***********************************************************!*\
  !*** ./node_modules/@firebase/util/dist/index.esm2017.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONSTANTS\": () => (/* binding */ CONSTANTS),\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"ErrorFactory\": () => (/* binding */ ErrorFactory),\n/* harmony export */   \"FirebaseError\": () => (/* binding */ FirebaseError),\n/* harmony export */   \"MAX_VALUE_MILLIS\": () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   \"RANDOM_FACTOR\": () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   \"Sha1\": () => (/* binding */ Sha1),\n/* harmony export */   \"areCookiesEnabled\": () => (/* binding */ areCookiesEnabled),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"assertionError\": () => (/* binding */ assertionError),\n/* harmony export */   \"async\": () => (/* binding */ async),\n/* harmony export */   \"base64\": () => (/* binding */ base64),\n/* harmony export */   \"base64Decode\": () => (/* binding */ base64Decode),\n/* harmony export */   \"base64Encode\": () => (/* binding */ base64Encode),\n/* harmony export */   \"base64urlEncodeWithoutPadding\": () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   \"calculateBackoffMillis\": () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   \"contains\": () => (/* binding */ contains),\n/* harmony export */   \"createMockUserToken\": () => (/* binding */ createMockUserToken),\n/* harmony export */   \"createSubscribe\": () => (/* binding */ createSubscribe),\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"deepCopy\": () => (/* binding */ deepCopy),\n/* harmony export */   \"deepEqual\": () => (/* binding */ deepEqual),\n/* harmony export */   \"deepExtend\": () => (/* binding */ deepExtend),\n/* harmony export */   \"errorPrefix\": () => (/* binding */ errorPrefix),\n/* harmony export */   \"extractQuerystring\": () => (/* binding */ extractQuerystring),\n/* harmony export */   \"getGlobal\": () => (/* binding */ getGlobal),\n/* harmony export */   \"getModularInstance\": () => (/* binding */ getModularInstance),\n/* harmony export */   \"getUA\": () => (/* binding */ getUA),\n/* harmony export */   \"isAdmin\": () => (/* binding */ isAdmin),\n/* harmony export */   \"isBrowser\": () => (/* binding */ isBrowser),\n/* harmony export */   \"isBrowserExtension\": () => (/* binding */ isBrowserExtension),\n/* harmony export */   \"isElectron\": () => (/* binding */ isElectron),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"isIE\": () => (/* binding */ isIE),\n/* harmony export */   \"isIndexedDBAvailable\": () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   \"isMobileCordova\": () => (/* binding */ isMobileCordova),\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"isNodeSdk\": () => (/* binding */ isNodeSdk),\n/* harmony export */   \"isReactNative\": () => (/* binding */ isReactNative),\n/* harmony export */   \"isSafari\": () => (/* binding */ isSafari),\n/* harmony export */   \"isUWP\": () => (/* binding */ isUWP),\n/* harmony export */   \"isValidFormat\": () => (/* binding */ isValidFormat),\n/* harmony export */   \"isValidTimestamp\": () => (/* binding */ isValidTimestamp),\n/* harmony export */   \"issuedAtTime\": () => (/* binding */ issuedAtTime),\n/* harmony export */   \"jsonEval\": () => (/* binding */ jsonEval),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"ordinal\": () => (/* binding */ ordinal),\n/* harmony export */   \"querystring\": () => (/* binding */ querystring),\n/* harmony export */   \"querystringDecode\": () => (/* binding */ querystringDecode),\n/* harmony export */   \"safeGet\": () => (/* binding */ safeGet),\n/* harmony export */   \"stringLength\": () => (/* binding */ stringLength),\n/* harmony export */   \"stringToByteArray\": () => (/* binding */ stringToByteArray),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify),\n/* harmony export */   \"validateArgCount\": () => (/* binding */ validateArgCount),\n/* harmony export */   \"validateCallback\": () => (/* binding */ validateCallback),\n/* harmony export */   \"validateContextObject\": () => (/* binding */ validateContextObject),\n/* harmony export */   \"validateIndexedDBOpenable\": () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   \"validateNamespace\": () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */\nconst CONSTANTS = {\n  /**\r\n   * @define {boolean} Whether this is the client Node.js SDK.\r\n   */\n  NODE_CLIENT: false,\n\n  /**\r\n   * @define {boolean} Whether this is the Admin Node.js SDK.\r\n   */\n  NODE_ADMIN: false,\n\n  /**\r\n   * Firebase SDK Version\r\n   */\n  SDK_VERSION: '${JSCORE_VERSION}'\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Throws an error if the provided assertion is falsy\r\n */\n\nconst assert = function (assertion, message) {\n  if (!assertion) {\n    throw assertionError(message);\n  }\n};\n/**\r\n * Returns an Error object suitable for throwing.\r\n */\n\n\nconst assertionError = function (message) {\n  return new Error('Firebase Database (' + CONSTANTS.SDK_VERSION + ') INTERNAL ASSERT FAILED: ' + message);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst stringToByteArray$1 = function (str) {\n  // TODO(user): Use native implementations if/when available\n  const out = [];\n  let p = 0;\n\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = c >> 6 | 192;\n      out[p++] = c & 63 | 128;\n    } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n      out[p++] = c >> 18 | 240;\n      out[p++] = c >> 12 & 63 | 128;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    } else {\n      out[p++] = c >> 12 | 224;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    }\n  }\n\n  return out;\n};\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */\n\n\nconst byteArrayToString = function (bytes) {\n  // TODO(user): Use native implementations if/when available\n  const out = [];\n  let pos = 0,\n      c = 0;\n\n  while (pos < bytes.length) {\n    const c1 = bytes[pos++];\n\n    if (c1 < 128) {\n      out[c++] = String.fromCharCode(c1);\n    } else if (c1 > 191 && c1 < 224) {\n      const c2 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n    } else if (c1 > 239 && c1 < 365) {\n      // Surrogate Pair\n      const c2 = bytes[pos++];\n      const c3 = bytes[pos++];\n      const c4 = bytes[pos++];\n      const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n      out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n      out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n    } else {\n      const c2 = bytes[pos++];\n      const c3 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n    }\n  }\n\n  return out.join('');\n}; // We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\n\n\nconst base64 = {\n  /**\r\n   * Maps bytes to characters.\r\n   */\n  byteToCharMap_: null,\n\n  /**\r\n   * Maps characters to bytes.\r\n   */\n  charToByteMap_: null,\n\n  /**\r\n   * Maps bytes to websafe characters.\r\n   * @private\r\n   */\n  byteToCharMapWebSafe_: null,\n\n  /**\r\n   * Maps websafe characters to bytes.\r\n   * @private\r\n   */\n  charToByteMapWebSafe_: null,\n\n  /**\r\n   * Our default alphabet, shared between\r\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n   */\n  ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n\n  /**\r\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + '+/=';\n  },\n\n  /**\r\n   * Our websafe alphabet.\r\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + '-_.';\n  },\n\n  /**\r\n   * Whether this browser supports the atob and btoa functions. This extension\r\n   * started at Mozilla but is now implemented by many browsers. We use the\r\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n   * but still allowing the standard per-browser compilations.\r\n   *\r\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === 'function',\n\n  /**\r\n   * Base64-encode an array of bytes.\r\n   *\r\n   * @param input An array of bytes (numbers with\r\n   *     value in [0, 255]) to encode.\r\n   * @param webSafe Boolean indicating we should use the\r\n   *     alternative alphabet.\r\n   * @return The base64 encoded string.\r\n   */\n  encodeByteArray(input, webSafe) {\n    if (!Array.isArray(input)) {\n      throw Error('encodeByteArray takes an array as a parameter');\n    }\n\n    this.init_();\n    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n    const output = [];\n\n    for (let i = 0; i < input.length; i += 3) {\n      const byte1 = input[i];\n      const haveByte2 = i + 1 < input.length;\n      const byte2 = haveByte2 ? input[i + 1] : 0;\n      const haveByte3 = i + 2 < input.length;\n      const byte3 = haveByte3 ? input[i + 2] : 0;\n      const outByte1 = byte1 >> 2;\n      const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n      let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n      let outByte4 = byte3 & 0x3f;\n\n      if (!haveByte3) {\n        outByte4 = 64;\n\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n\n      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n    }\n\n    return output.join('');\n  },\n\n  /**\r\n   * Base64-encode a string.\r\n   *\r\n   * @param input A string to encode.\r\n   * @param webSafe If true, we should use the\r\n   *     alternative alphabet.\r\n   * @return The base64 encoded string.\r\n   */\n  encodeString(input, webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return btoa(input);\n    }\n\n    return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n  },\n\n  /**\r\n   * Base64-decode a string.\r\n   *\r\n   * @param input to decode.\r\n   * @param webSafe True if we should use the\r\n   *     alternative alphabet.\r\n   * @return string representing the decoded value.\r\n   */\n  decodeString(input, webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return atob(input);\n    }\n\n    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n  },\n\n  /**\r\n   * Base64-decode a string.\r\n   *\r\n   * In base-64 decoding, groups of four characters are converted into three\r\n   * bytes.  If the encoder did not apply padding, the input length may not\r\n   * be a multiple of 4.\r\n   *\r\n   * In this case, the last group will have fewer than 4 characters, and\r\n   * padding will be inferred.  If the group has one or two characters, it decodes\r\n   * to one byte.  If the group has three characters, it decodes to two bytes.\r\n   *\r\n   * @param input Input to decode.\r\n   * @param webSafe True if we should use the web-safe alphabet.\r\n   * @return bytes representing the decoded value.\r\n   */\n  decodeStringToByteArray(input, webSafe) {\n    this.init_();\n    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n    const output = [];\n\n    for (let i = 0; i < input.length;) {\n      const byte1 = charToByteMap[input.charAt(i++)];\n      const haveByte2 = i < input.length;\n      const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n      const haveByte3 = i < input.length;\n      const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      const haveByte4 = i < input.length;\n      const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw Error();\n      }\n\n      const outByte1 = byte1 << 2 | byte2 >> 4;\n      output.push(outByte1);\n\n      if (byte3 !== 64) {\n        const outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n        output.push(outByte2);\n\n        if (byte4 !== 64) {\n          const outByte3 = byte3 << 6 & 0xc0 | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Lazy static initialization function. Called before\r\n   * accessing any of the static map variables.\r\n   * @private\r\n   */\n  init_() {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {}; // We want quick mappings back and forth, so we precompute two maps.\n\n      for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i; // Be forgiving when decoding and correctly decode both encodings.\n\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n\n};\n/**\r\n * URL-safe base64 encoding\r\n */\n\nconst base64Encode = function (str) {\n  const utf8Bytes = stringToByteArray$1(str);\n  return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */\n\n\nconst base64urlEncodeWithoutPadding = function (str) {\n  // Use base64url encoding and remove padding in the end (dot characters).\n  return base64Encode(str).replace(/\\./g, '');\n};\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */\n\n\nconst base64Decode = function (str) {\n  try {\n    return base64.decodeString(str, true);\n  } catch (e) {\n    console.error('base64Decode failed: ', e);\n  }\n\n  return null;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */\n\n\nfunction deepCopy(value) {\n  return deepExtend(undefined, value);\n}\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */\n\n\nfunction deepExtend(target, source) {\n  if (!(source instanceof Object)) {\n    return source;\n  }\n\n  switch (source.constructor) {\n    case Date:\n      // Treat Dates like scalars; if the target date object had any child\n      // properties - they will be lost!\n      const dateValue = source;\n      return new Date(dateValue.getTime());\n\n    case Object:\n      if (target === undefined) {\n        target = {};\n      }\n\n      break;\n\n    case Array:\n      // Always copy the array source and overwrite the target.\n      target = [];\n      break;\n\n    default:\n      // Not a plain Object - treat it as a scalar.\n      return source;\n  }\n\n  for (const prop in source) {\n    // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n    if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n      continue;\n    }\n\n    target[prop] = deepExtend(target[prop], source[prop]);\n  }\n\n  return target;\n}\n\nfunction isValidKey(key) {\n  return key !== '__proto__';\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nclass Deferred {\n  constructor() {\n    this.reject = () => {};\n\n    this.resolve = () => {};\n\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n  /**\r\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n   */\n\n\n  wrapCallback(callback) {\n    return (error, value) => {\n      if (error) {\n        this.reject(error);\n      } else {\n        this.resolve(value);\n      }\n\n      if (typeof callback === 'function') {\n        // Attaching noop handler just in case developer wasn't expecting\n        // promises\n        this.promise.catch(() => {}); // Some of our callbacks don't expect a value and our own tests\n        // assert that the parameter length is 1\n\n        if (callback.length === 1) {\n          callback(error);\n        } else {\n          callback(error, value);\n        }\n      }\n    };\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction createMockUserToken(token, projectId) {\n  if (token.uid) {\n    throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n  } // Unsecured JWTs use \"none\" as the algorithm.\n\n\n  const header = {\n    alg: 'none',\n    type: 'JWT'\n  };\n  const project = projectId || 'demo-project';\n  const iat = token.iat || 0;\n  const sub = token.sub || token.user_id;\n\n  if (!sub) {\n    throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n  }\n\n  const payload = Object.assign({\n    // Set all required fields to decent defaults\n    iss: `https://securetoken.google.com/${project}`,\n    aud: project,\n    iat,\n    exp: iat + 3600,\n    auth_time: iat,\n    sub,\n    user_id: sub,\n    firebase: {\n      sign_in_provider: 'custom',\n      identities: {}\n    }\n  }, token); // Unsecured JWTs use the empty string as a signature.\n\n  const signature = '';\n  return [base64urlEncodeWithoutPadding(JSON.stringify(header)), base64urlEncodeWithoutPadding(JSON.stringify(payload)), signature].join('.');\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */\n\n\nfunction getUA() {\n  if (typeof navigator !== 'undefined' && typeof navigator['userAgent'] === 'string') {\n    return navigator['userAgent'];\n  } else {\n    return '';\n  }\n}\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */\n\n\nfunction isMobileCordova() {\n  return typeof window !== 'undefined' && // @ts-ignore Setting up an broadly applicable index signature for Window\n  // just to deal with this case would probably be a bad idea.\n  !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());\n}\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected.\r\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\n\n\nfunction isNode() {\n  try {\n    return Object.prototype.toString.call(__webpack_require__.g.process) === '[object process]';\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * Detect Browser Environment\r\n */\n\n\nfunction isBrowser() {\n  return typeof self === 'object' && self.self === self;\n}\n\nfunction isBrowserExtension() {\n  const runtime = typeof chrome === 'object' ? chrome.runtime : typeof browser === 'object' ? browser.runtime : undefined;\n  return typeof runtime === 'object' && runtime.id !== undefined;\n}\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */\n\n\nfunction isReactNative() {\n  return typeof navigator === 'object' && navigator['product'] === 'ReactNative';\n}\n/** Detects Electron apps. */\n\n\nfunction isElectron() {\n  return getUA().indexOf('Electron/') >= 0;\n}\n/** Detects Internet Explorer. */\n\n\nfunction isIE() {\n  const ua = getUA();\n  return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n}\n/** Detects Universal Windows Platform apps. */\n\n\nfunction isUWP() {\n  return getUA().indexOf('MSAppHost/') >= 0;\n}\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */\n\n\nfunction isNodeSdk() {\n  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */\n\n\nfunction isSafari() {\n  return !isNode() && navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');\n}\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */\n\n\nfunction isIndexedDBAvailable() {\n  return typeof indexedDB === 'object';\n}\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */\n\n\nfunction validateIndexedDBOpenable() {\n  return new Promise((resolve, reject) => {\n    try {\n      let preExist = true;\n      const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\n      const request = self.indexedDB.open(DB_CHECK_NAME);\n\n      request.onsuccess = () => {\n        request.result.close(); // delete database only when it doesn't pre-exist\n\n        if (!preExist) {\n          self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n        }\n\n        resolve(true);\n      };\n\n      request.onupgradeneeded = () => {\n        preExist = false;\n      };\n\n      request.onerror = () => {\n        var _a;\n\n        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\n      };\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */\n\n\nfunction areCookiesEnabled() {\n  if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n */\n\n\nfunction getGlobal() {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof __webpack_require__.g !== 'undefined') {\n    return __webpack_require__.g;\n  }\n\n  throw new Error('Unable to locate global object.');\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if (e.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */\n\n\nconst ERROR_NAME = 'FirebaseError'; // Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\n\nclass FirebaseError extends Error {\n  constructor(code, message, customData) {\n    super(message);\n    this.code = code;\n    this.customData = customData;\n    this.name = ERROR_NAME; // Fix For ES5\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n\n    Object.setPrototypeOf(this, FirebaseError.prototype); // Maintains proper stack trace for where our error was thrown.\n    // Only available on V8.\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ErrorFactory.prototype.create);\n    }\n  }\n\n}\n\nclass ErrorFactory {\n  constructor(service, serviceName, errors) {\n    this.service = service;\n    this.serviceName = serviceName;\n    this.errors = errors;\n  }\n\n  create(code, ...data) {\n    const customData = data[0] || {};\n    const fullCode = `${this.service}/${code}`;\n    const template = this.errors[code];\n    const message = template ? replaceTemplate(template, customData) : 'Error'; // Service Name: Error message (service/code).\n\n    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n    const error = new FirebaseError(fullCode, fullMessage, customData);\n    return error;\n  }\n\n}\n\nfunction replaceTemplate(template, data) {\n  return template.replace(PATTERN, (_, key) => {\n    const value = data[key];\n    return value != null ? String(value) : `<${key}?>`;\n  });\n}\n\nconst PATTERN = /\\{\\$([^}]+)}/g;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */\n\nfunction jsonEval(str) {\n  return JSON.parse(str);\n}\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */\n\n\nfunction stringify(data) {\n  return JSON.stringify(data);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\n\n\nconst decode = function (token) {\n  let header = {},\n      claims = {},\n      data = {},\n      signature = '';\n\n  try {\n    const parts = token.split('.');\n    header = jsonEval(base64Decode(parts[0]) || '');\n    claims = jsonEval(base64Decode(parts[1]) || '');\n    signature = parts[2];\n    data = claims['d'] || {};\n    delete claims['d'];\n  } catch (e) {}\n\n  return {\n    header,\n    claims,\n    data,\n    signature\n  };\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\n\n\nconst isValidTimestamp = function (token) {\n  const claims = decode(token).claims;\n  const now = Math.floor(new Date().getTime() / 1000);\n  let validSince = 0,\n      validUntil = 0;\n\n  if (typeof claims === 'object') {\n    if (claims.hasOwnProperty('nbf')) {\n      validSince = claims['nbf'];\n    } else if (claims.hasOwnProperty('iat')) {\n      validSince = claims['iat'];\n    }\n\n    if (claims.hasOwnProperty('exp')) {\n      validUntil = claims['exp'];\n    } else {\n      // token will expire after 24h by default\n      validUntil = validSince + 86400;\n    }\n  }\n\n  return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;\n};\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\n\n\nconst issuedAtTime = function (token) {\n  const claims = decode(token).claims;\n\n  if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n    return claims['iat'];\n  }\n\n  return null;\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\n\n\nconst isValidFormat = function (token) {\n  const decoded = decode(token),\n        claims = decoded.claims;\n  return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\n\n\nconst isAdmin = function (token) {\n  const claims = decode(token).claims;\n  return typeof claims === 'object' && claims['admin'] === true;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction contains(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction safeGet(obj, key) {\n  if (Object.prototype.hasOwnProperty.call(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n\nfunction isEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction map(obj, fn, contextObj) {\n  const res = {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      res[key] = fn.call(contextObj, obj[key], key, obj);\n    }\n  }\n\n  return res;\n}\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */\n\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  for (const k of aKeys) {\n    if (!bKeys.includes(k)) {\n      return false;\n    }\n\n    const aProp = a[k];\n    const bProp = b[k];\n\n    if (isObject(aProp) && isObject(bProp)) {\n      if (!deepEqual(aProp, bProp)) {\n        return false;\n      }\n    } else if (aProp !== bProp) {\n      return false;\n    }\n  }\n\n  for (const k of bKeys) {\n    if (!aKeys.includes(k)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isObject(thing) {\n  return thing !== null && typeof thing === 'object';\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */\n\n\nfunction querystring(querystringParams) {\n  const params = [];\n\n  for (const [key, value] of Object.entries(querystringParams)) {\n    if (Array.isArray(value)) {\n      value.forEach(arrayVal => {\n        params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\n      });\n    } else {\n      params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n    }\n  }\n\n  return params.length ? '&' + params.join('&') : '';\n}\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */\n\n\nfunction querystringDecode(querystring) {\n  const obj = {};\n  const tokens = querystring.replace(/^\\?/, '').split('&');\n  tokens.forEach(token => {\n    if (token) {\n      const [key, value] = token.split('=');\n      obj[decodeURIComponent(key)] = decodeURIComponent(value);\n    }\n  });\n  return obj;\n}\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */\n\n\nfunction extractQuerystring(url) {\n  const queryStart = url.indexOf('?');\n\n  if (!queryStart) {\n    return '';\n  }\n\n  const fragmentStart = url.indexOf('#', queryStart);\n  return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */\n\n/**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\n\n\nclass Sha1 {\n  constructor() {\n    /**\r\n     * Holds the previous values of accumulated variables a-e in the compress_\r\n     * function.\r\n     * @private\r\n     */\n    this.chain_ = [];\n    /**\r\n     * A buffer holding the partially computed hash result.\r\n     * @private\r\n     */\n\n    this.buf_ = [];\n    /**\r\n     * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n     * as the message schedule in the docs.\r\n     * @private\r\n     */\n\n    this.W_ = [];\n    /**\r\n     * Contains data needed to pad messages less than 64 bytes.\r\n     * @private\r\n     */\n\n    this.pad_ = [];\n    /**\r\n     * @private {number}\r\n     */\n\n    this.inbuf_ = 0;\n    /**\r\n     * @private {number}\r\n     */\n\n    this.total_ = 0;\n    this.blockSize = 512 / 8;\n    this.pad_[0] = 128;\n\n    for (let i = 1; i < this.blockSize; ++i) {\n      this.pad_[i] = 0;\n    }\n\n    this.reset();\n  }\n\n  reset() {\n    this.chain_[0] = 0x67452301;\n    this.chain_[1] = 0xefcdab89;\n    this.chain_[2] = 0x98badcfe;\n    this.chain_[3] = 0x10325476;\n    this.chain_[4] = 0xc3d2e1f0;\n    this.inbuf_ = 0;\n    this.total_ = 0;\n  }\n  /**\r\n   * Internal compress helper function.\r\n   * @param buf Block to compress.\r\n   * @param offset Offset of the block in the buffer.\r\n   * @private\r\n   */\n\n\n  compress_(buf, offset) {\n    if (!offset) {\n      offset = 0;\n    }\n\n    const W = this.W_; // get 16 big endian words\n\n    if (typeof buf === 'string') {\n      for (let i = 0; i < 16; i++) {\n        // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n        // have a bug that turns the post-increment ++ operator into pre-increment\n        // during JIT compilation.  We have code that depends heavily on SHA-1 for\n        // correctness and which is affected by this bug, so I've removed all uses\n        // of post-increment ++ in which the result value is used.  We can revert\n        // this change once the Safari bug\n        // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n        // most clients have been updated.\n        W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);\n        offset += 4;\n      }\n    } else {\n      for (let i = 0; i < 16; i++) {\n        W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];\n        offset += 4;\n      }\n    } // expand to 80 words\n\n\n    for (let i = 16; i < 80; i++) {\n      const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n      W[i] = (t << 1 | t >>> 31) & 0xffffffff;\n    }\n\n    let a = this.chain_[0];\n    let b = this.chain_[1];\n    let c = this.chain_[2];\n    let d = this.chain_[3];\n    let e = this.chain_[4];\n    let f, k; // TODO(user): Try to unroll this loop to speed up the computation.\n\n    for (let i = 0; i < 80; i++) {\n      if (i < 40) {\n        if (i < 20) {\n          f = d ^ b & (c ^ d);\n          k = 0x5a827999;\n        } else {\n          f = b ^ c ^ d;\n          k = 0x6ed9eba1;\n        }\n      } else {\n        if (i < 60) {\n          f = b & c | d & (b | c);\n          k = 0x8f1bbcdc;\n        } else {\n          f = b ^ c ^ d;\n          k = 0xca62c1d6;\n        }\n      }\n\n      const t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;\n      e = d;\n      d = c;\n      c = (b << 30 | b >>> 2) & 0xffffffff;\n      b = a;\n      a = t;\n    }\n\n    this.chain_[0] = this.chain_[0] + a & 0xffffffff;\n    this.chain_[1] = this.chain_[1] + b & 0xffffffff;\n    this.chain_[2] = this.chain_[2] + c & 0xffffffff;\n    this.chain_[3] = this.chain_[3] + d & 0xffffffff;\n    this.chain_[4] = this.chain_[4] + e & 0xffffffff;\n  }\n\n  update(bytes, length) {\n    // TODO(johnlenz): tighten the function signature and remove this check\n    if (bytes == null) {\n      return;\n    }\n\n    if (length === undefined) {\n      length = bytes.length;\n    }\n\n    const lengthMinusBlock = length - this.blockSize;\n    let n = 0; // Using local instead of member variables gives ~5% speedup on Firefox 16.\n\n    const buf = this.buf_;\n    let inbuf = this.inbuf_; // The outer while loop should execute at most twice.\n\n    while (n < length) {\n      // When we have no data in the block to top up, we can directly process the\n      // input buffer (assuming it contains sufficient data). This gives ~25%\n      // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n      // the data is provided in large chunks (or in multiples of 64 bytes).\n      if (inbuf === 0) {\n        while (n <= lengthMinusBlock) {\n          this.compress_(bytes, n);\n          n += this.blockSize;\n        }\n      }\n\n      if (typeof bytes === 'string') {\n        while (n < length) {\n          buf[inbuf] = bytes.charCodeAt(n);\n          ++inbuf;\n          ++n;\n\n          if (inbuf === this.blockSize) {\n            this.compress_(buf);\n            inbuf = 0; // Jump to the outer loop so we use the full-block optimization.\n\n            break;\n          }\n        }\n      } else {\n        while (n < length) {\n          buf[inbuf] = bytes[n];\n          ++inbuf;\n          ++n;\n\n          if (inbuf === this.blockSize) {\n            this.compress_(buf);\n            inbuf = 0; // Jump to the outer loop so we use the full-block optimization.\n\n            break;\n          }\n        }\n      }\n    }\n\n    this.inbuf_ = inbuf;\n    this.total_ += length;\n  }\n  /** @override */\n\n\n  digest() {\n    const digest = [];\n    let totalBits = this.total_ * 8; // Add pad 0x80 0x00*.\n\n    if (this.inbuf_ < 56) {\n      this.update(this.pad_, 56 - this.inbuf_);\n    } else {\n      this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n    } // Add # bits.\n\n\n    for (let i = this.blockSize - 1; i >= 56; i--) {\n      this.buf_[i] = totalBits & 255;\n      totalBits /= 256; // Don't use bit-shifting here!\n    }\n\n    this.compress_(this.buf_);\n    let n = 0;\n\n    for (let i = 0; i < 5; i++) {\n      for (let j = 24; j >= 0; j -= 8) {\n        digest[n] = this.chain_[i] >> j & 255;\n        ++n;\n      }\n    }\n\n    return digest;\n  }\n\n}\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */\n\n\nfunction createSubscribe(executor, onNoObservers) {\n  const proxy = new ObserverProxy(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */\n\n\nclass ObserverProxy {\n  /**\r\n   * @param executor Function which can make calls to a single Observer\r\n   *     as a proxy.\r\n   * @param onNoObservers Callback when count of Observers goes to zero.\r\n   */\n  constructor(executor, onNoObservers) {\n    this.observers = [];\n    this.unsubscribes = [];\n    this.observerCount = 0; // Micro-task scheduling by calling task.then().\n\n    this.task = Promise.resolve();\n    this.finalized = false;\n    this.onNoObservers = onNoObservers; // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n\n    this.task.then(() => {\n      executor(this);\n    }).catch(e => {\n      this.error(e);\n    });\n  }\n\n  next(value) {\n    this.forEachObserver(observer => {\n      observer.next(value);\n    });\n  }\n\n  error(error) {\n    this.forEachObserver(observer => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver(observer => {\n      observer.complete();\n    });\n    this.close();\n  }\n  /**\r\n   * Subscribe function that can be used to add an Observer to the fan-out list.\r\n   *\r\n   * - We require that no event is sent to a subscriber sychronously to their\r\n   *   call to subscribe().\r\n   */\n\n\n  subscribe(nextOrObserver, error, complete) {\n    let observer;\n\n    if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n      throw new Error('Missing Observer.');\n    } // Assemble an Observer object when passed as callback functions.\n\n\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver;\n    } else {\n      observer = {\n        next: nextOrObserver,\n        error,\n        complete\n      };\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop;\n    }\n\n    if (observer.error === undefined) {\n      observer.error = noop;\n    }\n\n    if (observer.complete === undefined) {\n      observer.complete = noop;\n    }\n\n    const unsub = this.unsubscribeOne.bind(this, this.observers.length); // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n\n    if (this.finalized) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {// nothing\n        }\n\n        return;\n      });\n    }\n\n    this.observers.push(observer);\n    return unsub;\n  } // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n\n\n  unsubscribeOne(i) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n    this.observerCount -= 1;\n\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  forEachObserver(fn) {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    } // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n\n\n    for (let i = 0; i < this.observers.length; i++) {\n      this.sendOne(i, fn);\n    }\n  } // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n\n\n  sendOne(i, fn) {\n    // Execute the callback asynchronously\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  close(err) {\n    if (this.finalized) {\n      return;\n    }\n\n    this.finalized = true;\n\n    if (err !== undefined) {\n      this.finalError = err;\n    } // Proxy is no longer needed - garbage collect references\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n\n}\n/** Turn synchronous function into one called asynchronously. */\n// eslint-disable-next-line @typescript-eslint/ban-types\n\n\nfunction async(fn, onError) {\n  return (...args) => {\n    Promise.resolve(true).then(() => {\n      fn(...args);\n    }).catch(error => {\n      if (onError) {\n        onError(error);\n      }\n    });\n  };\n}\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */\n\n\nfunction implementsAnyMethods(obj, methods) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (const method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop() {// do nothing\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */\n\n\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\n  let argError;\n\n  if (argCount < minCount) {\n    argError = 'at least ' + minCount;\n  } else if (argCount > maxCount) {\n    argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n  }\n\n  if (argError) {\n    const error = fnName + ' failed: Was called with ' + argCount + (argCount === 1 ? ' argument.' : ' arguments.') + ' Expects ' + argError + '.';\n    throw new Error(error);\n  }\n};\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */\n\n\nfunction errorPrefix(fnName, argName) {\n  return `${fnName} failed: ${argName} argument `;\n}\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */\n\n\nfunction validateNamespace(fnName, namespace, optional) {\n  if (optional && !namespace) {\n    return;\n  }\n\n  if (typeof namespace !== 'string') {\n    //TODO: I should do more validation here. We only allow certain chars in namespaces.\n    throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\n  }\n}\n\nfunction validateCallback(fnName, argumentName, // eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n  if (optional && !callback) {\n    return;\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\n  }\n}\n\nfunction validateContextObject(fnName, argumentName, context, optional) {\n  if (optional && !context) {\n    return;\n  }\n\n  if (typeof context !== 'object' || context === null) {\n    throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\n  }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */\n\n\nconst stringToByteArray = function (str) {\n  const out = [];\n  let p = 0;\n\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i); // Is this the lead surrogate in a surrogate pair?\n\n    if (c >= 0xd800 && c <= 0xdbff) {\n      const high = c - 0xd800; // the high 10 bits.\n\n      i++;\n      assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n      const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n\n      c = 0x10000 + (high << 10) + low;\n    }\n\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = c >> 6 | 192;\n      out[p++] = c & 63 | 128;\n    } else if (c < 65536) {\n      out[p++] = c >> 12 | 224;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    } else {\n      out[p++] = c >> 18 | 240;\n      out[p++] = c >> 12 & 63 | 128;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    }\n  }\n\n  return out;\n};\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */\n\n\nconst stringLength = function (str) {\n  let p = 0;\n\n  for (let i = 0; i < str.length; i++) {\n    const c = str.charCodeAt(i);\n\n    if (c < 128) {\n      p++;\n    } else if (c < 2048) {\n      p += 2;\n    } else if (c >= 0xd800 && c <= 0xdbff) {\n      // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n      p += 4;\n      i++; // skip trail surrogate.\n    } else {\n      p += 3;\n    }\n  }\n\n  return p;\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * The amount of milliseconds to exponentially increase.\r\n */\n\n\nconst DEFAULT_INTERVAL_MILLIS = 1000;\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */\n\nconst DEFAULT_BACKOFF_FACTOR = 2;\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */\n\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */\n\nconst RANDOM_FACTOR = 0.5;\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */\n\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n  // Calculates an exponentially increasing value.\n  // Deviation: calculates value from count and a constant interval, so we only need to save value\n  // and count to restore state.\n  const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount); // A random \"fuzz\" to avoid waves of retries.\n  // Deviation: randomFactor is required.\n\n  const randomWait = Math.round( // A fraction of the backoff value to add/subtract.\n  // Deviation: changes multiplication order to improve readability.\n  RANDOM_FACTOR * currBaseValue * ( // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n  // if we add or subtract.\n  Math.random() - 0.5) * 2); // Limits backoff to max to avoid effectively permanent backoff.\n\n  return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Provide English ordinal letters after a number\r\n */\n\n\nfunction ordinal(i) {\n  if (!Number.isFinite(i)) {\n    return `${i}`;\n  }\n\n  return i + indicator(i);\n}\n\nfunction indicator(i) {\n  i = Math.abs(i);\n  const cent = i % 100;\n\n  if (cent >= 10 && cent <= 20) {\n    return 'th';\n  }\n\n  const dec = i % 10;\n\n  if (dec === 1) {\n    return 'st';\n  }\n\n  if (dec === 2) {\n    return 'nd';\n  }\n\n  if (dec === 3) {\n    return 'rd';\n  }\n\n  return 'th';\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction getModularInstance(service) {\n  if (service && service._delegate) {\n    return service._delegate;\n  } else {\n    return service;\n  }\n}\n\n\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/@firebase/util/dist/index.esm2017.js?");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n// css base code, injected by the css-loader\nmodule.exports = function () {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    var result = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var item = this[i];\n\n      if (item[2]) {\n        result.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n      } else {\n        result.push(item[1]);\n      }\n    }\n\n    return result.join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n      if (typeof id === \"number\") alreadyImportedModules[id] = true;\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      //  when a module is imported multiple times with different media queries.\n      //  I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/firebase/app/dist/index.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/firebase/app/dist/index.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FirebaseError\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.FirebaseError),\n/* harmony export */   \"SDK_VERSION\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION),\n/* harmony export */   \"_DEFAULT_ENTRY_NAME\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._DEFAULT_ENTRY_NAME),\n/* harmony export */   \"_addComponent\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addComponent),\n/* harmony export */   \"_addOrOverwriteComponent\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addOrOverwriteComponent),\n/* harmony export */   \"_apps\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._apps),\n/* harmony export */   \"_clearComponents\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._clearComponents),\n/* harmony export */   \"_components\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._components),\n/* harmony export */   \"_getProvider\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider),\n/* harmony export */   \"_registerComponent\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent),\n/* harmony export */   \"_removeServiceInstance\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance),\n/* harmony export */   \"deleteApp\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.deleteApp),\n/* harmony export */   \"getApp\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp),\n/* harmony export */   \"getApps\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps),\n/* harmony export */   \"initializeApp\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp),\n/* harmony export */   \"onLog\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.onLog),\n/* harmony export */   \"registerVersion\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion),\n/* harmony export */   \"setLogLevel\": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n\n\nvar name = \"firebase\";\nvar version = \"9.6.1\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'app');\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/firebase/app/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/firebase/database/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/firebase/database/dist/index.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataSnapshot\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.DataSnapshot),\n/* harmony export */   \"Database\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.Database),\n/* harmony export */   \"OnDisconnect\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.OnDisconnect),\n/* harmony export */   \"QueryConstraint\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.QueryConstraint),\n/* harmony export */   \"TransactionResult\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.TransactionResult),\n/* harmony export */   \"_QueryImpl\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._QueryImpl),\n/* harmony export */   \"_QueryParams\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._QueryParams),\n/* harmony export */   \"_ReferenceImpl\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._ReferenceImpl),\n/* harmony export */   \"_TEST_ACCESS_forceRestClient\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._TEST_ACCESS_forceRestClient),\n/* harmony export */   \"_TEST_ACCESS_hijackHash\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._TEST_ACCESS_hijackHash),\n/* harmony export */   \"_repoManagerDatabaseFromApp\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._repoManagerDatabaseFromApp),\n/* harmony export */   \"_setSDKVersion\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._setSDKVersion),\n/* harmony export */   \"_validatePathString\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._validatePathString),\n/* harmony export */   \"_validateWritablePath\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._validateWritablePath),\n/* harmony export */   \"child\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.child),\n/* harmony export */   \"connectDatabaseEmulator\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.connectDatabaseEmulator),\n/* harmony export */   \"enableLogging\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.enableLogging),\n/* harmony export */   \"endAt\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.endAt),\n/* harmony export */   \"endBefore\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.endBefore),\n/* harmony export */   \"equalTo\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.equalTo),\n/* harmony export */   \"get\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.get),\n/* harmony export */   \"getDatabase\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.getDatabase),\n/* harmony export */   \"goOffline\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.goOffline),\n/* harmony export */   \"goOnline\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.goOnline),\n/* harmony export */   \"increment\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.increment),\n/* harmony export */   \"limitToFirst\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.limitToFirst),\n/* harmony export */   \"limitToLast\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.limitToLast),\n/* harmony export */   \"off\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.off),\n/* harmony export */   \"onChildAdded\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildAdded),\n/* harmony export */   \"onChildChanged\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildChanged),\n/* harmony export */   \"onChildMoved\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildMoved),\n/* harmony export */   \"onChildRemoved\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildRemoved),\n/* harmony export */   \"onDisconnect\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onDisconnect),\n/* harmony export */   \"onValue\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue),\n/* harmony export */   \"orderByChild\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByChild),\n/* harmony export */   \"orderByKey\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByKey),\n/* harmony export */   \"orderByPriority\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByPriority),\n/* harmony export */   \"orderByValue\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByValue),\n/* harmony export */   \"push\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.push),\n/* harmony export */   \"query\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.query),\n/* harmony export */   \"ref\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref),\n/* harmony export */   \"refFromURL\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.refFromURL),\n/* harmony export */   \"remove\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.remove),\n/* harmony export */   \"runTransaction\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.runTransaction),\n/* harmony export */   \"serverTimestamp\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp),\n/* harmony export */   \"set\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.set),\n/* harmony export */   \"setPriority\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.setPriority),\n/* harmony export */   \"setWithPriority\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.setWithPriority),\n/* harmony export */   \"startAfter\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.startAfter),\n/* harmony export */   \"startAt\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.startAt),\n/* harmony export */   \"update\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)\n/* harmony export */ });\n/* harmony import */ var _firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/database */ \"./node_modules/@firebase/database/dist/index.esm2017.js\");\n\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/firebase/database/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/preact-router/dist/preact-router.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/preact-router/dist/preact-router.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribers\": () => (/* binding */ subscribers),\n/* harmony export */   \"getCurrentUrl\": () => (/* binding */ getCurrentUrl),\n/* harmony export */   \"route\": () => (/* binding */ route),\n/* harmony export */   \"Router\": () => (/* binding */ Router),\n/* harmony export */   \"Route\": () => (/* binding */ Route),\n/* harmony export */   \"Link\": () => (/* binding */ Link),\n/* harmony export */   \"exec\": () => (/* binding */ exec),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\nvar EMPTY$1 = {};\n\nfunction assign(obj, props) {\n  // eslint-disable-next-line guard-for-in\n  for (var i in props) {\n    obj[i] = props[i];\n  }\n\n  return obj;\n}\n\nfunction exec(url, route, opts) {\n  var reg = /(?:\\?([^#]*))?(#.*)?$/,\n      c = url.match(reg),\n      matches = {},\n      ret;\n\n  if (c && c[1]) {\n    var p = c[1].split('&');\n\n    for (var i = 0; i < p.length; i++) {\n      var r = p[i].split('=');\n      matches[decodeURIComponent(r[0])] = decodeURIComponent(r.slice(1).join('='));\n    }\n  }\n\n  url = segmentize(url.replace(reg, ''));\n  route = segmentize(route || '');\n  var max = Math.max(url.length, route.length);\n\n  for (var i$1 = 0; i$1 < max; i$1++) {\n    if (route[i$1] && route[i$1].charAt(0) === ':') {\n      var param = route[i$1].replace(/(^:|[+*?]+$)/g, ''),\n          flags = (route[i$1].match(/[+*?]+$/) || EMPTY$1)[0] || '',\n          plus = ~flags.indexOf('+'),\n          star = ~flags.indexOf('*'),\n          val = url[i$1] || '';\n\n      if (!val && !star && (flags.indexOf('?') < 0 || plus)) {\n        ret = false;\n        break;\n      }\n\n      matches[param] = decodeURIComponent(val);\n\n      if (plus || star) {\n        matches[param] = url.slice(i$1).map(decodeURIComponent).join('/');\n        break;\n      }\n    } else if (route[i$1] !== url[i$1]) {\n      ret = false;\n      break;\n    }\n  }\n\n  if (opts.default !== true && ret === false) {\n    return false;\n  }\n\n  return matches;\n}\n\nfunction pathRankSort(a, b) {\n  return a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : a.index - b.index;\n} // filter out VNodes without attributes (which are unrankeable), and add `index`/`rank` properties to be used in sorting.\n\n\nfunction prepareVNodeForRanking(vnode, index) {\n  vnode.index = index;\n  vnode.rank = rankChild(vnode);\n  return vnode.props;\n}\n\nfunction segmentize(url) {\n  return url.replace(/(^\\/+|\\/+$)/g, '').split('/');\n}\n\nfunction rankSegment(segment) {\n  return segment.charAt(0) == ':' ? 1 + '*+?'.indexOf(segment.charAt(segment.length - 1)) || 4 : 5;\n}\n\nfunction rank(path) {\n  return segmentize(path).map(rankSegment).join('');\n}\n\nfunction rankChild(vnode) {\n  return vnode.props.default ? 0 : rank(vnode.props.path);\n}\n\nvar customHistory = null;\nvar ROUTERS = [];\nvar subscribers = [];\nvar EMPTY = {};\n\nfunction setUrl(url, type) {\n  if (type === void 0) type = 'push';\n\n  if (customHistory && customHistory[type]) {\n    customHistory[type](url);\n  } else if (typeof history !== 'undefined' && history[type + 'State']) {\n    history[type + 'State'](null, null, url);\n  }\n}\n\nfunction getCurrentUrl() {\n  var url;\n\n  if (customHistory && customHistory.location) {\n    url = customHistory.location;\n  } else if (customHistory && customHistory.getCurrentLocation) {\n    url = customHistory.getCurrentLocation();\n  } else {\n    url = typeof location !== 'undefined' ? location : EMPTY;\n  }\n\n  return \"\" + (url.pathname || '') + (url.search || '');\n}\n\nfunction route(url, replace) {\n  if (replace === void 0) replace = false;\n\n  if (typeof url !== 'string' && url.url) {\n    replace = url.replace;\n    url = url.url;\n  } // only push URL into history if we can handle it\n\n\n  if (canRoute(url)) {\n    setUrl(url, replace ? 'replace' : 'push');\n  }\n\n  return routeTo(url);\n}\n/** Check if the given URL can be handled by any router instances. */\n\n\nfunction canRoute(url) {\n  for (var i = ROUTERS.length; i--;) {\n    if (ROUTERS[i].canRoute(url)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/** Tell all router instances to handle the given URL.  */\n\n\nfunction routeTo(url) {\n  var didRoute = false;\n\n  for (var i = 0; i < ROUTERS.length; i++) {\n    if (ROUTERS[i].routeTo(url) === true) {\n      didRoute = true;\n    }\n  }\n\n  for (var i$1 = subscribers.length; i$1--;) {\n    subscribers[i$1](url);\n  }\n\n  return didRoute;\n}\n\nfunction routeFromLink(node) {\n  // only valid elements\n  if (!node || !node.getAttribute) {\n    return;\n  }\n\n  var href = node.getAttribute('href'),\n      target = node.getAttribute('target'); // ignore links with targets and non-path URLs\n\n  if (!href || !href.match(/^\\//g) || target && !target.match(/^_?self$/i)) {\n    return;\n  } // attempt to route, if no match simply cede control to browser\n\n\n  return route(href);\n}\n\nfunction handleLinkClick(e) {\n  if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button !== 0) {\n    return;\n  }\n\n  routeFromLink(e.currentTarget || e.target || this);\n  return prevent(e);\n}\n\nfunction prevent(e) {\n  if (e) {\n    if (e.stopImmediatePropagation) {\n      e.stopImmediatePropagation();\n    }\n\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    }\n\n    e.preventDefault();\n  }\n\n  return false;\n}\n\nfunction delegateLinkHandler(e) {\n  // ignore events the browser takes care of already:\n  if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button !== 0) {\n    return;\n  }\n\n  var t = e.target;\n\n  do {\n    if (String(t.nodeName).toUpperCase() === 'A' && t.getAttribute('href')) {\n      if (t.hasAttribute('native')) {\n        return;\n      } // if link is handled by the router, prevent browser defaults\n\n\n      if (routeFromLink(t)) {\n        return prevent(e);\n      }\n    }\n  } while (t = t.parentNode);\n}\n\nvar eventListenersInitialized = false;\n\nfunction initEventListeners() {\n  if (eventListenersInitialized) {\n    return;\n  }\n\n  if (typeof addEventListener === 'function') {\n    if (!customHistory) {\n      addEventListener('popstate', function () {\n        routeTo(getCurrentUrl());\n      });\n    }\n\n    addEventListener('click', delegateLinkHandler);\n  }\n\n  eventListenersInitialized = true;\n}\n\nvar Router = function (Component$$1) {\n  function Router(props) {\n    Component$$1.call(this, props);\n\n    if (props.history) {\n      customHistory = props.history;\n    }\n\n    this.state = {\n      url: props.url || getCurrentUrl()\n    };\n    initEventListeners();\n  }\n\n  if (Component$$1) Router.__proto__ = Component$$1;\n  Router.prototype = Object.create(Component$$1 && Component$$1.prototype);\n  Router.prototype.constructor = Router;\n\n  Router.prototype.shouldComponentUpdate = function shouldComponentUpdate(props) {\n    if (props.static !== true) {\n      return true;\n    }\n\n    return props.url !== this.props.url || props.onChange !== this.props.onChange;\n  };\n  /** Check if the given URL can be matched against any children */\n\n\n  Router.prototype.canRoute = function canRoute(url) {\n    var children = (0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(this.props.children);\n    return this.getMatchingChildren(children, url, false).length > 0;\n  };\n  /** Re-render children with a new URL to match against. */\n\n\n  Router.prototype.routeTo = function routeTo(url) {\n    this.setState({\n      url: url\n    });\n    var didRoute = this.canRoute(url); // trigger a manual re-route if we're not in the middle of an update:\n\n    if (!this.updating) {\n      this.forceUpdate();\n    }\n\n    return didRoute;\n  };\n\n  Router.prototype.componentWillMount = function componentWillMount() {\n    ROUTERS.push(this);\n    this.updating = true;\n  };\n\n  Router.prototype.componentDidMount = function componentDidMount() {\n    var this$1 = this;\n\n    if (customHistory) {\n      this.unlisten = customHistory.listen(function (location) {\n        this$1.routeTo(\"\" + (location.pathname || '') + (location.search || ''));\n      });\n    }\n\n    this.updating = false;\n  };\n\n  Router.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (typeof this.unlisten === 'function') {\n      this.unlisten();\n    }\n\n    ROUTERS.splice(ROUTERS.indexOf(this), 1);\n  };\n\n  Router.prototype.componentWillUpdate = function componentWillUpdate() {\n    this.updating = true;\n  };\n\n  Router.prototype.componentDidUpdate = function componentDidUpdate() {\n    this.updating = false;\n  };\n\n  Router.prototype.getMatchingChildren = function getMatchingChildren(children, url, invoke) {\n    return children.filter(prepareVNodeForRanking).sort(pathRankSort).map(function (vnode) {\n      var matches = exec(url, vnode.props.path, vnode.props);\n\n      if (matches) {\n        if (invoke !== false) {\n          var newProps = {\n            url: url,\n            matches: matches\n          };\n          assign(newProps, matches);\n          delete newProps.ref;\n          delete newProps.key;\n          return (0,preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(vnode, newProps);\n        }\n\n        return vnode;\n      }\n    }).filter(Boolean);\n  };\n\n  Router.prototype.render = function render(ref, ref$1) {\n    var children = ref.children;\n    var onChange = ref.onChange;\n    var url = ref$1.url;\n    var active = this.getMatchingChildren((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(children), url, true);\n    var current = active[0] || null;\n    var previous = this.previousUrl;\n\n    if (url !== previous) {\n      this.previousUrl = url;\n\n      if (typeof onChange === 'function') {\n        onChange({\n          router: this,\n          url: url,\n          previous: previous,\n          active: active,\n          current: current\n        });\n      }\n    }\n\n    return current;\n  };\n\n  return Router;\n}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nvar Link = function (props) {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)('a', assign({\n    onClick: handleLinkClick\n  }, props));\n};\n\nvar Route = function (props) {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.component, props);\n};\n\nRouter.subscribers = subscribers;\nRouter.getCurrentUrl = getCurrentUrl;\nRouter.route = route;\nRouter.Router = Router;\nRouter.Route = Route;\nRouter.Link = Link;\nRouter.exec = exec;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Router);\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/preact-router/dist/preact-router.es.js?");

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ S),\n/* harmony export */   \"hydrate\": () => (/* binding */ q),\n/* harmony export */   \"createElement\": () => (/* binding */ v),\n/* harmony export */   \"h\": () => (/* binding */ v),\n/* harmony export */   \"Fragment\": () => (/* binding */ d),\n/* harmony export */   \"createRef\": () => (/* binding */ p),\n/* harmony export */   \"isValidElement\": () => (/* binding */ i),\n/* harmony export */   \"Component\": () => (/* binding */ _),\n/* harmony export */   \"cloneElement\": () => (/* binding */ B),\n/* harmony export */   \"createContext\": () => (/* binding */ D),\n/* harmony export */   \"toChildArray\": () => (/* binding */ A),\n/* harmony export */   \"options\": () => (/* binding */ l)\n/* harmony export */ });\nvar n,\n    l,\n    u,\n    i,\n    t,\n    r,\n    o,\n    f,\n    e = {},\n    c = [],\n    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n\nfunction a(n, l) {\n  for (var u in l) n[u] = l[u];\n\n  return n;\n}\n\nfunction h(n) {\n  var l = n.parentNode;\n  l && l.removeChild(n);\n}\n\nfunction v(l, u, i) {\n  var t,\n      r,\n      o,\n      f = {};\n\n  for (o in u) \"key\" == o ? t = u[o] : \"ref\" == o ? r = u[o] : f[o] = u[o];\n\n  if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), \"function\" == typeof l && null != l.defaultProps) for (o in l.defaultProps) void 0 === f[o] && (f[o] = l.defaultProps[o]);\n  return y(l, f, t, r, null);\n}\n\nfunction y(n, i, t, r, o) {\n  var f = {\n    type: n,\n    props: i,\n    key: t,\n    ref: r,\n    __k: null,\n    __: null,\n    __b: 0,\n    __e: null,\n    __d: void 0,\n    __c: null,\n    __h: null,\n    constructor: void 0,\n    __v: null == o ? ++u : o\n  };\n  return null == o && null != l.vnode && l.vnode(f), f;\n}\n\nfunction p() {\n  return {\n    current: null\n  };\n}\n\nfunction d(n) {\n  return n.children;\n}\n\nfunction _(n, l) {\n  this.props = n, this.context = l;\n}\n\nfunction k(n, l) {\n  if (null == l) return n.__ ? k(n.__, n.__.__k.indexOf(n) + 1) : null;\n\n  for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;\n\n  return \"function\" == typeof n.type ? k(n) : null;\n}\n\nfunction b(n) {\n  var l, u;\n\n  if (null != (n = n.__) && null != n.__c) {\n    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {\n      n.__e = n.__c.base = u.__e;\n      break;\n    }\n\n    return b(n);\n  }\n}\n\nfunction m(n) {\n  (!n.__d && (n.__d = !0) && t.push(n) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(g);\n}\n\nfunction g() {\n  for (var n; g.__r = t.length;) n = t.sort(function (n, l) {\n    return n.__v.__b - l.__v.__b;\n  }), t = [], n.some(function (n) {\n    var l, u, i, t, r, o;\n    n.__d && (r = (t = (l = n).__v).__e, (o = l.__P) && (u = [], (i = a({}, t)).__v = t.__v + 1, j(o, t, i, l.__n, void 0 !== o.ownerSVGElement, null != t.__h ? [r] : null, u, null == r ? k(t) : r, t.__h), z(u, t), t.__e != r && b(t)));\n  });\n}\n\nfunction w(n, l, u, i, t, r, o, f, s, a) {\n  var h,\n      v,\n      p,\n      _,\n      b,\n      m,\n      g,\n      w = i && i.__k || c,\n      A = w.length;\n\n  for (u.__k = [], h = 0; h < l.length; h++) if (null != (_ = u.__k[h] = null == (_ = l[h]) || \"boolean\" == typeof _ ? null : \"string\" == typeof _ || \"number\" == typeof _ || \"bigint\" == typeof _ ? y(null, _, null, null, _) : Array.isArray(_) ? y(d, {\n    children: _\n  }, null, null, null) : _.__b > 0 ? y(_.type, _.props, _.key, null, _.__v) : _)) {\n    if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {\n      if ((p = w[v]) && _.key == p.key && _.type === p.type) {\n        w[v] = void 0;\n        break;\n      }\n\n      p = null;\n    }\n    j(n, _, p = p || e, t, r, o, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (g || (g = []), p.ref && g.push(p.ref, null, _), g.push(v, _.__c || b, _)), null != b ? (null == m && (m = b), \"function\" == typeof _.type && _.__k === p.__k ? _.__d = s = x(_, s, n) : s = P(n, _, p, w, b, s), \"function\" == typeof u.type && (u.__d = s)) : s && p.__e == s && s.parentNode != n && (s = k(p));\n  }\n\n  for (u.__e = m, h = A; h--;) null != w[h] && (\"function\" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = k(i, h + 1)), N(w[h], w[h]));\n\n  if (g) for (h = 0; h < g.length; h++) M(g[h], g[++h], g[++h]);\n}\n\nfunction x(n, l, u) {\n  for (var i, t = n.__k, r = 0; t && r < t.length; r++) (i = t[r]) && (i.__ = n, l = \"function\" == typeof i.type ? x(i, l, u) : P(u, i, i, t, i.__e, l));\n\n  return l;\n}\n\nfunction A(n, l) {\n  return l = l || [], null == n || \"boolean\" == typeof n || (Array.isArray(n) ? n.some(function (n) {\n    A(n, l);\n  }) : l.push(n)), l;\n}\n\nfunction P(n, l, u, i, t, r) {\n  var o, f, e;\n  if (void 0 !== l.__d) o = l.__d, l.__d = void 0;else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;else {\n    for (f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;\n\n    n.insertBefore(t, r), o = r;\n  }\n  return void 0 !== o ? o : t.nextSibling;\n}\n\nfunction C(n, l, u, i, t) {\n  var r;\n\n  for (r in u) \"children\" === r || \"key\" === r || r in l || H(n, r, null, u[r], i);\n\n  for (r in l) t && \"function\" != typeof l[r] || \"children\" === r || \"key\" === r || \"value\" === r || \"checked\" === r || u[r] === l[r] || H(n, r, l[r], u[r], i);\n}\n\nfunction $(n, l, u) {\n  \"-\" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? \"\" : \"number\" != typeof u || s.test(l) ? u : u + \"px\";\n}\n\nfunction H(n, l, u, i, t) {\n  var r;\n\n  n: if (\"style\" === l) {\n    if (\"string\" == typeof u) n.style.cssText = u;else {\n      if (\"string\" == typeof i && (n.style.cssText = i = \"\"), i) for (l in i) u && l in u || $(n.style, l, \"\");\n      if (u) for (l in u) i && u[l] === i[l] || $(n.style, l, u[l]);\n    }\n  } else if (\"o\" === l[0] && \"n\" === l[1]) r = l !== (l = l.replace(/Capture$/, \"\")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? T : I, r) : n.removeEventListener(l, r ? T : I, r);else if (\"dangerouslySetInnerHTML\" !== l) {\n    if (t) l = l.replace(/xlink[H:h]/, \"h\").replace(/sName$/, \"s\");else if (\"href\" !== l && \"list\" !== l && \"form\" !== l && \"tabIndex\" !== l && \"download\" !== l && l in n) try {\n      n[l] = null == u ? \"\" : u;\n      break n;\n    } catch (n) {}\n    \"function\" == typeof u || (null != u && (!1 !== u || \"a\" === l[0] && \"r\" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));\n  }\n}\n\nfunction I(n) {\n  this.l[n.type + !1](l.event ? l.event(n) : n);\n}\n\nfunction T(n) {\n  this.l[n.type + !0](l.event ? l.event(n) : n);\n}\n\nfunction j(n, u, i, t, r, o, f, e, c) {\n  var s,\n      h,\n      v,\n      y,\n      p,\n      k,\n      b,\n      m,\n      g,\n      x,\n      A,\n      P = u.type;\n  if (void 0 !== u.constructor) return null;\n  null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [e]), (s = l.__b) && s(u);\n\n  try {\n    n: if (\"function\" == typeof P) {\n      if (m = u.props, g = (s = P.contextType) && t[s.__c], x = s ? g ? g.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : (\"prototype\" in P && P.prototype.render ? u.__c = h = new P(m, x) : (u.__c = h = new _(m, x), h.constructor = P, h.render = O), g && g.sub(h), h.props = m, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != P.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a({}, h.__s)), a(h.__s, P.getDerivedStateFromProps(m, h.__s))), y = h.props, p = h.state, v) null == P.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {\n        if (null == P.getDerivedStateFromProps && m !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, x) || u.__v === i.__v) {\n          h.props = m, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {\n            n && (n.__ = u);\n          }), h.__h.length && f.push(h);\n          break n;\n        }\n\n        null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {\n          h.componentDidUpdate(y, p, k);\n        });\n      }\n      h.context = x, h.props = m, h.state = h.__s, (s = l.__r) && s(u), h.__d = !1, h.__v = u, h.__P = n, s = h.render(h.props, h.state, h.context), h.state = h.__s, null != h.getChildContext && (t = a(a({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), A = null != s && s.type === d && null == s.key ? s.props.children : s, w(n, Array.isArray(A) ? A : [A], u, i, t, r, o, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;\n    } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L(i.__e, u, i, t, r, o, f, c);\n\n    (s = l.diffed) && s(u);\n  } catch (n) {\n    u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l.__e(n, u, i);\n  }\n}\n\nfunction z(n, u) {\n  l.__c && l.__c(u, n), n.some(function (u) {\n    try {\n      n = u.__h, u.__h = [], n.some(function (n) {\n        n.call(u);\n      });\n    } catch (n) {\n      l.__e(n, u.__v);\n    }\n  });\n}\n\nfunction L(l, u, i, t, r, o, f, c) {\n  var s,\n      a,\n      v,\n      y = i.props,\n      p = u.props,\n      d = u.type,\n      _ = 0;\n  if (\"svg\" === d && (r = !0), null != o) for (; _ < o.length; _++) if ((s = o[_]) && \"setAttribute\" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {\n    l = s, o[_] = null;\n    break;\n  }\n\n  if (null == l) {\n    if (null === d) return document.createTextNode(p);\n    l = r ? document.createElementNS(\"http://www.w3.org/2000/svg\", d) : document.createElement(d, p.is && p), o = null, c = !1;\n  }\n\n  if (null === d) y === p || c && l.data === p || (l.data = p);else {\n    if (o = o && n.call(l.childNodes), a = (y = i.props || e).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {\n      if (null != o) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;\n      (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || \"\"));\n    }\n\n    if (C(l, p, y, r, c), v) u.__k = [];else if (_ = u.props.children, w(l, Array.isArray(_) ? _ : [_], u, i, t, r && \"foreignObject\" !== d, o, f, o ? o[0] : i.__k && k(i, 0), c), null != o) for (_ = o.length; _--;) null != o[_] && h(o[_]);\n    c || (\"value\" in p && void 0 !== (_ = p.value) && (_ !== y.value || _ !== l.value || \"progress\" === d && !_) && H(l, \"value\", _, y.value, !1), \"checked\" in p && void 0 !== (_ = p.checked) && _ !== l.checked && H(l, \"checked\", _, y.checked, !1));\n  }\n  return l;\n}\n\nfunction M(n, u, i) {\n  try {\n    \"function\" == typeof n ? n(u) : n.current = u;\n  } catch (n) {\n    l.__e(n, i);\n  }\n}\n\nfunction N(n, u, i) {\n  var t, r;\n\n  if (l.unmount && l.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M(t, null, u)), null != (t = n.__c)) {\n    if (t.componentWillUnmount) try {\n      t.componentWillUnmount();\n    } catch (n) {\n      l.__e(n, u);\n    }\n    t.base = t.__P = null;\n  }\n\n  if (t = n.__k) for (r = 0; r < t.length; r++) t[r] && N(t[r], u, \"function\" != typeof n.type);\n  i || null == n.__e || h(n.__e), n.__e = n.__d = void 0;\n}\n\nfunction O(n, l, u) {\n  return this.constructor(n, u);\n}\n\nfunction S(u, i, t) {\n  var r, o, f;\n  l.__ && l.__(u, i), o = (r = \"function\" == typeof t) ? null : t && t.__k || i.__k, f = [], j(i, u = (!r && t || i).__k = v(d, null, [u]), o || e, e, void 0 !== i.ownerSVGElement, !r && t ? [t] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), z(f, u);\n}\n\nfunction q(n, l) {\n  S(n, l, q);\n}\n\nfunction B(l, u, i) {\n  var t,\n      r,\n      o,\n      f = a({}, l.props);\n\n  for (o in u) \"key\" == o ? t = u[o] : \"ref\" == o ? r = u[o] : f[o] = u[o];\n\n  return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), y(l.type, f, t || l.key, r || l.ref, null);\n}\n\nfunction D(n, l) {\n  var u = {\n    __c: l = \"__cC\" + f++,\n    __: n,\n    Consumer: function (n, l) {\n      return n.children(l);\n    },\n    Provider: function (n) {\n      var u, i;\n      return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {\n        return i;\n      }, this.shouldComponentUpdate = function (n) {\n        this.props.value !== n.value && u.some(m);\n      }, this.sub = function (n) {\n        u.push(n);\n        var l = n.componentWillUnmount;\n\n        n.componentWillUnmount = function () {\n          u.splice(u.indexOf(n), 1), l && l.call(n);\n        };\n      }), n.children;\n    }\n  };\n  return u.Provider.__ = u.Consumer.contextType = u;\n}\n\nn = c.slice, l = {\n  __e: function (n, l) {\n    for (var u, i, t; l = l.__;) if ((u = l.__c) && !u.__) try {\n      if ((i = u.constructor) && null != i.getDerivedStateFromError && (u.setState(i.getDerivedStateFromError(n)), t = u.__d), null != u.componentDidCatch && (u.componentDidCatch(n), t = u.__d), t) return u.__E = u;\n    } catch (l) {\n      n = l;\n    }\n\n    throw n;\n  }\n}, u = 0, i = function (n) {\n  return null != n && void 0 === n.constructor;\n}, _.prototype.setState = function (n, l) {\n  var u;\n  u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), \"function\" == typeof n && (n = n(a({}, u), this.props)), n && a(u, n), null != n && this.__v && (l && this.__h.push(l), m(this));\n}, _.prototype.forceUpdate = function (n) {\n  this.__v && (this.__e = !0, n && this.__h.push(n), m(this));\n}, _.prototype.render = d, t = [], r = \"function\" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g.__r = 0, f = 0;\n\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/preact/dist/preact.module.js?");

/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useState\": () => (/* binding */ l),\n/* harmony export */   \"useReducer\": () => (/* binding */ p),\n/* harmony export */   \"useEffect\": () => (/* binding */ y),\n/* harmony export */   \"useLayoutEffect\": () => (/* binding */ h),\n/* harmony export */   \"useRef\": () => (/* binding */ s),\n/* harmony export */   \"useImperativeHandle\": () => (/* binding */ _),\n/* harmony export */   \"useMemo\": () => (/* binding */ d),\n/* harmony export */   \"useCallback\": () => (/* binding */ A),\n/* harmony export */   \"useContext\": () => (/* binding */ F),\n/* harmony export */   \"useDebugValue\": () => (/* binding */ T),\n/* harmony export */   \"useErrorBoundary\": () => (/* binding */ q)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\nvar t,\n    u,\n    r,\n    o = 0,\n    i = [],\n    c = preact__WEBPACK_IMPORTED_MODULE_0__.options.__b,\n    f = preact__WEBPACK_IMPORTED_MODULE_0__.options.__r,\n    e = preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed,\n    a = preact__WEBPACK_IMPORTED_MODULE_0__.options.__c,\n    v = preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;\n\nfunction m(t, r) {\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.__h && preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(u, t, o || r), o = 0;\n  var i = u.__H || (u.__H = {\n    __: [],\n    __h: []\n  });\n  return t >= i.__.length && i.__.push({}), i.__[t];\n}\n\nfunction l(n) {\n  return o = 1, p(w, n);\n}\n\nfunction p(n, r, o) {\n  var i = m(t++, 2);\n  return i.t = n, i.__c || (i.__ = [o ? o(r) : w(void 0, r), function (n) {\n    var t = i.t(i.__[0], n);\n    i.__[0] !== t && (i.__ = [t, i.__[1]], i.__c.setState({}));\n  }], i.__c = u), i.__;\n}\n\nfunction y(r, o) {\n  var i = m(t++, 3);\n  !preact__WEBPACK_IMPORTED_MODULE_0__.options.__s && k(i.__H, o) && (i.__ = r, i.__H = o, u.__H.__h.push(i));\n}\n\nfunction h(r, o) {\n  var i = m(t++, 4);\n  !preact__WEBPACK_IMPORTED_MODULE_0__.options.__s && k(i.__H, o) && (i.__ = r, i.__H = o, u.__h.push(i));\n}\n\nfunction s(n) {\n  return o = 5, d(function () {\n    return {\n      current: n\n    };\n  }, []);\n}\n\nfunction _(n, t, u) {\n  o = 6, h(function () {\n    \"function\" == typeof n ? n(t()) : n && (n.current = t());\n  }, null == u ? u : u.concat(n));\n}\n\nfunction d(n, u) {\n  var r = m(t++, 7);\n  return k(r.__H, u) && (r.__ = n(), r.__H = u, r.__h = n), r.__;\n}\n\nfunction A(n, t) {\n  return o = 8, d(function () {\n    return n;\n  }, t);\n}\n\nfunction F(n) {\n  var r = u.context[n.__c],\n      o = m(t++, 9);\n  return o.c = n, r ? (null == o.__ && (o.__ = !0, r.sub(u)), r.props.value) : n.__;\n}\n\nfunction T(t, u) {\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue && preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(u ? u(t) : t);\n}\n\nfunction q(n) {\n  var r = m(t++, 10),\n      o = l();\n  return r.__ = n, u.componentDidCatch || (u.componentDidCatch = function (n) {\n    r.__ && r.__(n), o[1](n);\n  }), [o[0], function () {\n    o[1](void 0);\n  }];\n}\n\nfunction x() {\n  var t;\n\n  for (i.sort(function (n, t) {\n    return n.__v.__b - t.__v.__b;\n  }); t = i.pop();) if (t.__P) try {\n    t.__H.__h.forEach(g), t.__H.__h.forEach(j), t.__H.__h = [];\n  } catch (u) {\n    t.__H.__h = [], preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u, t.__v);\n  }\n}\n\npreact__WEBPACK_IMPORTED_MODULE_0__.options.__b = function (n) {\n  u = null, c && c(n);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.__r = function (n) {\n  f && f(n), t = 0;\n  var r = (u = n.__c).__H;\n  r && (r.__h.forEach(g), r.__h.forEach(j), r.__h = []);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed = function (t) {\n  e && e(t);\n  var o = t.__c;\n  o && o.__H && o.__H.__h.length && (1 !== i.push(o) && r === preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame || ((r = preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame) || function (n) {\n    var t,\n        u = function () {\n      clearTimeout(r), b && cancelAnimationFrame(t), setTimeout(n);\n    },\n        r = setTimeout(u, 100);\n\n    b && (t = requestAnimationFrame(u));\n  })(x)), u = null;\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.__c = function (t, u) {\n  u.some(function (t) {\n    try {\n      t.__h.forEach(g), t.__h = t.__h.filter(function (n) {\n        return !n.__ || j(n);\n      });\n    } catch (r) {\n      u.some(function (n) {\n        n.__h && (n.__h = []);\n      }), u = [], preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r, t.__v);\n    }\n  }), a && a(t, u);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount = function (t) {\n  v && v(t);\n  var u,\n      r = t.__c;\n  r && r.__H && (r.__H.__.forEach(function (n) {\n    try {\n      g(n);\n    } catch (n) {\n      u = n;\n    }\n  }), u && preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u, r.__v));\n};\nvar b = \"function\" == typeof requestAnimationFrame;\n\nfunction g(n) {\n  var t = u,\n      r = n.__c;\n  \"function\" == typeof r && (n.__c = void 0, r()), u = t;\n}\n\nfunction j(n) {\n  var t = u;\n  n.__c = n.__(), u = t;\n}\n\nfunction k(n, t) {\n  return !n || n.length !== t.length || t.some(function (t, u) {\n    return t !== n[u];\n  });\n}\n\nfunction w(n, t) {\n  return \"function\" == typeof t ? t(n) : t;\n}\n\n\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/preact/hooks/dist/hooks.module.js?");

/***/ }),

/***/ "./src/App.jsx":
/*!*********************!*\
  !*** ./src/App.jsx ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ \"./node_modules/preact/hooks/dist/hooks.module.js\");\n/* harmony import */ var preact_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! preact-router */ \"./node_modules/preact-router/dist/preact-router.es.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./firebase */ \"./src/firebase/index.js\");\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! firebase/database */ \"./node_modules/firebase/database/dist/index.esm.js\");\n/* harmony import */ var _pages_about_About_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pages/about/About.jsx */ \"./src/pages/about/About.jsx\");\n/* harmony import */ var _pages_learn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pages/learn */ \"./src/pages/learn/index.js\");\n/* harmony import */ var _pages_roadmap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pages/roadmap */ \"./src/pages/roadmap/index.js\");\n/* harmony import */ var _layout_Header_jsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./layout/Header.jsx */ \"./src/layout/Header.jsx\");\n/* harmony import */ var _pages_home_Home_jsx__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pages/home/Home.jsx */ \"./src/pages/home/Home.jsx\");\n/* harmony import */ var _App_styles_scss__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./App.styles.scss */ \"./src/App.styles.scss\");\n/* harmony import */ var _pages_profile__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./pages/profile */ \"./src/pages/profile/index.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n// Core\n\n\n // Firebase\n\n\n // Pages\n\n\n\n // Layout (+ load first page first)\n\n\n // Styles\n\n\n // Default to home URL for bad requests, no need for separate file for this component\n\nfunction Default() {\n  console.log(\"rerouting to url: /\");\n  return (0,preact_router__WEBPACK_IMPORTED_MODULE_2__.route)(\"/\");\n}\n\nfunction Footer() {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"footer\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"This is a WIP. Questions? Contact me by \", (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"mailto:kim.skogsmo@gmail.com\"\n  }, \"@email\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"\\xA9 2021 thinkfrontend\"));\n}\n\nfunction App() {\n  var _useState = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState)([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      roadmaps = _useState2[0],\n      setRoadmaps = _useState2[1];\n\n  (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    return (0,firebase_database__WEBPACK_IMPORTED_MODULE_4__.onValue)((0,firebase_database__WEBPACK_IMPORTED_MODULE_4__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_3__.database, '/roadmaps/'), function (snapshot) {\n      if (snapshot) setRoadmaps(snapshot.val());\n    }, {\n      onlyOnce: true\n    });\n  }, []);\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_layout_Header_jsx__WEBPACK_IMPORTED_MODULE_8__[\"default\"], null), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"main\", {\n    \"class\": \"container\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact_router__WEBPACK_IMPORTED_MODULE_2__[\"default\"], null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_pages_home_Home_jsx__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n    path: \"/\"\n  }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_pages_about_About_jsx__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n    path: \"/about\"\n  }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_pages_profile__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n    path: \"/profile\"\n  }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_pages_learn__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n    path: \"/learn\",\n    roadmaps: roadmaps\n  }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_pages_roadmap__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n    path: \"/roadmap/:id\"\n  }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(Default, {\n    \"default\": true\n  }))), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(Footer, null));\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n\n//# sourceURL=webpack://thinkfrontend/./src/App.jsx?");

/***/ }),

/***/ "./src/components/roadmap-list/RoadmapList.jsx":
/*!*****************************************************!*\
  !*** ./src/components/roadmap-list/RoadmapList.jsx ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RoadmapList)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ \"./node_modules/preact/hooks/dist/hooks.module.js\");\n/* harmony import */ var _RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RoadmapList.styles.scss */ \"./src/components/roadmap-list/RoadmapList.styles.scss\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\nfunction Resource(_ref) {\n  var name = _ref.name;\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    \"class\": \"resource\"\n  }, name);\n}\n\nfunction Article(_ref2) {\n  var id = _ref2.id,\n      slug = _ref2.slug,\n      from = _ref2.from,\n      leadsTo = _ref2.leadsTo,\n      name = _ref2.name,\n      _ref2$resources = _ref2.resources,\n      resources = _ref2$resources === void 0 ? [] : _ref2$resources;\n\n  var _useState = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState)(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      articleOpen = _useState2[0],\n      setArticleOpen = _useState2[1];\n\n  var handleOpenArticle = function handleOpenArticle() {\n    setArticleOpen(function (a) {\n      return a = !a;\n    });\n  };\n\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    role: \"button\",\n    href: \"/roadmap/\".concat(id),\n    \"data-tooltip\": \"coming soon...\",\n    \"aria-disabled\": true\n  }, name, articleOpen && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    \"class\": \"detailed\"\n  }, resources.map(function (resource) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", {\n      \"data-tooltip\": \"coming soon...\"\n    }, resource.name);\n  })));\n}\n\nfunction RoadmapList(_ref3) {\n  var roadmaps = _ref3.roadmaps;\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, roadmaps && roadmaps.length && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"section\", {\n    className: \"roadmaps\"\n  }, roadmaps.map(function (roadmap) {\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(Article, {\n      slug: roadmap.slug,\n      id: roadmap.id,\n      name: roadmap.name\n    });\n  })));\n}\n\n//# sourceURL=webpack://thinkfrontend/./src/components/roadmap-list/RoadmapList.jsx?");

/***/ }),

/***/ "./src/components/roadmap-list/index.js":
/*!**********************************************!*\
  !*** ./src/components/roadmap-list/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _RoadmapList_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RoadmapList.jsx */ \"./src/components/roadmap-list/RoadmapList.jsx\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_RoadmapList_jsx__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://thinkfrontend/./src/components/roadmap-list/index.js?");

/***/ }),

/***/ "./src/firebase/index.js":
/*!*******************************!*\
  !*** ./src/firebase/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"database\": () => (/* binding */ database)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"./node_modules/firebase/app/dist/index.esm.js\");\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/database */ \"./node_modules/firebase/database/dist/index.esm.js\");\n\n\nvar firebaseConfig = {\n  apiKey: \"AIzaSyCgmCFjCdmv-MrY-gSPfCUA5CntGEbIQ5Q\",\n  authDomain: \"thinkfrontend.firebaseapp.com\",\n  databaseURL: \"https://thinkfrontend-default-rtdb.europe-west1.firebasedatabase.app\",\n  projectId: \"thinkfrontend\",\n  messagingSenderId: \"343893954644\",\n  appId: \"1:343893954644:web:dae4bb274f6018c2019dc1\",\n  measurementId: \"G-52LEV0DYV4\"\n};\nvar app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig); // Get a reference to the database service\n\nvar database = (0,firebase_database__WEBPACK_IMPORTED_MODULE_1__.getDatabase)(app);\n\n\n//# sourceURL=webpack://thinkfrontend/./src/firebase/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _App_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.jsx */ \"./src/App.jsx\");\n/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.scss */ \"./src/index.scss\");\n\n\n\n(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_App_jsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"], null), document.getElementById('root'));\n\n//# sourceURL=webpack://thinkfrontend/./src/index.js?");

/***/ }),

/***/ "./src/layout/Header.jsx":
/*!*******************************!*\
  !*** ./src/layout/Header.jsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Header)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _Header_styles_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Header.styles.scss */ \"./src/layout/Header.styles.scss\");\n/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! preact/hooks */ \"./node_modules/preact/hooks/dist/hooks.module.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\nfunction Header() {\n  var _useState = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_2__.useState)(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      menuOpen = _useState2[0],\n      setMenuOpen = _useState2[1];\n\n  var handleMenuClick = function handleMenuClick() {\n    setMenuOpen(function (m) {\n      return m = !m;\n    });\n  };\n\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"nav\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    \"class\": \"logo\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", null, \"think\", (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"strong\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"i\", null, \"dev\"))))), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    \"class\": \"right\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/profile\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    className: \"profile search\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\", {\n    d: \"M17.754 14a2.249 2.249 0 0 1 2.25 2.249v.918a2.75 2.75 0 0 1-.513 1.599C17.945 20.929 15.42 22 12 22c-3.422 0-5.945-1.072-7.487-3.237a2.75 2.75 0 0 1-.51-1.595v-.92a2.249 2.249 0 0 1 2.249-2.25h11.501ZM12 2.004a5 5 0 1 1 0 10 5 5 0 0 1 0-10Z\",\n    fill: \"#212121\"\n  })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", null, \"Profile\"))), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    \"class\": \"menu\",\n    onClick: handleMenuClick\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\", {\n    d: \"M21 18.251a2.249 2.249 0 0 0-2.25-2.249H5.25a2.249 2.249 0 1 0 0 4.498h13.5A2.249 2.249 0 0 0 21 18.251Zm-4-6.5a2.249 2.249 0 0 0-2.25-2.249h-9.5a2.25 2.25 0 1 0 0 4.498h9.5A2.249 2.249 0 0 0 17 11.751Zm-4-6.5a2.25 2.25 0 0 0-2.25-2.25l-5.5.001a2.25 2.25 0 0 0 0 4.498h5.5A2.25 2.25 0 0 0 13 5.251Z\",\n    fill: \"#212121\"\n  })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", null, \"Menu\"))), menuOpen && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    \"class\": \"dropDown\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"ul\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"li\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/\",\n    onClick: function onClick() {\n      return handleMenuClick();\n    }\n  }, \"Home\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"li\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/learn\",\n    onClick: function onClick() {\n      return handleMenuClick();\n    }\n  }, \"Learn\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"li\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/profile\",\n    onClick: function onClick() {\n      return handleMenuClick();\n    }\n  }, \"Profile\"))), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    \"class\": \"close\",\n    onClick: handleMenuClick\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\", {\n    height: \"512px\",\n    id: \"Layer_1\",\n    style: \"enable-background:new 0 0 512 512;\",\n    version: \"1.1\",\n    viewBox: \"0 0 512 512\",\n    width: \"512px\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\", {\n    d: \"M443.6,387.1L312.4,255.4l131.5-130c5.4-5.4,5.4-14.2,0-19.6l-37.4-37.6c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4  L256,197.8L124.9,68.3c-2.6-2.6-6.1-4-9.8-4c-3.7,0-7.2,1.5-9.8,4L68,105.9c-5.4,5.4-5.4,14.2,0,19.6l131.5,130L68.4,387.1  c-2.6,2.6-4.1,6.1-4.1,9.8c0,3.7,1.4,7.2,4.1,9.8l37.4,37.6c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1L256,313.1l130.7,131.1  c2.7,2.7,6.2,4.1,9.8,4.1c3.5,0,7.1-1.3,9.8-4.1l37.4-37.6c2.6-2.6,4.1-6.1,4.1-9.8C447.7,393.2,446.2,389.7,443.6,387.1z\"\n  })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", null, \"Close\"))));\n}\n\n//# sourceURL=webpack://thinkfrontend/./src/layout/Header.jsx?");

/***/ }),

/***/ "./src/pages/about/About.jsx":
/*!***********************************!*\
  !*** ./src/pages/about/About.jsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ About)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\nfunction About() {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", null, \"About Kim\", (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/learn\"\n  }, \"Learn!\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/\"\n  }, \"back home!\"));\n}\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/about/About.jsx?");

/***/ }),

/***/ "./src/pages/home/Home.jsx":
/*!*********************************!*\
  !*** ./src/pages/home/Home.jsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _Home_styles_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Home.styles.scss */ \"./src/pages/home/Home.styles.scss\");\n\n\nfunction Home() {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"header\", {\n    className: \"--jumbo\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h1\", null, \"Get good at code\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"This is going to be a tool for sharing interactive roadmaps for learning\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    role: \"button\",\n    href: \"/learn\"\n  }, \"Start learning now\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"section\", {\n    \"class\": \"grid\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    \"class\": \"card\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\", {\n    d: \"M17 4a1 1 0 1 1 0-2h4a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V5.414l-5.793 5.793a1 1 0 0 1-1.414 0L10 8.414l-5.293 5.293a1 1 0 0 1-1.414-1.414l6-6a1 1 0 0 1 1.414 0L13.5 9.086 18.586 4H17ZM5 18v3a1 1 0 1 1-2 0v-3a1 1 0 1 1 2 0Zm5-4a1 1 0 1 0-2 0v7a1 1 0 1 0 2 0v-7Zm4 1a1 1 0 0 1 1 1v5a1 1 0 1 1-2 0v-5a1 1 0 0 1 1-1Zm6-4a1 1 0 1 0-2 0v10a1 1 0 1 0 2 0V11Z\",\n    fill: \"#fff\"\n  })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h3\", null, \"Track your progress\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"All your stuff will be saved. Imagine following a road map and being able to get right back to where you started later? That's what it will be.\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    className: \"card\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\", {\n    d: \"M11 5.5a3.5 3.5 0 0 1-3 3.465V11.5h6.25a2.25 2.25 0 0 0 2.25-2.25v-.395A3.502 3.502 0 0 1 17.5 2a3.5 3.5 0 0 1 .5 6.965v.285A3.75 3.75 0 0 1 14.25 13H8v2.035a3.5 3.5 0 1 1-1.5.11v-6.29A3.502 3.502 0 0 1 7.5 2 3.5 3.5 0 0 1 11 5.5Z\",\n    fill: \"#fff\"\n  })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h3\", null, \"Get creative\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"Think stuff is missing from other roadmaps out there? Create a fork, and make your own, or start from scratch!\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    className: \"card\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\", {\n    d: \"M6.248 16.002c.966 0 1.75.784 1.75 1.75v2.498A1.75 1.75 0 0 1 6.248 22H3.75A1.75 1.75 0 0 1 2 20.25v-2.498c0-.966.784-1.75 1.75-1.75h2.498ZM9.748 18h11.505a.75.75 0 0 1 .102 1.493l-.102.007H9.748a.75.75 0 0 1-.102-1.493L9.748 18h11.505H9.748Zm-3.5-8.999c.966 0 1.75.784 1.75 1.75v2.498a1.75 1.75 0 0 1-1.75 1.75H3.75A1.75 1.75 0 0 1 2 13.249V10.75c0-.966.784-1.75 1.75-1.75h2.498ZM9.748 11h11.505a.75.75 0 0 1 .102 1.493l-.102.007H9.748a.75.75 0 0 1-.102-1.493L9.748 11h11.505H9.748Zm-3.5-9c.966 0 1.75.784 1.75 1.75v2.498a1.75 1.75 0 0 1-1.75 1.75H3.75A1.75 1.75 0 0 1 2 6.248V3.75C2 2.784 2.784 2 3.75 2h2.498Zm3.5 2h11.505a.75.75 0 0 1 .102 1.493l-.102.007H9.748a.75.75 0 0 1-.102-1.493L9.748 4h11.505H9.748Z\",\n    fill: \"#212121\"\n  })), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h3\", null, \"Challenjour...?\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"This site would be completely useless if you couldn't challenge your friends on completing a roadmap.\"))));\n}\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/home/Home.jsx?");

/***/ }),

/***/ "./src/pages/learn/Learn.jsx":
/*!***********************************!*\
  !*** ./src/pages/learn/Learn.jsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Learn)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _Learn_styles_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Learn.styles.scss */ \"./src/pages/learn/Learn.styles.scss\");\n/* harmony import */ var _components_roadmap_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/roadmap-list */ \"./src/components/roadmap-list/index.js\");\n\n\n\nfunction Learn(_ref) {\n  var roadmaps = _ref.roadmaps;\n  var progress = false;\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"header\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h1\", null, \"Learn\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"Choose a path to get started.\")), progress && // This wont show for now, see const progress = false ^\n  (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h3\", null, \"Your progress\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", null, \"Your progress\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_components_roadmap_list__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n    roadmaps: roadmaps\n  }));\n}\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/learn/Learn.jsx?");

/***/ }),

/***/ "./src/pages/learn/index.js":
/*!**********************************!*\
  !*** ./src/pages/learn/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Learn_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Learn.jsx */ \"./src/pages/learn/Learn.jsx\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Learn_jsx__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/learn/index.js?");

/***/ }),

/***/ "./src/pages/profile/Profile.jsx":
/*!***************************************!*\
  !*** ./src/pages/profile/Profile.jsx ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Profile)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\nfunction Profile(_ref) {\n  var roadmaps = _ref.roadmaps;\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"header\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h1\", null, \"Your profile\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"Track your amazing progress, create and update roadmaps, and challenge your friends from here.\")), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"article\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h2\", null, \"Stats\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    className: 'stats'\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"If you had any stats, you would get stats!\"))), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"article\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h2\", null, \"Your roadmaps\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"No roadmaps yet... bah!\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/create-roadmap\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"button\", null, \"Create one?\"))), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"article\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h2\", null, \"Challenges\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"You haven't submitted or received any challenges yet...\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", {\n    href: \"/challenge-friend\"\n  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"button\", null, \"Challenge someone now!\"))), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"article\", null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h3\", null, \"Your details\"), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"Coming soon\")));\n}\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/profile/Profile.jsx?");

/***/ }),

/***/ "./src/pages/profile/index.js":
/*!************************************!*\
  !*** ./src/pages/profile/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Profile_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Profile.jsx */ \"./src/pages/profile/Profile.jsx\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Profile_jsx__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/profile/index.js?");

/***/ }),

/***/ "./src/pages/roadmap/Roadmap.jsx":
/*!***************************************!*\
  !*** ./src/pages/roadmap/Roadmap.jsx ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Roadmap)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ \"./node_modules/preact/hooks/dist/hooks.module.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../firebase */ \"./src/firebase/index.js\");\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/database */ \"./node_modules/firebase/database/dist/index.esm.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n // Firebase\n\n\n\nfunction Roadmap(_ref) {\n  var id = _ref.id;\n\n  var _useState = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState)(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      roadmap = _useState2[0],\n      setRoadmap = _useState2[1];\n\n  (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    return (0,firebase_database__WEBPACK_IMPORTED_MODULE_3__.onValue)((0,firebase_database__WEBPACK_IMPORTED_MODULE_3__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.database, '/roadmaps/' + id), function (snapshot) {\n      if (snapshot.exists()) {\n        setRoadmap(function (r) {\n          return r = snapshot.val();\n        });\n      }\n    }, {\n      onlyOnce: false\n    });\n  }, []);\n  (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    console.log(\"retrieved roadmap\", roadmap);\n  }, [roadmap]);\n  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, roadmap && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"header\", null, roadmap.name && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"h1\", null, roadmap.name), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"p\", null, \"Everything about frontend development. Get started with getting to know more about browsers, common tools and some terminology. Move on to the languages of the web and more.\"))\n  /*<RoadmapTree />*/\n  , !roadmap && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", null, \"loading...\"));\n}\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/roadmap/Roadmap.jsx?");

/***/ }),

/***/ "./src/pages/roadmap/index.js":
/*!************************************!*\
  !*** ./src/pages/roadmap/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Roadmap_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Roadmap.jsx */ \"./src/pages/roadmap/Roadmap.jsx\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Roadmap_jsx__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/roadmap/index.js?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/App.styles.scss":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/App.styles.scss ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"@font-face {\\n  font-family: \\\"Krub\\\";\\n  font-style: normal;\\n  font-weight: 300;\\n  src: local(\\\"\\\"), url(\" + __webpack_require__(/*! ./assets/fonts/krub-v4-latin-300.woff2 */ \"./src/assets/fonts/krub-v4-latin-300.woff2\") + \") format(\\\"woff2\\\"), url(\" + __webpack_require__(/*! ./assets/fonts/krub-v4-latin-300.woff */ \"./src/assets/fonts/krub-v4-latin-300.woff\") + \") format(\\\"woff\\\");\\n  /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */\\n}\\n@font-face {\\n  font-family: \\\"Krub\\\";\\n  font-style: normal;\\n  font-weight: 400;\\n  src: local(\\\"\\\"), url(\" + __webpack_require__(/*! ./assets/fonts/krub-v4-latin-regular.woff2 */ \"./src/assets/fonts/krub-v4-latin-regular.woff2\") + \") format(\\\"woff2\\\"), url(\" + __webpack_require__(/*! ./assets/fonts/krub-v4-latin-regular.woff */ \"./src/assets/fonts/krub-v4-latin-regular.woff\") + \") format(\\\"woff\\\");\\n  /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */\\n}\\n@font-face {\\n  font-family: \\\"Krub\\\";\\n  font-style: normal;\\n  font-weight: 700;\\n  src: local(\\\"\\\"), url(\" + __webpack_require__(/*! ./assets/fonts/krub-v4-latin-700.woff2 */ \"./src/assets/fonts/krub-v4-latin-700.woff2\") + \") format(\\\"woff2\\\"), url(\" + __webpack_require__(/*! ./assets/fonts/krub-v4-latin-700.woff */ \"./src/assets/fonts/krub-v4-latin-700.woff\") + \") format(\\\"woff\\\");\\n  /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */\\n}\\n/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */\\nhtml {\\n  line-height: 1.15;\\n  -webkit-text-size-adjust: 100%;\\n}\\n\\nbody {\\n  margin: 0;\\n}\\n\\nmain {\\n  display: block;\\n}\\n\\nh1 {\\n  font-size: 2em;\\n  margin: 0.67em 0;\\n}\\n\\nhr {\\n  box-sizing: content-box;\\n  height: 0;\\n  overflow: visible;\\n}\\n\\npre {\\n  font-family: monospace, monospace;\\n  font-size: 1em;\\n}\\n\\na {\\n  background-color: transparent;\\n}\\n\\nabbr[title] {\\n  border-bottom: none;\\n  text-decoration: underline;\\n  text-decoration: underline dotted;\\n}\\n\\nb, strong {\\n  font-weight: bolder;\\n}\\n\\ncode, kbd, samp {\\n  font-family: monospace, monospace;\\n  font-size: 1em;\\n}\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\nsub, sup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\nimg {\\n  border-style: none;\\n}\\n\\nbutton, input, optgroup, select, textarea {\\n  font-family: inherit;\\n  font-size: 100%;\\n  line-height: 1.15;\\n  margin: 0;\\n}\\n\\nbutton, input {\\n  overflow: visible;\\n}\\n\\nbutton, select {\\n  text-transform: none;\\n}\\n\\n[type=button], [type=reset], [type=submit], button {\\n  -webkit-appearance: button;\\n}\\n\\n[type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner, button::-moz-focus-inner {\\n  border-style: none;\\n  padding: 0;\\n}\\n\\n[type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring, button:-moz-focusring {\\n  outline: 1px dotted ButtonText;\\n}\\n\\nfieldset {\\n  padding: 0.35em 0.75em 0.625em;\\n}\\n\\nlegend {\\n  box-sizing: border-box;\\n  color: inherit;\\n  display: table;\\n  max-width: 100%;\\n  padding: 0;\\n  white-space: normal;\\n}\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\ntextarea {\\n  overflow: auto;\\n}\\n\\n[type=checkbox], [type=radio] {\\n  box-sizing: border-box;\\n  padding: 0;\\n}\\n\\n[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n[type=search] {\\n  -webkit-appearance: textfield;\\n  outline-offset: -2px;\\n}\\n\\n[type=search]::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button;\\n  font: inherit;\\n}\\n\\ndetails {\\n  display: block;\\n}\\n\\nsummary {\\n  display: list-item;\\n}\\n\\ntemplate {\\n  display: none;\\n}\\n\\n[hidden] {\\n  display: none;\\n}\\n\\n/* ! Overrides\\n *\\n *  Add your theme overrides here, if you are not happy with normalize.css\\n */\\nh1, h2, h3, h4, h5, h6 {\\n  margin: 0.618rem 0 1rem 0;\\n}\\n\\np {\\n  line-height: var(--line-height);\\n}\\n\\nheader {\\n  margin: 3rem 0;\\n}\\nheader h1 {\\n  font-size: 2.618rem;\\n}\\nheader.\\\\--jumbo {\\n  margin: 5rem 0;\\n}\\nheader.\\\\--jumbo h1 {\\n  font-size: 3rem;\\n}\\n\\nhtml, html body {\\n  font-family: \\\"Open Sans\\\", sans-serif;\\n}\\nhtml body {\\n  overflow-y: scroll;\\n}\\nhtml body * {\\n  user-select: none;\\n}\\nhtml body p {\\n  user-select: none;\\n}\\nhtml body .\\\\--selectable::selection {\\n  background: rgba(255, 255, 200, 0.33);\\n}\\n\\nfooter {\\n  margin-top: auto;\\n  background: rgba(0, 0, 0, 0.65);\\n  padding: 1.618rem;\\n  width: 100vw;\\n  display: flex;\\n  align-items: center;\\n  flex-direction: column;\\n  justify-content: center;\\n  gap: 0.5rem;\\n}\\n@media screen and (max-width: 1024px) {\\n  footer {\\n    right: 0;\\n    bottom: 0;\\n  }\\n}\\nfooter p, footer a {\\n  font-family: monospace;\\n  font-size: 0.8rem;\\n  margin: 0;\\n}\\n\\n* {\\n  font-family: \\\"Krub\\\", sans-serif;\\n  font-weight: 300;\\n  font-size: 0.8rem;\\n}\\n*::selection {\\n  background: rgba(176, 64, 64, 0.352);\\n}\\n\\n#root {\\n  text-align: center;\\n  display: flex;\\n  flex-direction: column;\\n  height: 100vh;\\n}\\n#root .App-logo {\\n  animation: App-logo-spin infinite 20s linear;\\n  height: 80px;\\n}\\n#root .App-header {\\n  background-color: #222;\\n  height: 150px;\\n  padding: 20px;\\n  color: white;\\n}\\n#root .App-intro {\\n  font-size: large;\\n}\\n\\n@keyframes App-logo-spin {\\n  from {\\n    transform: rotate(0deg);\\n  }\\n  to {\\n    transform: rotate(360deg);\\n  }\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack://thinkfrontend/./src/App.styles.scss?./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/components/roadmap-list/RoadmapList.styles.scss":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/components/roadmap-list/RoadmapList.styles.scss ***!
  \***************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".roadmaps {\\n  width: 100%;\\n  max-width: 800px;\\n  display: flex;\\n  gap: 1rem;\\n  flex-wrap: wrap;\\n  justify-content: center;\\n  align-items: center;\\n  margin: auto;\\n  margin-bottom: 2rem;\\n  background: transparent;\\n}\\n\\na {\\n  text-decoration: none;\\n}\\n\\na[role=button] {\\n  border-radius: 2rem;\\n  font-weight: bold;\\n  font-size: 0.9rem;\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack://thinkfrontend/./src/components/roadmap-list/RoadmapList.styles.scss?./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/index.scss":
/*!**************************************************************************************************!*\
  !*** ./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/index.scss ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"body {\\n  margin: 0;\\n  padding: 0;\\n  font-family: sans-serif;\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack://thinkfrontend/./src/index.scss?./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/layout/Header.styles.scss":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/layout/Header.styles.scss ***!
  \*****************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"nav {\\n  background: var(--header-color);\\n  padding: 1rem;\\n  justify-content: space-between;\\n  position: relative;\\n}\\nnav, nav .logo, nav .menu, nav .search {\\n  display: flex;\\n  align-items: center;\\n}\\nnav .logo {\\n  text-decoration: none;\\n}\\nnav .logo span {\\n  color: #f9f9f9;\\n  font-weight: bold;\\n  text-decoration: none;\\n}\\nnav .logo span, nav .logo i {\\n  font-size: 1rem;\\n}\\nnav .logo svg path {\\n  fill: #721919;\\n}\\nnav .right {\\n  display: flex;\\n  gap: 1rem;\\n}\\nnav .right .menu, nav .right .search {\\n  display: flex;\\n  gap: 0.25rem;\\n  cursor: pointer;\\n}\\nnav .right .menu:hover svg path, nav .right .search:hover svg path {\\n  fill: #721919;\\n}\\nnav .right .menu span, nav .right .search span {\\n  color: #eee;\\n}\\nnav .right .menu svg path, nav .right .search svg path {\\n  fill: #eee;\\n}\\nnav .dropDown {\\n  position: absolute;\\n  color: white;\\n  top: 0;\\n  left: 0;\\n  height: 100vh;\\n  width: 100vw;\\n  background-color: black;\\n  cursor: unset;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\nnav .dropDown ul {\\n  list-style-type: none;\\n  padding: 0;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25rem;\\n  font-size: 1.2rem;\\n}\\nnav .dropDown ul li {\\n  margin: 0;\\n}\\nnav .dropDown ul li::marker {\\n  display: none;\\n  color: transparent;\\n}\\nnav .dropDown ul li a {\\n  padding: 0.618rem 1.618rem;\\n  color: white;\\n  font-weight: 500;\\n  font-size: 1.2rem;\\n  background: transparent;\\n  border-radius: 8rem;\\n  transition: 0.125s all ease-in-out;\\n}\\nnav .dropDown ul li a:hover {\\n  background: white;\\n  color: black;\\n}\\nnav .dropDown .close {\\n  position: absolute;\\n  top: 2rem;\\n  right: 2rem;\\n  cursor: pointer;\\n  display: flex;\\n  align-items: center;\\n  gap: 0.5rem;\\n  justify-content: center;\\n}\\nnav .dropDown .close svg {\\n  height: 20px;\\n  width: 20px;\\n}\\nnav .dropDown .close svg path {\\n  fill: #eee;\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack://thinkfrontend/./src/layout/Header.styles.scss?./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/pages/home/Home.styles.scss":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/pages/home/Home.styles.scss ***!
  \*******************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".card > div {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  gap: 0.5rem;\\n}\\n.card svg path {\\n  fill: var(--primary);\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/home/Home.styles.scss?./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/pages/learn/Learn.styles.scss":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/pages/learn/Learn.styles.scss ***!
  \*********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".roadmapList {\\n  background: white;\\n  gap: 0.5rem;\\n  display: flex;\\n  justify-content: center;\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/learn/Learn.styles.scss?./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./src/assets/fonts/krub-v4-latin-300.woff":
/*!*************************************************!*\
  !*** ./src/assets/fonts/krub-v4-latin-300.woff ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"fonts/krub-v4-latin-300.woff\");\n\n//# sourceURL=webpack://thinkfrontend/./src/assets/fonts/krub-v4-latin-300.woff?");

/***/ }),

/***/ "./src/assets/fonts/krub-v4-latin-300.woff2":
/*!**************************************************!*\
  !*** ./src/assets/fonts/krub-v4-latin-300.woff2 ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"fonts/krub-v4-latin-300.woff2\");\n\n//# sourceURL=webpack://thinkfrontend/./src/assets/fonts/krub-v4-latin-300.woff2?");

/***/ }),

/***/ "./src/assets/fonts/krub-v4-latin-700.woff":
/*!*************************************************!*\
  !*** ./src/assets/fonts/krub-v4-latin-700.woff ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"fonts/krub-v4-latin-700.woff\");\n\n//# sourceURL=webpack://thinkfrontend/./src/assets/fonts/krub-v4-latin-700.woff?");

/***/ }),

/***/ "./src/assets/fonts/krub-v4-latin-700.woff2":
/*!**************************************************!*\
  !*** ./src/assets/fonts/krub-v4-latin-700.woff2 ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"fonts/krub-v4-latin-700.woff2\");\n\n//# sourceURL=webpack://thinkfrontend/./src/assets/fonts/krub-v4-latin-700.woff2?");

/***/ }),

/***/ "./src/assets/fonts/krub-v4-latin-regular.woff":
/*!*****************************************************!*\
  !*** ./src/assets/fonts/krub-v4-latin-regular.woff ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"fonts/krub-v4-latin-regular.woff\");\n\n//# sourceURL=webpack://thinkfrontend/./src/assets/fonts/krub-v4-latin-regular.woff?");

/***/ }),

/***/ "./src/assets/fonts/krub-v4-latin-regular.woff2":
/*!******************************************************!*\
  !*** ./src/assets/fonts/krub-v4-latin-regular.woff2 ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"fonts/krub-v4-latin-regular.woff2\");\n\n//# sourceURL=webpack://thinkfrontend/./src/assets/fonts/krub-v4-latin-regular.woff2?");

/***/ }),

/***/ "./src/App.styles.scss":
/*!*****************************!*\
  !*** ./src/App.styles.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/index.js!../node_modules/sass-loader/dist/cjs.js!./App.styles.scss */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/App.styles.scss\");\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()), options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()) && (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) ? (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_App_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) : undefined);\n\n\n//# sourceURL=webpack://thinkfrontend/./src/App.styles.scss?");

/***/ }),

/***/ "./src/components/roadmap-list/RoadmapList.styles.scss":
/*!*************************************************************!*\
  !*** ./src/components/roadmap-list/RoadmapList.styles.scss ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./RoadmapList.styles.scss */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/components/roadmap-list/RoadmapList.styles.scss\");\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()), options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()) && (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) ? (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_RoadmapList_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) : undefined);\n\n\n//# sourceURL=webpack://thinkfrontend/./src/components/roadmap-list/RoadmapList.styles.scss?");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/index.js!../node_modules/sass-loader/dist/cjs.js!./index.scss */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/index.scss\");\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6___default()), options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6___default()) && (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) ? (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_index_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) : undefined);\n\n\n//# sourceURL=webpack://thinkfrontend/./src/index.scss?");

/***/ }),

/***/ "./src/layout/Header.styles.scss":
/*!***************************************!*\
  !*** ./src/layout/Header.styles.scss ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./Header.styles.scss */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/layout/Header.styles.scss\");\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()), options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()) && (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) ? (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Header_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) : undefined);\n\n\n//# sourceURL=webpack://thinkfrontend/./src/layout/Header.styles.scss?");

/***/ }),

/***/ "./src/pages/home/Home.styles.scss":
/*!*****************************************!*\
  !*** ./src/pages/home/Home.styles.scss ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Home.styles.scss */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/pages/home/Home.styles.scss\");\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()), options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()) && (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) ? (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Home_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) : undefined);\n\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/home/Home.styles.scss?");

/***/ }),

/***/ "./src/pages/learn/Learn.styles.scss":
/*!*******************************************!*\
  !*** ./src/pages/learn/Learn.styles.scss ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/dist/cjs.js!./Learn.styles.scss */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./src/pages/learn/Learn.styles.scss\");\n/* harmony import */ var _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()), options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6___default()) && (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) ? (_node_modules_css_loader_index_js_node_modules_sass_loader_dist_cjs_js_Learn_styles_scss__WEBPACK_IMPORTED_MODULE_6___default().locals) : undefined);\n\n\n//# sourceURL=webpack://thinkfrontend/./src/pages/learn/Learn.styles.scss?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://thinkfrontend/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;